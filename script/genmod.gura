#!/usr/bin/env gurax
import(argopt)

//------------------------------------------------------------------------------
// Template of build.gura
//------------------------------------------------------------------------------
tmpl_build = tR'''
#!/usr/bin/env gurax
//==============================================================================
// build.gura
//==============================================================================
import(util.modbuild) {Builder}

b = Builder('${dotModuleName}')
b.pathNamesSrc = ['module-${ubarModuleName}.cpp']
b.pathNamesScript = []
b.dirNamesInc = []
b.dirNamesLib = []
b.cflags = []
b.ldflags = []
b.libs = []
b.Run()
'''

//------------------------------------------------------------------------------
// Template of test-${ubarModuleName}.gura
//------------------------------------------------------------------------------
tmpl_test = tR'''
#!/usr/bin/env gurax
//==============================================================================
// test-${ubarModuleName}.gura
//==============================================================================
import(util.tester) {*}
import(${dotModuleName})

TestCase('Basic test') {
	Println(${dotModuleName}.Test('hello', 4))
}
'''

//------------------------------------------------------------------------------
// Template of stdafx.h
//------------------------------------------------------------------------------
tmpl_stdafx = tR'''
//==============================================================================
// stdafx.h
//==============================================================================
#include "${fileName_header}"
'''

//------------------------------------------------------------------------------
// Template of module-${ubarModuleName}.h
//------------------------------------------------------------------------------
tmpl_header = tR'''
//==============================================================================
// ${fileName_header}
//==============================================================================
#ifndef GURAX_MODULE_${ubarModuleName.Upper()}_H
#define GURAX_MODULE_${ubarModuleName.Upper()}_H
#include <gurax.h>

Gurax_BeginModuleHeader(${ubarModuleName})
Gurax_EndModuleHeader(${ubarModuleName})

#endif
'''

//------------------------------------------------------------------------------
// Template of module-${ubarModuleName}.cpp
//------------------------------------------------------------------------------
tmpl_source = tR'''
//==============================================================================
// ${fileName_main}
//==============================================================================
#include "stdafx.h"

Gurax_BeginModule(${ubarModuleName})

//------------------------------------------------------------------------------
// Implementation of function
//------------------------------------------------------------------------------
// re.Test()
Gurax_DeclareFunction(Test)
{
	Declare(VTYPE_Number, Flag::None);
	DeclareArg("str", VTYPE_String, ArgOccur::Once, ArgFlag::None);
	DeclareArg("num", VTYPE_Number, ArgOccur::Once, ArgFlag::None);
	AddHelp(
		Gurax_Symbol(en),
		"Adds up the given two numbers and returns the result.");
}

Gurax_ImplementFunction(Test)
{
	// Arguments
	ArgPicker args(argument);
	const char* str = args.PickString();
	Int num = args.PickNumber<Int>();
	// Function body
	return new Value_String(String::Repeat(str, num));
}

//------------------------------------------------------------------------------
// Entries
//------------------------------------------------------------------------------
Gurax_ModuleValidate()
{
	return Version::CheckCoreVersion(GURAX_VERSION, nullptr);
}

Gurax_ModulePrepare()
{
	// Assignment of function
	Assign(Gurax_CreateFunction(Test));
	return true;
}

Gurax_ModuleTerminate()
{
}

Gurax_EndModule(${ubarModuleName})
'''

strHelp = tR'''
Generates a set of files to build a Gura binary module.
usage: genmod.gura module-name
'''

//------------------------------------------------------------------------------
// main
//------------------------------------------------------------------------------
main() = {
	[argv, opt] = argopt.Parser {|p|
		p.AddFlag('force', 'f', 'forcibly overwrites existing files')
		p.AddFlag('here', 'h', 'create files in the current directory')
		p.Parse(sys.argv)
	}
	if (argv.len < 1) {
		sys.cerr.Print(strHelp)
		sys.Exit(1)
	}
	fields = path.FileName(argv[0]).Split('.'):list
	dotModuleName = fields.Join('.')
	ubarModuleName = fields.Join('_')
	baseName = fields[-1]
	if (opt['here']) {
		dirNameOut = ''
	} else {
		dirNameOut = cond(opt['here'], '', 'module-' + ubarModuleName)
		!fs.Exists(dirNameOut) && fs.CreateDir(dirNameOut)
	}
	fileName_build = 'build.gura'
	fileName_test = 'test-' + ubarModuleName + '.gura'
	fileName_stdafx = 'stdafx.h'
	fileName_header = 'module-' + ubarModuleName + '.h'
	fileName_main = 'module-' + ubarModuleName + '.cpp'
	pathName_build = path.Join(dirNameOut, fileName_build)
	pathName_test = path.Join(dirNameOut, fileName_test)
	pathName_stdafx = path.Join(dirNameOut, fileName_stdafx)
	pathName_header = path.Join(dirNameOut, fileName_header)
	pathName_main = path.Join(dirNameOut, fileName_main)
	if (!opt['force'] && \
		fs.Exists([pathName_build, pathName_test, pathName_stdafx, pathName_header, pathName_main]).Or()) {
		sys.cerr.Println('file already exists')
		sys.Exit(1)
	}
	tmpl_build.Render(Open(pathName_build, 'w'))
	tmpl_test.Render(Open(pathName_test, 'w'))
	tmpl_stdafx.Render(Open(pathName_stdafx, 'w'))
	tmpl_header.Render(Open(pathName_header, 'w'))
	tmpl_source.Render(Open(pathName_main, 'w'))
	fs.ChangeMode(pathName_build, 'a+x')
	fs.ChangeMode(pathName_test, 'a+x')
	tR'''
	Following files were generated for the ${dotModuleName} module.
	- Build Script: ${pathName_build}
	- Test Script:  ${pathName_test}
	- Source Files: ${pathName_stdafx}
	                ${pathName_header}
	                ${pathName_main}
	'''.Render(sys.cout)
}

main()
