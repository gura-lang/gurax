#!/usr/bin/env gurax
import(argopt)

//------------------------------------------------------------------------------
// Template of CMakeLists.txt
//------------------------------------------------------------------------------
tmpl_cmake = tR'''
#===============================================================================
# CMakeLists for module: ${dotModuleName}
#===============================================================================
cmake_minimum_required(VERSION 3.16)
project(gurax_module_${ubarModuleName})

include_directories($\{PROJECT_SOURCE_DIR}/../../include)
link_directories($\{PROJECT_SOURCE_DIR}/../../lib)
include_directories(md5 sha1)
add_library(${ubarModuleName} SHARED
    module-${ubarModuleName}.cpp
    Util.cpp
)
target_link_libraries(${ubarModuleName} guraxcore)
add_definitions(-DGURAX_MODULE_SEPARATED)
set(CMAKE_SHARED_LIBRARY_SUFFIX .gurd)
set(CMAKE_INSTALL_PREFIX $\{PROJECT_SOURCE_DIR}/../..)
target_precompile_headers(${ubarModuleName} PUBLIC stdafx.h)
install(TARGETS ${ubarModuleName} RUNTIME DESTINATION module/site)
'''

//------------------------------------------------------------------------------
// Template of test-${ubarModuleName}.gura
//------------------------------------------------------------------------------
tmpl_test = tR'''
#!/usr/bin/env gurax
//==============================================================================
// test-${ubarModuleName}.gura
//==============================================================================
import(util.tester) {*}
import(${dotModuleName})

TestCase('Basic test') {
	Println(${dotModuleName}.Test('hello', 4))
}
'''

//------------------------------------------------------------------------------
// Template of stdafx.h
//------------------------------------------------------------------------------
tmpl_stdafx = tR'''
//==============================================================================
// stdafx.h
//==============================================================================
#include "${fileName_mainHdr}"
'''

//------------------------------------------------------------------------------
// Template of module-${ubarModuleName}.h
//------------------------------------------------------------------------------
tmpl_mainHdr = tR'''
//==============================================================================
// ${fileName_mainHdr}
//==============================================================================
#ifndef GURAX_MODULE_${ubarModuleName.Upper()}_H
#define GURAX_MODULE_${ubarModuleName.Upper()}_H
#include <gurax.h>
#include "Util.h"

Gurax_BeginModuleHeader(${ubarModuleName})
Gurax_EndModuleHeader(${ubarModuleName})

#endif
'''

//------------------------------------------------------------------------------
// Template of module-${ubarModuleName}.cpp
//------------------------------------------------------------------------------
tmpl_mainSrc = tR'''
//==============================================================================
// ${fileName_mainSrc}
//==============================================================================
#include "stdafx.h"

Gurax_BeginModule(${ubarModuleName})

//------------------------------------------------------------------------------
// Implementation of function
//------------------------------------------------------------------------------
// ${dotModuleName}.Test()
Gurax_DeclareFunction(Test)
{
	Declare(VTYPE_Number, Flag::None);
	DeclareArg("str", VTYPE_String, ArgOccur::Once, ArgFlag::None);
	DeclareArg("num", VTYPE_Number, ArgOccur::Once, ArgFlag::None);
	AddHelp(
		Gurax_Symbol(en),
		"Adds up the given two numbers and returns the result.");
}

Gurax_ImplementFunction(Test)
{
	// Arguments
	ArgPicker args(argument);
	const char* str = args.PickString();
	Int num = args.PickNumber<Int>();
	// Function body
	return new Value_String(String::Repeat(str, num));
}

//------------------------------------------------------------------------------
// Entries
//------------------------------------------------------------------------------
Gurax_ModuleValidate()
{
	return Version::CheckCoreVersion(GURAX_VERSION, nullptr);
}

Gurax_ModulePrepare()
{
	// Assignment of function
	Assign(Gurax_CreateFunction(Test));
	return true;
}

Gurax_ModuleTerminate()
{
}

Gurax_EndModule(${ubarModuleName})
'''

//------------------------------------------------------------------------------
// Template of Util.h
//------------------------------------------------------------------------------
tmpl_utilHdr = tR'''
//==============================================================================
// Util.h
//==============================================================================
#ifndef GURAX_MODULE_${ubarModuleName.Upper()}_UTIL_H
#define GURAX_MODULE_${ubarModuleName.Upper()}_UTIL_H
#include <gurax.h>

Gurax_BeginModuleScope(${ubarModuleName})
Gurax_EndModuleScope(${ubarModuleName})

#endif
'''

//------------------------------------------------------------------------------
// Template of Util.cpp
//------------------------------------------------------------------------------
tmpl_utilSrc = tR'''
//==============================================================================
// Util.cpp
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(${ubarModuleName})
Gurax_EndModuleScope(${ubarModuleName})
'''

tmplHelp = tR'''
Generates a set of files to build a Gura binary module.
usage: genmod.gura module-name
options:
  ${p.FormatHelp() + '\n'}
'''

//------------------------------------------------------------------------------
// main
//------------------------------------------------------------------------------
main() = {
	argopt.Parser {|p|
		p.AddFlag('force', 'f', 'forcibly overwrites existing files')
		p.AddFlag('here', 'h', 'create files in the current directory')
		[argv, opt] = p.Parse(sys.argv)
		if (argv.len < 1) {
			tmplHelp.Render(sys.cerr)
			sys.Exit(1)
		}
	}
	fields = path.FileName(argv[0]).Split('.'):list
	dotModuleName = fields.Join('.')
	ubarModuleName = fields.Join('_')
	baseName = fields[-1]
	if (opt['here']) {
		dirNameOut = ''
	} else {
		dirNameOut = cond(opt['here'], '', 'module-' + ubarModuleName)
		!fs.Exists(dirNameOut) && fs.CreateDir(dirNameOut)
	}
	fileName_cmake = 'CMakeLists.txt'
	fileName_test = 'test-' + ubarModuleName + '.gura'
	fileName_stdafx = 'stdafx.h'
	fileName_mainHdr = 'module-' + ubarModuleName + '.h'
	fileName_mainSrc = 'module-' + ubarModuleName + '.cpp'
	fileName_utilHdr = 'Util.h'
	fileName_utilSrc = 'Util.cpp'
	dirNameBuild = path.Join(dirNameOut, 'build')
	pathName_cmake = path.Join(dirNameOut, fileName_cmake)
	pathName_test = path.Join(dirNameOut, fileName_test)
	pathName_stdafx = path.Join(dirNameOut, fileName_stdafx)
	pathName_mainHdr = path.Join(dirNameOut, fileName_mainHdr)
	pathName_mainSrc = path.Join(dirNameOut, fileName_mainSrc)
	pathName_utilHdr = path.Join(dirNameOut, fileName_utilHdr)
	pathName_utilSrc = path.Join(dirNameOut, fileName_utilSrc)
	if (!opt['force'] && \
		fs.Exists([pathName_cmake, pathName_test, pathName_stdafx,
			pathName_mainHdr, pathName_mainSrc, pathName_utilHdr, pathName_utilSrc]).Or()) {
		sys.cerr.Println('file already exists')
		sys.Exit(1)
	}
	tmpl_cmake.Render(Open(pathName_cmake, 'w'))
	tmpl_test.Render(Open(pathName_test, 'w'))
	tmpl_stdafx.Render(Open(pathName_stdafx, 'w'))
	tmpl_mainHdr.Render(Open(pathName_mainHdr, 'w'))
	tmpl_mainSrc.Render(Open(pathName_mainSrc, 'w'))
	tmpl_utilHdr.Render(Open(pathName_utilHdr, 'w'))
	tmpl_utilSrc.Render(Open(pathName_utilSrc, 'w'))
	fs.ChangeMode(pathName_cmake, 'a+x')
	fs.ChangeMode(pathName_test, 'a+x')
	tR'''
	To configure the project:
	  $ cmake -B build
	To clean generated files:
	  $ cmake --build build -t clean
	To build and install a Debug edition:
	  $ cmake --build build --config Debug
	  $ cmake --install build . --config Debug
	To build and install a Release edition:
	  $ cmake --build build . --config Release
	  $ cmake --install build . --config Release
	'''.Render(sys.cout)
}

main()
