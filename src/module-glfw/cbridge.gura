#!/usr/bin/env gurax

//------------------------------------------------------------------------------
// ErrorDone
//------------------------------------------------------------------------------
ErrorDone(expr:Expr, msg:String) = {
	sys.cerr.Printf('line.%d: %s\n', expr.lineNoTop, msg)
	sys.Exit(1)
}

//------------------------------------------------------------------------------
// TypeInfo
//------------------------------------------------------------------------------
TypeInfo = class {
	decl:String
	moduleName:String
	cType:String
	vtype:String
	tmplPicker:Template
	tmplPickerValidation:Template
	tmplPickerListVar:Template
	tmplFunctionBody:Template
	map:static = %{}
	__init__(decl:String, moduleName, cType:String, vtype:String,
			codePicker:String, codePickerValidation:String,
			codePickerVec:String, codeFunctionBody:String) = {
		this.decl = decl, this.moduleName = moduleName, this.cType = cType, this.vtype = vtype
		this.tmplPicker = Template().Parse(codePicker)
		this.tmplPickerValidation = Template().Parse(codePickerValidation)
		this.tmplPickerListVar = Template().Parse(codePickerVec)
		this.tmplFunctionBody = Template().Parse(codeFunctionBody)
		this.map[this.decl] = this
	}
	ComposePicker(varName:String, listVarFlag:Bool, validationFlag:Bool) = {
		cond(listVarFlag, this.tmplPickerListVar, cond(validationFlag, this.tmplPickerValidation, this.tmplPicker)).Eval()
	}
	ComposeFunctionBody(caller:String) = this.tmplFunctionBody.Eval()
	MakeFullTypeName() = cond(this.moduleName.IsEmpty(), this.vtype, this.moduleName + '.' + this.vtype)
}

TypeInfo('any', '', '', 'Any', '', '', '', '')

TypeInfo('void', '', 'void', 'Nil', '', '', '',
	R'''
	${caller};
	return Value::nil();
	''')

TypeInfo('String', '', '', 'String', '', '', '', '')

TypeInfo('Function', '', '', 'Function',
	R'''
	RefPtr<Function> ${varName}(args.PickFunction().Reference());
	''', R'''
	RefPtr<Function> ${varName}(args.IsValid()? args.PickFunction().Reference() : nullptr);
	''', '', '')

TypeInfo_Number(decl:String, moduleName:String, cType:String) = TypeInfo(decl, moduleName, cType, 'Number',
	R'''
	${this.cType} ${varName} = args.PickNumber<${this.cType}>();
	''', R'''
	${this.cType} ${varName} = args.IsValid()? args.PickNumber<${this.cType}>() : 0;
	''', R'''
	auto ${varName} = args.PickNumList<${this.cType}>();
	''', R'''
	${this.cType} rtn = ${caller};
	return new Value_${this.vtype}(rtn);
	''')

TypeInfo_Number('char', '', 'char')
TypeInfo_Number('short', '', 'short')
TypeInfo_Number('long', '', 'long')
TypeInfo_Number('int', '', 'int')
TypeInfo_Number('long_long', '', 'long long')
TypeInfo_Number('float', '', 'float')
TypeInfo_Number('double', '', 'double')
TypeInfo_Number('unsigned_char', '', 'unsigned char')
TypeInfo_Number('unsigned_short', '', 'unsigned short')
TypeInfo_Number('unsigned_long', '', 'unsigned long')
TypeInfo_Number('unsigned_int', '', 'unsigned int')
TypeInfo_Number('unsigned_long_long', '', 'unsigned long long')
TypeInfo_Number('int8_t', '', 'int8_t')
TypeInfo_Number('int16_t', '', 'int16_t')
TypeInfo_Number('int32_t', '', 'int32_t')
TypeInfo_Number('int64_t', '', 'int64_t')
TypeInfo_Number('uint8_t', '', 'uint8_t')
TypeInfo_Number('uint16_t', '', 'uint16_t')
TypeInfo_Number('uint32_t', '', 'uint32_t')
TypeInfo_Number('uint64_t', '', 'uint64_t')
TypeInfo_Number('Char', '', 'Char')
TypeInfo_Number('UChar', '', 'UChar')
TypeInfo_Number('Short', '', 'Short')
TypeInfo_Number('UShort', '', 'UShort')
TypeInfo_Number('Int', '', 'Int')
TypeInfo_Number('UInt', '', 'UInt')
TypeInfo_Number('Long', '', 'Long')
TypeInfo_Number('ULong', '', 'ULong')
TypeInfo_Number('Int8', '', 'Int8')
TypeInfo_Number('UInt8', '', 'UInt8')
TypeInfo_Number('Int16', '', 'Int16')
TypeInfo_Number('UInt16', '', 'UInt16')
TypeInfo_Number('Int32', '', 'Int32')
TypeInfo_Number('UInt32', '', 'UInt32')
TypeInfo_Number('Int64', '', 'Int64')
TypeInfo_Number('UInt64', '', 'UInt64')
TypeInfo_Number('Float', '', 'Float')
TypeInfo_Number('Double', '', 'Double')

@(TypeInfo) {
	{ 'bool', '', 'bool', 'Bool',
		R'''
		${this.cType} ${varName} = args.PickBool();
		''', R'''
		${this.cType} ${varName} = args.IsValid()? args.PickBool() : false;
		''', R'''
		auto ${varName} = args.PickVector<bool>(Value_${this.vtype}::ValueForVector);
		''', R'''
		${this.cType} rtn = ${caller};
		return new Value_${this.vtype}(rtn);
		''' }
	{ 'Bool', '', 'Bool', 'Bool',
		R'''
		${this.cType} ${varName} = args.PickBool();
		''', R'''
		${this.cType} ${varName} = args.IsValid()? args.PickBool() : false;
		''', R'''
		auto ${varName} = args.PickVector<bool>(Value_${this.vtype}::ValueForVector);
		''', R'''
		${this.cType} rtn = ${caller};
		return new Value_${this.vtype}(rtn);
		''' }
	{ 'const_char_p', '', 'const char*', 'String',
		R'''
		${this.cType} ${varName} = args.PickString();
		''', R'''
		${this.cType} ${varName} = args.IsValid()? args.PickString() : nullptr;
		''', R'''
		auto ${varName} = args.PickVector<${this.cType}>(Value_${this.vtype}::ValueForVector);
		''', R'''
		${this.cType} rtn = ${caller};
		return new Value_${this.vtype}(rtn);
		''' }
	{ 'const_char_p_NilIfNull', '', 'const char*', 'String', '', '', '',
		R'''
		if (${this.cType} rtn = ${caller}) {
			return new Value_${this.vtype}(rtn);
		}
		return Value::nil();
		''' }
}

//------------------------------------------------------------------------------
// ArgInfo
//------------------------------------------------------------------------------
ArgInfo = class {
	name:String
	type:String
	listVarFlag:Bool
	optionFlag:Bool
	nilFlag:Bool
	typeInfo:TypeInfo
	tmplDeclaration:Template:static
	tmplImplementation:Template:static
	__init__(name:String, attr:Attribute, listVarFlag:Bool, optionFlag:Bool) = {
		this.name = name
		this.type = attr.dottedName
		this.listVarFlag = listVarFlag
		this.optionFlag = optionFlag
		this.nilFlag = attr.IsSet(`nil)
		this.typeInfo = TypeInfo.map[this.type]
	}
	ComposeDeclaration() = {
		strArgOccur = 'ArgOccur::' + cond(this.optionFlag, 'ZeroOrOnce', 'Once')
		argFlags = []
		this.listVarFlag && argFlags.Add('ListVar')
		this.nilFlag && argFlags.Add('Nil')
		argFlags.IsEmpty() && argFlags.Add('None')
		strArgFlags = ('ArgFlag::' + argFlags).Join(' | ')
		this.tmplDeclaration.Eval()
	}
	ComposeImplementation() = this.typeInfo.ComposePicker(
			this.name, this.listVarFlag, this.optionFlag || this.nilFlag)
	ToString() = Format('%s%s%s:%s%s', this.name, cond(this.listVarFlag, '[]', ''),
			cond(this.optionFlag, '?', ''), this.typeInfo.MakeFullTypeName(),
			cond(this.nilFlag, ':nil', ''))
}

ArgInfo.tmplDeclaration = tR'''
DeclareArg("${this.name}", VTYPE_${this.typeInfo.vtype}, ${strArgOccur}, ${strArgFlags});
'''

//------------------------------------------------------------------------------
// FuncInfo
//------------------------------------------------------------------------------
FuncInfo = class {
	moduleName:String
	name:String
	type:String
	typeInfo:TypeInfo
	argInfoTbl[]:ArgInfo = []
	tmplFunctionBody:Template
	tmplImplementation:Template:static
	tmplAssignment:Template:static
	ComposeImplementation() = this.tmplImplementation.Eval()
	ComposeAssignment() = this.tmplAssignment.Eval()
	__init__(moduleName:String, name:String, type:String, codeFunctionBody:String:nil) = {
		this.moduleName = moduleName, this.name = name, this.type = type
		this.typeInfo = TypeInfo.map[type]
		if (codeFunctionBody) { this.tmplFunctionBody = Template().Parse(codeFunctionBody) }
	}
	ComposeCaller() = {
		Format('%s(%s)', this.name, this.argInfoTbl:*name.Join(', ')) 
	}
	ToString() = Format('%s.%s(%s)', this.moduleName, this.name, this.argInfoTbl:*ToString().Join(', '))
}

FuncInfo.tmplImplementation = tR'''
// ${this.ToString()}
Gurax_DeclareFunction(${this.name})
{
	Declare(VTYPE_${this.typeInfo.vtype}, Flag::None);
	${this.argInfoTbl::ComposeDeclaration()}
	AddHelp(
		Gurax_Symbol(en),
		"");
}

Gurax_ImplementFunction(${this.name})
{
	${if (!this.argInfoTbl.IsEmpty())}
	// Arguments
	ArgPicker args(argument);
	${this.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (this.tmplFunctionBody)}
	${this.tmplFunctionBody.Eval()}
	${else}
	${this.typeInfo.ComposeFunctionBody(this.ComposeCaller())}
	${end}
}
'''

FuncInfo.tmplAssignment = t'Assign(Gurax_CreateFunction(${this.name}));'

//------------------------------------------------------------------------------
// Renderer
//------------------------------------------------------------------------------
Renderer = class {
	funcInfoTbl = []
	Register(moduleName:String) {`block} = this.RegisterExpr(moduleName, block.EachElem())
	RegisterExpr(moduleName:String, expr:Expr):map:void = {
		codeFunctionBody = nil
		if (expr.IsAssign()) {
			!expr.right.IsString() && ErrorDone(expr, 'assigned value must be a string')
			codeFunctionBody = expr.right.string
			expr = expr.left
		}
		!expr.IsCaller() && ErrorDone(expr, 'Caller is expected')
		!expr.car.IsIdentifier() && ErrorDone(expr, 'Identifier is expected')
		funcInfo = FuncInfo(moduleName, expr.car.symbolName, expr.attr.dottedName, codeFunctionBody)
		this.funcInfoTbl.Add(funcInfo)
		expr.EachParam {|exprParam|
			//Println(exprParam)
			listVarFlag = false
			optionFlag = false
			if (exprParam.IsUnaryOp()) {
				if (exprParam.operator.symbol == `?) {
					optionFlag = true
				} else {
					ErrorDone(exprParam, 'invalid format of parameter')
				}
				exprParam = exprParam.child
			}
			attr = exprParam.attr
			if (exprParam.IsIndexer()) {
				listVarFlag = true
				exprParam = exprParam.car
			}
			!exprParam.IsIdentifier() && ErrorDone(exprParam, 'Identifier is expected in parameter list')
			argInfo = ArgInfo(exprParam.symbolName, attr, listVarFlag, optionFlag)
			funcInfo.argInfoTbl.Add(argInfo)
		}
	}
	ComposeImplementation() = this.funcInfoTbl:*ComposeImplementation().Join('\n')
	ComposeAssignment(codePrefix:String) = (codePrefix + this.funcInfoTbl:*ComposeAssignment()).Join('\n')
}
