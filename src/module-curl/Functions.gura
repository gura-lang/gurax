#!/usr/bin/env gurax
import(cbridge)

r = cbridge.Renderer()

//------------------------------------------------------------------------------
// Type Information
//------------------------------------------------------------------------------
cbridge.Renderer.DeclareType_Entity(decl:String, cType:String, vtypeFullName:String) = \
this.DeclareType(decl, cType, vtypeFullName,
	codePicker = R'''
	auto& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
	${this.cType}& ${varName} = value_${varName}.GetEntity();
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<${this.cType}>(Value_${this.vtype}::ValueForVector);
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Value_${this.vtype}(rtn);
	''')

cbridge.Renderer.DeclareType_EntityPtr(decl:String, cType:String, vtypeFullName:String) = \
this.DeclareType(decl, cType, vtypeFullName,
	codePicker = R'''
	auto& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
	${this.cType} ${varName} = value_${varName}.GetEntityPtr();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr() : nullptr;
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	if (!rtn) return Value::nil();
	return new Value_${this.vtype}(rtn);
	''')

r.DeclareType_Number('CURLcode')
r.DeclareType_Number('CURLSHcode')
r.DeclareType_Number('CURLFORMcode')
r.DeclareType_Number('CURLoption')
r.DeclareType_Number('CURLINFO')

r.DeclareType('SDL_bool', 'SDL_bool', 'Bool',
	codePicker = R'''
	${this.cType} ${varName} = static_cast<SDL_bool>(args_gurax.PickBool());
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? static_cast<SDL_bool>(args_gurax.PickBool()) : SDL_FALSE;
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<SDL_bool>([](Gurax::Value& value) {
		return value.GetBool()? SDL_TRUE : SDL_FALSE;
	});
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Gurax::Value_Bool(!!rtn);
	''')

r.DeclareType_EntityPtr('CURL_p', 'CURL*', 'CURL')
r.DeclareType_EntityPtr('curl_mime_p', 'curl_mime*', 'curl_mime')
r.DeclareType_EntityPtr('curl_mimepart_p', 'curl_mimepart*', 'curl_mimepart')

//------------------------------------------------------------------------------
// Function Registration
//------------------------------------------------------------------------------
// easy.h
r.Register('curl') {

curl_easy_init():CURL_p

curl_easy_setopt(curl:CURL_p, option:CURLoption, value:any) = \
	R'''
	long optType = static_cast<long>(option) / 10000 * 10000;
	CURLcode code = CURLE_OK;
	if (optType == CURLOPTTYPE_LONG) {
		if (!value.IsInstanceOf(VTYPE_Number)) {
			Error::Issue(ErrorType::TypeError, "the option accepts Number value");
			return Value::nil();
		}
		code = curl_easy_setopt(curl, option, Value_Number::GetNumber<long>(value));
	} else if (optType == CURLOPTTYPE_OBJECTPOINT) {
		switch (option) {
		case CURLOPT_WRITEDATA:
			value_curl.pValue_WRITE.reset(value.Reference());
			break;
		case CURLOPT_READDATA:
			value_curl.pValue_READ.reset(value.Reference());
			break;
		case CURLOPT_PROGRESSDATA:
			value_curl.pValue_PROGRESS.reset(value.Reference());
			break;
		case CURLOPT_HEADERDATA:
			value_curl.pValue_HEADER.reset(value.Reference());
			break;
		case CURLOPT_DEBUGDATA:
			value_curl.pValue_DEBUG.reset(value.Reference());
			break;
		case CURLOPT_SSL_CTX_DATA:
			value_curl.pValue_SSL_CTX.reset(value.Reference());
			break;
		case CURLOPT_IOCTLDATA:
			value_curl.pValue_IOCTL.reset(value.Reference());
			break;
		//case CURLOPT_CONV_FROM_NETWORK_DATA:
		//	value_curl.pValue_CONV_FROM_NETWORK.reset(value.Reference());
		//	break;
		//case CURLOPT_CONV_TO_NETWORK_DATA:
		//	value_curl.pValue_CONV_TO_NETWORK.reset(value.Reference());
		//	break;
		//case CURLOPT_CONV_FROM_UTF8_DATA:
		//	value_curl.pValue_CONV_FROM_UTF8.reset(value.Reference());
		//	break;
		case CURLOPT_SOCKOPTDATA:
			value_curl.pValue_SOCKOPT.reset(value.Reference());
			break;
		case CURLOPT_OPENSOCKETDATA:
			value_curl.pValue_OPENSOCKET.reset(value.Reference());
			break;
		case CURLOPT_SEEKDATA:
			value_curl.pValue_SEEK.reset(value.Reference());
			break;
		case CURLOPT_SSH_KEYDATA:
			value_curl.pValue_SSH_KEY.reset(value.Reference());
			break;
		case CURLOPT_INTERLEAVEDATA:
			value_curl.pValue_INTERLEAVE.reset(value.Reference());
			break;
		//case CURLOPT_CHUNK_BGN_DATA:
		//	value_curl.pValue_CHUNK_BGN.reset(value.Reference());
		//	break;
		//case CURLOPT_CHUNK_END_DATA:
		//	value_curl.pValue_CHUNK_END.reset(value.Reference());
		//	break;
		case CURLOPT_FNMATCH_DATA:
			value_curl.pValue_FNMATCH.reset(value.Reference());
			break;
		case CURLOPT_CLOSESOCKETDATA:
			value_curl.pValue_CLOSESOCKET.reset(value.Reference());
			break;
		//case CURLOPT_XFERINFODATA:
		//	value_curl.pValue_XFERINFO.reset(value.Reference());
		//	break;
		case CURLOPT_RESOLVER_START_DATA:
			value_curl.pValue_RESOLVER_START.reset(value.Reference());
			break;
		case CURLOPT_TRAILERDATA:
			value_curl.pValue_TRAILER.reset(value.Reference());
			break;
		default:
			if (!value.IsInstanceOf(VTYPE_String)) {
				Error::Issue(ErrorType::TypeError, "the option accepts String value");
				return Value::nil();
			}
			code = curl_easy_setopt(curl, option, Value_String::GetString(value));
		}
	} else if (optType == CURLOPTTYPE_FUNCTIONPOINT) {
		if (!value.IsInstanceOf(VTYPE_Function)) {
			Error::Issue(ErrorType::TypeError, "the option accepts Function value");
			return Value::nil();
		}
		const Function& func = Value_Function::GetFunction(value);
		switch (option) {
		case CURLOPT_WRITEFUNCTION:
			value_curl.pFunc_WRITE.reset(func.Reference());
			break;
		case CURLOPT_READFUNCTION:
			value_curl.pFunc_READ.reset(func.Reference());
			break;
		case CURLOPT_PROGRESSFUNCTION:
			value_curl.pFunc_PROGRESS.reset(func.Reference());
			break;
		case CURLOPT_HEADERFUNCTION:
			value_curl.pFunc_HEADER.reset(func.Reference());
			break;
		case CURLOPT_DEBUGFUNCTION:
			value_curl.pFunc_DEBUG.reset(func.Reference());
			break;
		case CURLOPT_SSL_CTX_FUNCTION:
			value_curl.pFunc_SSL_CTX.reset(func.Reference());
			break;
		case CURLOPT_IOCTLFUNCTION:
			value_curl.pFunc_IOCTL.reset(func.Reference());
			break;
		case CURLOPT_CONV_FROM_NETWORK_FUNCTION:
			value_curl.pFunc_CONV_FROM_NETWORK.reset(func.Reference());
			break;
		case CURLOPT_CONV_TO_NETWORK_FUNCTION:
			value_curl.pFunc_CONV_TO_NETWORK.reset(func.Reference());
			break;
		case CURLOPT_CONV_FROM_UTF8_FUNCTION:
			value_curl.pFunc_CONV_FROM_UTF8.reset(func.Reference());
			break;
		case CURLOPT_SOCKOPTFUNCTION:
			value_curl.pFunc_SOCKOPT.reset(func.Reference());
			break;
		case CURLOPT_OPENSOCKETFUNCTION:
			value_curl.pFunc_OPENSOCKET.reset(func.Reference());
			break;
		case CURLOPT_SEEKFUNCTION:
			value_curl.pFunc_SEEK.reset(func.Reference());
			break;
		case CURLOPT_SSH_KEYFUNCTION:
			value_curl.pFunc_SSH_KEY.reset(func.Reference());
			break;
		case CURLOPT_INTERLEAVEFUNCTION:
			value_curl.pFunc_INTERLEAVE.reset(func.Reference());
			break;
		case CURLOPT_CHUNK_BGN_FUNCTION:
			value_curl.pFunc_CHUNK_BGN.reset(func.Reference());
			break;
		case CURLOPT_CHUNK_END_FUNCTION:
			value_curl.pFunc_CHUNK_END.reset(func.Reference());
			break;
		case CURLOPT_FNMATCH_FUNCTION:
			value_curl.pFunc_FNMATCH.reset(func.Reference());
			break;
		case CURLOPT_CLOSESOCKETFUNCTION:
			value_curl.pFunc_CLOSESOCKET.reset(func.Reference());
			break;
		case CURLOPT_XFERINFOFUNCTION:
			value_curl.pFunc_XFERINFO.reset(func.Reference());
			break;
		case CURLOPT_RESOLVER_START_FUNCTION:
			value_curl.pFunc_RESOLVER_START.reset(func.Reference());
			break;
		case CURLOPT_TRAILERFUNCTION:
			value_curl.pFunc_TRAILER.reset(func.Reference());
			break;
		default:
			break;
		}
	} else if (optType == CURLOPTTYPE_OFF_T) {
		if (!value.IsInstanceOf(VTYPE_Number)) {
			Error::Issue(ErrorType::TypeError, "the option accepts Number value");
			return Value::nil();
		}
		code = curl_easy_setopt(curl, option, Value_Number::GetNumber<size_t>(value));
	} else if (optType == CURLOPTTYPE_BLOB) {

	}
	return new Value_Number(code);
	'''

curl_easy_perform(curl:CURL_p):CURLcode

curl_easy_cleanup(curl:CURL_p):void

curl_easy_getinfo(curl:CURL_p, info:CURLINFO) = \
	R'''
	RefPtr<Value> pValueRtn(Value::nil());
	long infoType = info & CURLINFO_TYPEMASK;
	if (infoType == CURLINFO_STRING) {
		const char* value;
		curl_easy_getinfo(curl, info, &value);
		pValueRtn.reset(new Value_String(value));
	} else if (infoType == CURLINFO_LONG) {
		long value;
		curl_easy_getinfo(curl, info, &value);
		pValueRtn.reset(new Value_Number(value));
	} else if (infoType == CURLINFO_DOUBLE) {
		double value;
		curl_easy_getinfo(curl, info, &value);
		pValueRtn.reset(new Value_Number(value));
	} else if (infoType == CURLINFO_SLIST) {
		curl_slist* slist = nullptr;
		curl_easy_getinfo(curl, info, &slist);
		RefPtr<ValueOwner> pValues(CreateValueOwnerFromSList(slist));
		curl_free(slist);
		pValueRtn.reset(new Value_List(VTYPE_String, pValues.release()));
	} else if (infoType == CURLINFO_PTR) {
	} else if (infoType == CURLINFO_SOCKET) {
	} else if (infoType == CURLINFO_OFF_T) {
		curl_off_t value;
		curl_easy_getinfo(curl, info, &value);
		pValueRtn.reset(new Value_Number(value));
	}
	return pValueRtn.release();
	'''

curl_easy_duphandle(curl:CURL_p):CURL_p

curl_easy_reset(curl:CURL_p):void

//CURLcode curl_easy_recv(curl:CURL_p, void *buffer, size_t buflen, size_t *n);

//CURLcode curl_easy_send(curl:CURL_p, const void *buffer, size_t buflen, size_t *n);

curl_easy_upkeep(curl:CURL_p):CURLcode;

}

// curl.h
r.Register('curl') {

//curl_strequal(s1:const_char_p, s2:const_char_p):int;

//curl_strnequal(s1:const_char_p, s2:const_char_p, size_t n):int;

curl_mime_init(easy:CURL_p):curl_mime_p;

curl_mime_free(mime:curl_mime_p):void;

curl_mime_addpart(mime:curl_mime_p):curl_mimepart_p;

curl_mime_name(part:curl_mimepart_p, name:const_char_p):CURLcode

curl_mime_filename(part:curl_mimepart_p, filename:const_char_p):CURLcode

curl_mime_type(part:curl_mimepart_p, mimetype:const_char_p):CURLcode

curl_mime_encoder(part:curl_mimepart_p, encoding:const_char_p):CURLcode

//curl_mime_data(part:curl_mimepart_p, data:const_char_p, size_t datasize):CURLcode

curl_mime_filedata(part:curl_mimepart_p, filename:const_char_p):CURLcode

//curl_mime_data_cb(part:curl_mimepart_p, curl_off_t datasize, curl_read_callback readfunc, curl_seek_callback seekfunc, curl_free_callback freefunc, void *arg):CURLcode

curl_mime_subparts(part:curl_mimepart_p, subparts:curl_mime_p):CURLcode

//curl_mime_headers(part:curl_mimepart_p, struct curl_slist *headers, int take_ownership):CURLcode

/*
curl_formadd(struct curl_httppost **httppost, struct curl_httppost **last_post, ...):CURLFORMcode

curl_formget(form:curl_httppost_p, void *arg, curl_formget_callback append):int

curl_formfree(form:curl_httppost_p):void
*/

/*
char *curl_getenv(variable:const_char_p);

char *curl_version(void);

char *curl_easy_escape(handle:CURL_p, string:const_char_p, int length);

char *curl_escape(string:const_char_p, string:const_char_p, int length);

char *curl_easy_unescape(handle:CURL_p, string:const_char_p, int length, int *outlength);

char *curl_unescape(string:const_char_p, int length);
*/
//curl_free(void *p):void
/*
curl_global_init(long flags):CURLcode

curl_global_init_mem(long flags, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c):CURLcode

curl_global_cleanup(void):void

CURLsslset curl_global_sslset(curl_sslbackend id, const char *name, const curl_ssl_backend ***avail);

struct curl_slist *curl_slist_append(struct curl_slist *, const char *);

curl_slist_free_all(struct curl_slist *):void

time_t curl_getdate(p:const_char_p, const time_t *unused);

CURLSH *curl_share_init(void);

CURLSHcode curl_share_setopt(CURLSH *, CURLSHoption option, ...);

CURLSHcode curl_share_cleanup(CURLSH *);

curl_version_info_data *curl_version_info(CURLversion);
*/

curl_easy_strerror(code:CURLcode):const_char_p

curl_share_strerror(code:CURLSHcode):const_char_p

curl_easy_pause(handle:CURL_p, bitmask:int):CURLcode

}

tR'''
//==============================================================================
// Functions.cpp
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(curl)

${r.ComposeImplementation()}

void AssignFunctions(Frame& frame)
{
	${r.ComposeAssignment('frame.')}
}

Gurax_EndModuleScope(curl)
'''.Render('Functions.cpp')
