#!/usr/bin/env gurax
import(cbridge)

r = cbridge.Renderer()

//------------------------------------------------------------------------------
// Type Information
//------------------------------------------------------------------------------
cbridge.Renderer.DeclareType_Entity(decl:String, cType:String, vtypeFullName:String) = \
this.DeclareType(decl, cType, vtypeFullName,
	codePicker = R'''
	auto& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
	${this.cType}& ${varName} = value_${varName}.GetEntity();
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<${this.cType}>(Value_${this.vtype}::ValueForVector);
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Value_${this.vtype}(rtn);
	''')

cbridge.Renderer.DeclareType_EntityPtr(decl:String, cType:String, vtypeFullName:String) = \
this.DeclareType(decl, cType, vtypeFullName,
	codePicker = R'''
	auto& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
	${this.cType} ${varName} = value_${varName}.GetEntityPtr();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr() : nullptr;
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	if (!rtn) return Value::nil();
	return new Value_${this.vtype}(rtn);
	''')

r.DeclareType_Number('CURLcode')
r.DeclareType_Number('CURLoption')
r.DeclareType_Number('CURLINFO')

r.DeclareType('SDL_bool', 'SDL_bool', 'Bool',
	codePicker = R'''
	${this.cType} ${varName} = static_cast<SDL_bool>(args_gurax.PickBool());
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? static_cast<SDL_bool>(args_gurax.PickBool()) : SDL_FALSE;
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<SDL_bool>([](Gurax::Value& value) {
		return value.GetBool()? SDL_TRUE : SDL_FALSE;
	});
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Gurax::Value_Bool(!!rtn);
	''')

r.DeclareType_EntityPtr('CURL_p', 'CURL*', 'CURL')

//------------------------------------------------------------------------------
// Function Registration
//------------------------------------------------------------------------------
r.Register('curl') {

curl_easy_init():CURL_p

curl_easy_setopt(curl:CURL_p, option:CURLoption, value:any) = \
	R'''
	long optType = static_cast<long>(option) / 10000 * 10000;
	CURLcode code = CURLE_OK;
	if (optType == CURLOPTTYPE_LONG) {
		if (!value.IsInstanceOf(VTYPE_Number)) {
			Error::Issue(ErrorType::TypeError, "the option accepts Number value");
			return Value::nil();
		}
		code = curl_easy_setopt(curl, option, Value_Number::GetNumber<long>(value));
	} else if (optType == CURLOPTTYPE_OBJECTPOINT) {
		if (!value.IsInstanceOf(VTYPE_String)) {
			Error::Issue(ErrorType::TypeError, "the option accepts String value");
			return Value::nil();
		}
		code = curl_easy_setopt(curl, option, Value_String::GetString(value));
	} else if (optType == CURLOPTTYPE_FUNCTIONPOINT) {

	} else if (optType == CURLOPTTYPE_OFF_T) {
		if (!value.IsInstanceOf(VTYPE_Number)) {
			Error::Issue(ErrorType::TypeError, "the option accepts Number value");
			return Value::nil();
		}
		code = curl_easy_setopt(curl, option, Value_Number::GetNumber<size_t>(value));
	} else if (optType == CURLOPTTYPE_BLOB) {

	}
	return new Value_Number(code);
	'''

curl_easy_perform(curl:CURL_p):CURLcode

curl_easy_cleanup(curl:CURL_p):void

curl_easy_getinfo(curl:CURL_p, info:CURLINFO) = \
	R'''
	RefPtr<Value> pValueRtn(Value::nil());
	long infoType = info & CURLINFO_TYPEMASK;
	if (infoType == CURLINFO_STRING) {
		const char* value;
		curl_easy_getinfo(curl, info, &value);
		pValueRtn.reset(new Value_String(value));
	} else if (infoType == CURLINFO_LONG) {
		long value;
		curl_easy_getinfo(curl, info, &value);
		pValueRtn.reset(new Value_Number(value));
	} else if (infoType == CURLINFO_DOUBLE) {
		double value;
		curl_easy_getinfo(curl, info, &value);
		pValueRtn.reset(new Value_Number(value));
	} else if (infoType == CURLINFO_SLIST) {
		curl_slist* slist = nullptr;
		curl_easy_getinfo(curl, info, &slist);
		RefPtr<ValueOwner> pValues(CreateValueOwnerFromSList(slist));
		curl_free(slist);
		pValueRtn.reset(new Value_List(VTYPE_String, pValues.release()));
	} else if (infoType == CURLINFO_PTR) {
	} else if (infoType == CURLINFO_SOCKET) {
	} else if (infoType == CURLINFO_OFF_T) {
		curl_off_t value;
		curl_easy_getinfo(curl, info, &value);
		pValueRtn.reset(new Value_Number(value));
	}
	return pValueRtn.release();
	'''

curl_easy_strerror(code:CURLcode):const_char_p

curl_easy_duphandle(curl:CURL_p):CURL_p

curl_easy_reset(curl:CURL_p):void

//CURLcode curl_easy_recv(CURL *curl, void *buffer, size_t buflen, size_t *n);

//CURLcode curl_easy_send(CURL *curl, const void *buffer, size_t buflen, size_t *n);

curl_easy_upkeep(curl:CURL_p):CURLcode;

}

tR'''
//==============================================================================
// Functions.cpp
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(curl)

${r.ComposeImplementation()}

void AssignFunctions(Frame& frame)
{
	${r.ComposeAssignment('frame.')}
}

Gurax_EndModuleScope(curl)
'''.Render('Functions.cpp')
