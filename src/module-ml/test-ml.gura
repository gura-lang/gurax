#!/usr/bin/env gurax
//==============================================================================
// test-ml.gura
//==============================================================================
import(util.tester) {*}
import(ml)

Number.format@float = '%.3f'
a = @float([[-6, -1, 4], [-5, -1, -5], [-3, 2, 2]])
b = @float([[3, -1, 4], [1, 2, -5], [-2, 4, -4]])
correct = @float([[5, -2, -5], [5, -4, -2], [-6, 5, -3]])

TestCase('Unary Node') {
	[
		`(rtn = -a)
	].Each {|model|
		t = ml.Trainer(model, nil)
		t.Train(correct)
		rtn = t[`rtn]
		Printf('%s\n', rtn.typeName)
		Printf('  input      %s\n', rtn.input)
		Printf('  output     %s\n', rtn.output)
		Printf('  correct    %s\n', correct)
		Printf('  outputGrad %s\n', rtn.outputGrad)
		Printf('  inputGrad  %s\n', rtn.inputGrad)
	}
}

TestCase('Binary Node') {
	[
		`(rtn = a + b)
		`(rtn = a - b)
		`(rtn = a * b)
		`(rtn = a |.| b)
	].Each {|model|
		t = ml.Trainer(model, nil)
		t.Train(correct)
		rtn = t[`rtn]
		Printf('%s\n', rtn.typeName)
		Printf('  inputL     %s\n', rtn.inputL)
		Printf('  inputR     %s\n', rtn.inputR)
		Printf('  output     %s\n', rtn.output)
		Printf('  correct    %s\n', correct)
		Printf('  outputGrad %s\n', rtn.outputGrad)
		Printf('  inputGradL %s\n', rtn.inputGradL)
		Printf('  inputGradR %s\n', rtn.inputGradR)
	}
}

TestCase('Gear Node') {
	[
		`(rtn = a |*| ml.ReLU())
		`(rtn = a |*| ml.Sigmoid())
	].Each {|model|
		t = ml.Trainer(model, nil)
		t.Train(correct)
		rtn = t[`rtn]
		Printf('%s\n', rtn.typeName)
		Printf('  input      %s\n', rtn.input)
		Printf('  output     %s\n', rtn.output)
		Printf('  correct    %s\n', correct)
		Printf('  outputGrad %s\n', rtn.outputGrad)
		Printf('  inputGrad  %s\n', rtn.inputGrad)
	}
}
