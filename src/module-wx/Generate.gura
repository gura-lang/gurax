#!/usr/bin/env gurax
import(cbridge)

r = cbridge.Renderer()

r.DeclareType('const_wxChar_p', 'const wxChar*', 'String',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickString();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickString() : ${defaultValue || 'nullptr'};
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<${this.cType}>(Gurax::Value_${this.vtype}::ValueForVector);
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Gurax::Value_${this.vtype}(rtn);
	''')

r.DeclareType('String', 'const char*', 'String',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickString();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickString() : ${defaultValue || 'nullptr'};
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<${this.cType}>(Gurax::Value_${this.vtype}::ValueForVector);
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Gurax::Value_${this.vtype}(rtn);
	''')

r.DeclareType('const_String_r', 'const char*', 'String',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickString();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickString() : ${defaultValue || 'nullptr'};
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<${this.cType}>(Gurax::Value_${this.vtype}::ValueForVector);
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Gurax::Value_${this.vtype}(rtn);
	''')

r.DeclareType('const_ArrayString_r', 'const wxArrayString&', 'String[]',
	codePickerVec = R'''
	wxArrayString ${varName} = Util::CreateArrayString(args_gurax.PickList());
	''')

r.DeclareType('const_ArrayShort_r', 'const wxArrayShort&', 'Number[]',
	codePickerVec = R'''
	wxArrayShort ${varName} = Util::CreateArrayShort(args_gurax.PickList());
	''')

r.DeclareType('const_ArrayInt_r', 'const wxArrayInt&', 'Number[]',
	codePickerVec = R'''
	wxArrayInt ${varName} = Util::CreateArrayInt(args_gurax.PickList());
	''')

r.DeclareType('const_ArrayDouble_r', 'const wxArrayDouble&', 'Number[]',
	codePickerVec = R'''
	wxArrayDouble ${varName} = Util::CreateArrayDouble(args_gurax.PickList());
	''')

r.DeclareType('const_ArrayLong_r', 'const wxArrayLong&', 'Number[]',
	codePickerVec = R'''
	wxArrayLong ${varName} = Util::CreateArrayLong(args_gurax.PickList());
	''')

r.DeclareType('ArrayString', 'wxArrayString', 'Number[]',
	codePickerVec = R'''
	wxArrayString ${varName} = Util::CreateArrayString(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

r.DeclareType('ArrayShort', 'wxArrayShort', 'Number[]',
	codePickerVec = R'''
	wxArrayShort ${varName} = Util::CreateArrayShort(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

r.DeclareType('ArrayInt', 'wxArrayInt', 'Number[]',
	codePickerVec = R'''
	wxArrayInt ${varName} = Util::CreateArrayInt(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

r.DeclareType('ArrayDouble', 'wxArrayDouble', 'Number[]',
	codePickerVec = R'''
	wxArrayDouble ${varName} = Util::CreateArrayDouble(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

r.DeclareType('ArrayLong', 'wxArrayLong', 'Number[]',
	codePickerVec = R'''
	wxArrayLong ${varName} = Util::CreateArrayLong(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

tmplVTypesCMake = tR'''
#===============================================================================
# VTypes.cmake
# Don't edit this file since it's been generated by Generate.gura.
#===============================================================================
set(SRCFILES_VTYPE
	VType_wxEventType.cpp
	${fileNamesSource + '\n'}
)
'''

tmplVTypesH = tR'''
//==============================================================================
// VTypes.h
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#ifndef GURAX_MODULE_WX_VTYPES_H
#define GURAX_MODULE_WX_VTYPES_H
#include <gurax.h>
#include "VType_wxApp.h"
#include "VType_wxEventType.h"
${fileNamesHeader.Each {|fileNameHeader|}}
#include "${fileNameHeader}"
${end}

Gurax_BeginModuleScope(wx)

void AssignVTypes(Frame& frame);

Gurax_EndModuleScope(wx)

#endif
'''

tmplVTypesCPP = tR'''
//==============================================================================
// VTypes.cpp
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Assignment
//------------------------------------------------------------------------------
void AssignVTypes(Frame& frame)
{
	frame.Assign(VTYPE_wxEventType);
	${classNames.Each {|className|}}
	frame.Assign(VTYPE_wx${className});
	${end}
}

Gurax_EndModuleScope(wx)
'''

tmplHeader = tR'''
//==============================================================================
// VType_wx${className}.h
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#ifndef GURAX_MODULE_WX_VTYPE_WX${className.Upper()}_H
#define GURAX_MODULE_WX_VTYPE_WX${className.Upper()}_H
#include <gurax.h>
#include <wx/wx.h>
${classInfo.includeFiles.Each {|includeFile|}}
#include <${includeFile}>
${end}
#include "Util.h"
${if (classNameParent)}
#include "VType_wx${classNameParent}.h"
${end}
${if (className == 'Event')}
#include "VType_wxEventType.h"
${end}

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// VType_wx${className}
//------------------------------------------------------------------------------
class GURAX_DLLDECLARE VType_wx${className} : public VType {
public:
	using VType::VType;
	virtual void DoPrepare(Frame& frameOuter) override;
${if (funcInfoCast)}
	virtual Value* DoCastFrom(const Value& value, DeclArg::Flags flags) const override;
${end}
};

extern GURAX_DLLDECLARE VType_wx${className} VTYPE_wx${className};

//------------------------------------------------------------------------------
// Value_wx${className}
//------------------------------------------------------------------------------
${if (classNameParent)}
class GURAX_DLLDECLARE Value_wx${className} : public Value_wx${classNameParent} {
${else}
class GURAX_DLLDECLARE Value_wx${className} : public Value_Object {
${end}
public:
	// Referable declaration
	Gurax_DeclareReferable(Value_wx${className});
	// Uses MemoryPool allocator
	Gurax_MemoryPoolAllocator("Value_wx${className}");
${if (evtHandlerOrDerivFlag)}
protected:
	wxWeakRef<wx${className}> _pEntity;
${elsif (refCounterOrDerivFlag)}
protected:
	wxObjectDataPtr<wx${className}> _pEntity;
${elsif (classInfo.loosePointerFlag || (classInfoRoot && classInfoRoot.loosePointerFlag))}
protected:
	wx${className}* _pEntity;
${elsif (className == 'CmdLineParser')}
protected:
	wx${className}& _entity;
${elsif (className == 'Event')}
protected:
	std::unique_ptr<wx${className}> _pEntity;
	RefPtr<Value> _pValueUserData;
public:
	const Value& GetValueUserData() const { return *_pValueUserData; }
${elsif (!classNameParent || classInfo.holdEntityFlag)}
protected:
	wx${className} _entity;
${end}
${if (evtHandlerOrDerivFlag)}
public:
	class EntityT : public wx${className} {
	public:
		using wx${className}::wx${className};
	public:
		EntityCore core_gurax;
		${funcInfoVirtualTbl.Each {|funcInfo|}}
		virtual ${funcInfo.ComposeCDecl()} override;
		${end}
	};
${end}
public:
	static VType& vtype;
${if (eventDerivFlag)}
	static EventValueFactoryDeriv<Value_wx${className}> eventValueFactory;
${end}
public:
	// Constructor
	Value_wx${className}() = delete;
${if (className == 'EvtHandler' || classInfo.loosePointerFlag)}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _pEntity(pEntity) {}
${elsif (className == 'RefCounter')}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _pEntity(pEntity) {}
${elsif (className == 'Event')}
	explicit Value_wx${className}(const wx${className}& entity, Value* pValueUserData, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _pEntity(entity.Clone()), _pValueUserData(pValueUserData) {}
${elsif (className == 'CmdLineParser')}
	explicit Value_wx${className}(wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _entity(entity) {}
${elsif (!classNameParent || classInfo.holdEntityFlag)}
	explicit Value_wx${className}(const wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _entity(entity) {}
${elsif (classNameRoot == 'EvtHandler' || classInfoRoot.loosePointerFlag)}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(pEntity, vtype), _pEntity(pEntity) {}
${elsif (classNameRoot == 'RefCounter')}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(pEntity, vtype), _pEntity(pEntity) { pEntity->IncRef(); }
${elsif (eventDerivFlag)}
	Value_wx${className}(const wx${classNameRoot}& entity, Value* pValueUserData, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(entity, pValueUserData, vtype) {}
${else}
	explicit Value_wx${className}(const wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(entity, vtype) {}
${end}
	// Copy constructor/operator
	Value_wx${className}(const Value_wx${className}& src) = delete;
	Value_wx${className}& operator=(const Value_wx${className}& src) = delete;
	// Move constructor/operator
	Value_wx${className}(Value_wx${className}&& src) noexcept = delete;
	Value_wx${className}& operator=(Value_wx${className}&& src) noexcept = delete;
protected:
	// Destructor
	~Value_wx${className}() = default;
public:
${if (evtHandlerOrDerivFlag || className in ['Event'])}
	wx${className}& GetEntity() { return *_pEntity; }
	const wx${className}& GetEntity() const { return *_pEntity; }
	wx${className}* GetEntityPtr() { return _pEntity.get(); }
	const wx${className}* GetEntityPtr() const { return _pEntity.get(); }
${elsif (refCounterOrDerivFlag)}
	wx${className}& GetEntity() { return *_pEntity; }
	const wx${className}& GetEntity() const { return *_pEntity; }
	wx${className}* GetEntityPtr() { return _pEntity.get(); }
	const wx${className}* GetEntityPtr() const { return _pEntity.get(); }
${elsif (classInfo.loosePointerFlag || (classInfoRoot && classInfoRoot.loosePointerFlag))}
	wx${className}& GetEntity() { return *_pEntity; }
	const wx${className}& GetEntity() const { return *_pEntity; }
	wx${className}* GetEntityPtr() { return _pEntity; }
	const wx${className}* GetEntityPtr() const { return _pEntity; }
${elsif (!classNameRoot || classInfo.holdEntityFlag)}
	wx${className}& GetEntity() { return _entity; }
	const wx${className}& GetEntity() const { return _entity; }
	wx${className}* GetEntityPtr() { return &_entity; }
	const wx${className}* GetEntityPtr() const { return &_entity; }
${else}
	wx${className}& GetEntity() {
		return reinterpret_cast<wx${className}&>(Value_wx${classNameRoot}::GetEntity());
	}
	const wx${className}& GetEntity() const {
		return reinterpret_cast<const wx${className}&>(Value_wx${classNameRoot}::GetEntity());
	}
	wx${className}* GetEntityPtr() {
		return reinterpret_cast<wx${className}*>(Value_wx${classNameRoot}::GetEntityPtr());
	}
	const wx${className}* GetEntityPtr() const {
		return reinterpret_cast<const wx${className}*>(Value_wx${classNameRoot}::GetEntityPtr());
	}
${end}
public:
	static wx${className}& GetEntity(Value& value) {
		return dynamic_cast<Value_wx${className}&>(value).GetEntity();
	}
	static const wx${className}& GetEntity(const Value& value) {
		return dynamic_cast<const Value_wx${className}&>(value).GetEntity();
	}
	static wx${className}* GetEntityPtr(Value& value) {
		return dynamic_cast<Value_wx${className}&>(value).GetEntityPtr();
	}
	static const wx${className}* GetEntityPtr(const Value& value) {
		return dynamic_cast<const Value_wx${className}&>(value).GetEntityPtr();
	}
public:
	// Virtual functions of Value
	virtual Value* Clone() const override { return Reference(); }
	virtual size_t DoCalcHash() const override {
		return reinterpret_cast<size_t>(GetEntityPtr(*this));
	}
	virtual bool IsEqualTo(const Value& value) const override {
		return IsSameType(value) && GetEntityPtr(*this) == GetEntityPtr(value);
	}
	virtual bool IsLessThan(const Value& value) const override {
		return IsSameType(value)?
			(GetEntityPtr(*this) < GetEntityPtr(value)) :
			GetVTypeCustom().IsLessThan(value.GetVTypeCustom());
	}
	virtual String ToString(const StringStyle& ss) const override;
};

Gurax_EndModuleScope(wx)

#endif
'''

tmplSource = tR'''
//==============================================================================
// VType_wx${className}.cpp
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Help
//------------------------------------------------------------------------------
static const char* g_docHelp_en = u8R"**(
# Overview

# Predefined Variable

# Property

# Operator

# Cast Operation

# Constructor

# Method
)**";

//------------------------------------------------------------------------------
// Implementation of constructor
//------------------------------------------------------------------------------
${if (funcInfoConstructor)}
${classInfo.EvalTmplConstructorImplementation(className, funcInfoConstructor)}
${end}

//-----------------------------------------------------------------------------
// Implementation of method
//-----------------------------------------------------------------------------
${if (!funcInfoTbl.IsEmpty())}
${EvalTmplMethodImplementation(className, funcInfoTbl.Each()).Join('\n')}
${end}

//-----------------------------------------------------------------------------
// Implementation of property
//-----------------------------------------------------------------------------

//------------------------------------------------------------------------------
// VType_wx${className}
//------------------------------------------------------------------------------
VType_wx${className} VTYPE_wx${className}("${className}");

void VType_wx${className}::DoPrepare(Frame& frameOuter)
{
	// Add help
	AddHelpTmpl(Gurax_Symbol(en), g_docHelp_en);
	// Declaration of VType
${if (classNameParent)}
	Declare(VTYPE_wx${classNameParent}, Flag::Mutable${if (funcInfoConstructor) {
		Format(', Gurax_CreateConstructor(%s_gurax)', funcInfoConstructor.name) }});
${else}
	Declare(VTYPE_Object, Flag::Mutable${if (funcInfoConstructor) {
		Format(', Gurax_CreateConstructor(%s_gurax)', funcInfoConstructor.name) }});
${end}
	// Assignment of method
	${funcInfoTbl.Each {|funcInfo|}}
	Assign(Gurax_CreateMethod(wx${className}, ${funcInfo.name}_gurax));
	${end}
	${//(codePrefix + cbriege.EvalTmplFunctionAssignment(funcInfoTbl.Each())).Join('\n')}
}

${if (funcInfoCast)}
Value* VType_wx${className}::DoCastFrom(const Value& value, DeclArg::Flags flags) const
{
	${if (funcInfoCast.tmplFunctionBody)}
	${funcInfoCast.tmplFunctionBody.Eval()}
	${else}
	return nullptr;
	${end}
}

${end}
//------------------------------------------------------------------------------
// Value_wx${className}
//------------------------------------------------------------------------------
VType& Value_wx${className}::vtype = VTYPE_wx${className};
${if (eventDerivFlag)}
EventValueFactoryDeriv<Value_wx${className}> Value_wx${className}::eventValueFactory;
${end}

String Value_wx${className}::ToString(const StringStyle& ss) const
{
	return ToStringGeneric(ss, "wx.${className}");
}
${if (evtHandlerOrDerivFlag)}

//------------------------------------------------------------------------------
// Value_wx${className}::EntityT
//------------------------------------------------------------------------------
${funcInfoVirtualTbl.Each {|funcInfo|}}
${funcInfo.ComposeCDecl('Value_wx' + className + '::EntityT::')}
{
	static const Symbol* pSymbolFunc = nullptr;
	if (!pSymbolFunc) pSymbolFunc = Symbol::Add("${funcInfo.name}");
	do {
		Gurax::Function* pFunc_gurax;
		RefPtr<Gurax::Argument> pArgument_gurax;
		if (!core_gurax.PrepareMethod(pSymbolFunc, &pFunc_gurax, pArgument_gurax)) break;
		// Argument
		${if (funcInfo.argInfoTbl.IsEmpty())}
		// (none)
		${else}
		Gurax::ArgFeeder args_gurax(*pArgument_gurax, core_gurax.GetProcessor().GetFrameCur());
		${funcInfo.argInfoTbl.Each {|argInfo|}}
		if (!args_gurax.FeedValue(${argInfo.ComposeConvToGurax()})) break;
		${end}
		${end}
		// Evaluation
		RefPtr<Value> pValueRtn(pFunc_gurax->Eval(core_gurax.GetProcessor(), *pArgument_gurax));
		if (Error::IsIssued()) {
			Util::ExitMainLoop();
			break;
		}
		${if (funcInfo.IsVoid())}
		return;
		${else}
		// Return Value
		if (!pValueRtn->IsType(VTYPE_${funcInfo.GetTypeInfo().vtype})) break;
		return ${funcInfo.GetTypeInfo().ComposeConvToC('*pValueRtn')};
		${end}
	} while (0);
	${if (!funcInfo.IsVoid())}
	return wx${className}::${funcInfo.ComposeCaller()};
	${end}
}

${end}
${end}
${cond (funcInfoVirtualTbl.IsEmpty(), '')}
Gurax_EndModuleScope(wx)
'''

tmplMethodImplementation = tR'''
// ${Format('%s.%s#%s(%s)', funcInfo.moduleName, className, funcInfo.name, funcInfo.argInfoTbl:*ToString().Join(', '))}
Gurax_DeclareMethodAlias(wx${className}, ${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	AddHelp(
		Gurax_Symbol(en),
		"");
}

Gurax_ImplementMethodEx(wx${className}, ${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	// Target
	auto& valueThis_gurax = GetValueThis(argument_gurax);
	auto pEntity_gurax = valueThis_gurax.GetEntityPtr();
	if (!pEntity_gurax) return Value::nil();
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${elsif (funcInfo.returnThisFlag)}
	pEntity_gurax->${funcInfo.ComposeCaller()};
	return valueThis_gurax.Reference();
	${else}
	${funcInfo.GetTypeInfo().ComposeFunctionBody('pEntity_gurax->' + funcInfo.ComposeCaller())}
	${end}
}
'''

tmplClassMethodImplementation = tR'''
// ${Format('%s.%s.%s(%s)', funcInfo.moduleName, className, funcInfo.name, funcInfo.argInfoTbl:*ToString().Join(', '))}
Gurax_DeclareClassMethodAlias(wx${className}, ${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	AddHelp(
		Gurax_Symbol(en),
		"");
}

Gurax_ImplementClassMethodEx(wx${className}, ${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${elsif (funcInfo.returnThisFlag)}
	wx${className}::${funcInfo.ComposeCaller()};
	return valueThis_gurax.Reference();
	${else}
	${funcInfo.GetTypeInfo().ComposeFunctionBody('wx' + className + '::' + funcInfo.ComposeCaller())}
	${end}
}
'''

tmplConsts = tR'''
//==============================================================================
// Consts.cpp
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

void AssignConsts(Frame& frame)
{
	${constNameTbl.Each {|constName|}}
	frame.Assign("${constName}", new Value_Number(wx${constName}));
	${end}
}

Gurax_EndModuleScope(wx)
'''

EvalTmplMethodImplementation(className as String, funcInfo as cbridge.FuncInfo):map = {
	cond(funcInfo.staticFlag, tmplClassMethodImplementation, tmplMethodImplementation).Eval()
}

ClassInfo = class {
	typeInfo as cbridge.TypeInfo
	className as String
	classNameParent:nil as String
	classInfoParent:nil as ClassInfo
	funcInfoConstructor as cbridge.FuncInfo
	funcInfoCast as cbridge.FuncInfo
	tmplConstructorImplementation as Template
	loosePointerFlag as Bool = false
	holdEntityFlag as Bool = false
	funcInfoTbl[] as cbridge.FuncInfo = []
	includeFiles[] as String = []
	classNamesToMixin[] as String = []
	__init__(className as String, classNameParent:nil as String) = {
		this.className = className
		this.classNameParent = classNameParent
	}
	GetClassInfoRoot() = {
		classInfo = this.classInfoParent
		while (classInfo) {
			!classInfo.classInfoParent && return(classInfo)
			classInfo = classInfo.classInfoParent
		}
		nil
	}
	IsEventDeriv() = {
		classInfo = this.classInfoParent
		while (classInfo) {
			(classInfo.className == 'Event') && return(true)
			classInfo = classInfo.classInfoParent
		}
		false
	}
	IsEvtHandlerOrDeriv() = {
		(this.className == 'EvtHandler') && return(true)
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.className == 'EvtHandler'
	}
	IsRefCounterOrDeriv() = {
		(this.className == 'RefCounter') && return(true)
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.className == 'RefCounter'
	}
	IsLoosePointer() = {
		this.loosePointerFlag && return(true)
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.loosePointerFlag
	}
	EvalTmplConstructorImplementation(className as String, funcInfo as cbridge.FuncInfo):map = {
		this.tmplConstructorImplementation.Eval()
	}
}

EventInfo = struct { eventName as String, className as String }

classInfoTbl = []
classInfoToMixinTbl = []
constNameTbl = []
enumNameTbl = []
eventInfoTbl = []

path.Glob('metafile/*.gura').Each {|pathName|
	fileName = path.FileName(pathName)
	(fileName in ['VType_wxEventType.gura']) && continue
	Expr(pathName).EachElem {|expr|
		if (expr.IsAssign() && expr.left.IsIdentifier() && expr.right.IsCaller() && expr.right.car.IsIdentifier(`Class)) {
			className = expr.left.symbolName
			params = expr.right.EachParam():list
			if (!params.first) {
				classNameParent = nil
			} elsif (params.first.IsIdentifier()) {
				classNameParent = params.first.symbolName
			} else {
				sys.cerr.Printf('%d: identifier must be specified\n', expr.lineNoTop)
				sys.Exit(1)
			}
			classInfo = ClassInfo(className, classNameParent)
			classInfo.loosePointerFlag = expr.right.attr.IsSet(`loosePointer)
			classInfo.holdEntityFlag = expr.right.attr.IsSet(`holdEntity)
			expr.right.block.EachElem {|expr|
				if (expr.IsIndexer()) {
					params = expr.EachParam():list
					if (!expr.car.IsIdentifier()) {
						sys.cerr.Printf('%d: identifier must be specified\n', expr.lineNoTop)
						sys.Exit(1)
					}
					if (expr.car.symbolName == '@include') {
						classInfo.includeFiles = params::string
					} elsif (expr.car.symbolName == '@mixin') {
						classInfo.classNamesToMixin = params::symbolName
					} else {
						sys.cerr.Printf('unknown directive: %s\n', expr.car.symbolName)
						sys.Exit(1)
					}
				} else {
					funcInfo = cbridge.CreateFuncInfo(r, 'wx', expr)
					if (funcInfo.name == '__init__') {
						funcInfo.name = classInfo.className
						classInfo.funcInfoConstructor = funcInfo
					} elsif (funcInfo.name == '__cast__') {
						classInfo.funcInfoCast = funcInfo
					} else {
						classInfo.funcInfoTbl.Add(funcInfo)
					}
				}
			}
			if (expr.right.attr.IsSet(`mixin)) {
				classInfoToMixinTbl.Add(classInfo)
			} else {
				classInfoTbl.Add(classInfo)
			}
		} elsif (expr.IsIndexer()) {
			params = expr.EachParam():list
			if (!expr.car.IsIdentifier()) {
				sys.cerr.Printf('%d: identifier must be specified\n', expr.lineNoTop)
				sys.Exit(1)
			}
			if (expr.car.symbolName == '@const') {
				constNameTbl.Append(params:*symbolName)
			} elsif (expr.car.symbolName == '@enum') {
				enumNameTbl.Append(params:*symbolName)
			} elsif (expr.car.symbolName == '@event') {
				params.Each {|param|
					if (param.IsBinaryOp()) {
						eventInfoTbl.Add(EventInfo(param.left.symbolName, param.right.symbolName))
					} else {
						sys.cerr.Printf('invalid syntax of event list\n')
						sys.Exit(1)
					}
				}
			} else {
				sys.cerr.Printf('unknown directive: %s\n', expr.car.symbolName)
				sys.Exit(1)
			}
		}
	}
}

enumNameTbl.Each {|enumName|
	r.DeclareType_Number(enumName, 'wx' + enumName)
}

tmplConstructorImplementation_Object = tR'''
// ${funcInfo.ToString()} {block?}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	AddHelp(
		Gurax_Symbol(en),
		"Creates an instance of wx.${className}.");
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	return argument_gurax.ReturnValue(processor_gurax, new Value_${funcInfo.GetTypeInfo().vtype}(
		wx${funcInfo.ComposeCaller()}));
	${end}
}
'''

tmplConstructorImplementation_EvtHandler = tR'''
// ${funcInfo.ToString()} {block?}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	AddHelp(
		Gurax_Symbol(en),
		"Creates an instance of wx.${className}.");
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	auto pEntity_gurax = new Value_${funcInfo.GetTypeInfo().vtype}::EntityT(${funcInfo.ComposeArgs()});
	RefPtr<Value_${funcInfo.GetTypeInfo().vtype}> pValue_gurax(new Value_${funcInfo.GetTypeInfo().vtype}(pEntity_gurax));
	pEntity_gurax->core_gurax.SetInfo(processor_gurax.Reference(), *pValue_gurax);
	return argument_gurax.ReturnValue(processor_gurax, pValue_gurax.release());
	${end}
}
'''

tmplConstructorImplementation_LoosePointer = tR'''
// ${funcInfo.ToString()} {block?}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	AddHelp(
		Gurax_Symbol(en),
		"Creates an instance of wx.${className}.");
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	auto pEntity_gurax = new ${funcInfo.GetTypeInfo().vtype}(${funcInfo.ComposeArgs()});
	RefPtr<Value_${funcInfo.GetTypeInfo().vtype}> pValue_gurax(new Value_${funcInfo.GetTypeInfo().vtype}(pEntity_gurax));
	return argument_gurax.ReturnValue(processor_gurax, pValue_gurax.release());
	${end}
}
'''

tmplConstructorImplementation_RefCounter = tR'''
// ${funcInfo.ToString()} {block?}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	AddHelp(
		Gurax_Symbol(en),
		"Creates an instance of wx.${className}.");
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	${funcInfo.GetTypeInfo().vtype}* pEntity_gurax = new ${funcInfo.GetTypeInfo().vtype}(${funcInfo.ComposeArgs()});
	RefPtr<Value_${funcInfo.GetTypeInfo().vtype}> pValue_gurax(new Value_${funcInfo.GetTypeInfo().vtype}(pEntity_gurax));
	return argument_gurax.ReturnValue(processor_gurax, pValue_gurax.release());
	${end}
}
'''

tmplEvents = tR'''
//==============================================================================
// Events.cpp
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Assignment
//------------------------------------------------------------------------------
void AssignEvents(Frame& frame)
{
	${eventInfoTbl.Each {|eventInfo|}}
	Gurax_AssignEvent(${eventInfo.eventName}, wx${eventInfo.className});
	${end}
}

Gurax_EndModuleScope(wx)
'''

classInfoTbl.Each {|classInfo|
	if (classInfo.classNameParent) {
		classInfo.classInfoParent = classInfoTbl.Find(classInfoTbl:*className == classInfo.classNameParent)
		if (!classInfo.classInfoParent) {
			sys.cerr.Printf('class is not found: %s\n', classInfo.classNameParent)
			sys.Exit(1)
		}
	}
	classInfo.classNamesToMixin.Each {|classNameToMixin|
		classInfoToMixin = classInfoToMixinTbl.Find(classInfoToMixinTbl:*className == classNameToMixin)
		if (!classInfoToMixin) {
			sys.cerr.Printf('class is not found: %s\n', classNameToMixin)
			sys.Exit(1)
		}
		classInfoToMixin.funcInfoTbl.Each {|funcInfo|
			if (!(classInfo.funcInfoTbl:*name == funcInfo.name).Or()) {
				classInfo.funcInfoTbl.Add(funcInfo)
			}
		}
	}
}

r.DeclareType('EventType', 'wxEventType', 'wxEventType', 'wxEventType',
	codePicker = R'''
	Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
	${this.cType} ${varName} = value_${varName}.GetEntity();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntity() : -1;
	'''
	codeFunctionBody = R'''
	return Util::LookupEventType(${caller}).Reference();
	''')

classInfoTbl.Each {|classInfo|
	if (classInfo.IsEvtHandlerOrDeriv() || classInfo.IsLoosePointer() || classInfo.IsRefCounterOrDeriv()) {
		typeInfo_p = r.DeclareType(classInfo.className + '_p', 'wx' + classInfo.className + '*',
			'wx' + classInfo.className, 'wx.' + classInfo.className,
			codePicker = R'''
			Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
			${this.cType} ${varName} = value_${varName}.GetEntityPtr();
			'''
			codePickerValidation = R'''
			${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr() : nullptr;
			'''
			codeConvToC = 'Value_${this.vtype}::GetEntityPtr(${src})'
			codeConvToGurax = 'new Value_${this.vtype}(${varName})'
			codeFunctionBody = R'''
			return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
				${caller}));
			''')
	} else {
		typeInfo_p = r.DeclareType(classInfo.className + '_p', 'wx' + classInfo.className + '*',
			'wx' + classInfo.className, 'wx.' + classInfo.className,
			codePicker = R'''
			Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
			${this.cType} ${varName} = value_${varName}.GetEntityPtr();
			'''
			codePickerValidation = R'''
			${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr() : nullptr;
			'''
			codeConvToC = 'Value_${this.vtype}::GetEntityPtr(${src})'
			codeConvToGurax = 'new Value_${this.vtype}(${varName})'
			codeFunctionBody = R'''
			return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
				*${caller}));
			''')
	}
	typeInfo = r.DeclareType(classInfo.className, 'wx' + classInfo.className,
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		codePicker = R'''
		Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
		const ${this.cType}& ${varName} = value_${varName}.GetEntity();
		'''
		codePickerValidation = R'''
		const ${this.cType}& ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntity() : ${defaultValue || '0'};
		'''
		codeConvToC = 'Value_${this.vtype}::GetEntity(${src})'
		codeConvToGurax = 'new Value_${this.vtype}(${varName})'
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			${caller}));
		''')
	r.DeclareType('const_' + classInfo.className + '_p', 'const wx' + classInfo.className + '*',
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		codePicker = R'''
		Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
		${this.cType} ${varName} = value_${varName}.GetEntityPtr();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr() : nullptr;
		'''
		codeConvToC = 'Value_${this.vtype}::GetEntityPtr(${src})'
		codeConvToGurax = 'new Value_${this.vtype}(${varName})'
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			*${caller}));
		''')
	r.DeclareType(classInfo.className + '_r', 'wx' + classInfo.className + '&',
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		codePicker = R'''
		Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
		${this.cType} ${varName} = value_${varName}.GetEntity();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntity() : ${defaultValue || '0'};
		'''
		codeConvToC = 'Value_${this.vtype}::GetEntity(${src})'
		codeConvToGurax = 'new Value_${this.vtype}(${varName})'
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			${caller}));
		''')
	r.DeclareType('const_' + classInfo.className + '_r', 'const wx' + classInfo.className + '&',
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		codePicker = R'''
		Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
		${this.cType} ${varName} = value_${varName}.GetEntity();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntity() : ${defaultValue || '0'};
		'''
		codeConvToC = 'Value_${this.vtype}::GetEntity(${src})'
		codeConvToGurax = 'new Value_${this.vtype}(${varName})'
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			${caller}));
		''')
	if (classInfo.IsEvtHandlerOrDeriv()) {
		classInfo.typeInfo = typeInfo_p
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_EvtHandler
	} elsif (classInfo.IsLoosePointer()) {
		classInfo.typeInfo = typeInfo_p
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_LoosePointer
	} elsif (classInfo.IsRefCounterOrDeriv()) {
		classInfo.typeInfo = typeInfo_p
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_RefCounter
	} else {
		classInfo.typeInfo = typeInfo
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_Object
	}
	if (classInfo.funcInfoConstructor) {
		classInfo.funcInfoConstructor.typeName = classInfo.typeInfo.decl
	}
}

GenerateVType(classInfoTbl[] as ClassInfo) = {
	fileNamesHeader = []
	fileNamesSource = []
	classNames = []
	classInfoTbl.Each {|classInfo|
		classInfoParent = classInfo.classInfoParent
		classInfoRoot = classInfo.GetClassInfoRoot()
		className = classInfo.className
		classNameParent = cond(classInfoParent, classInfoParent.className)
		classNameRoot = cond(classInfoRoot, classInfoRoot.className)
		funcInfoConstructor = classInfo.funcInfoConstructor
		funcInfoCast = classInfo.funcInfoCast
		funcInfoTbl = classInfo.funcInfoTbl
		funcInfoVirtualTbl = funcInfoTbl.Filter(funcInfoTbl:*virtualFlag):list
		fileNameHeader = Format('VType_wx%s.h', className)
		fileNameSource = Format('VType_wx%s.cpp', className)
		fileNamesHeader.Add(fileNameHeader)
		fileNamesSource.Add(fileNameSource)
		classNames.Add(className)
		eventDerivFlag = classInfo.IsEventDeriv()
		evtHandlerOrDerivFlag = classInfo.IsEvtHandlerOrDeriv()
		refCounterOrDerivFlag = classInfo.IsRefCounterOrDeriv()
		Println(className)
		tmplHeader.Render(fileNameHeader)
		tmplSource.Render(fileNameSource)
	}
	tmplVTypesH.Render('VTypes.h')
	tmplVTypesCPP.Render('VTypes.cpp')
	tmplVTypesCMake.Render('VTypes.cmake')
}

GenerateConst(constNameTbl[] as String) = {
	tmplConsts.Render('Consts.cpp')
}

GenerateEvent(eventInfoTbl[] as EventInfo) = {
	tmplEvents.Render('Events.cpp')
}

GenerateVType(classInfoTbl)
GenerateConst(constNameTbl.Sort())
GenerateEvent(eventInfoTbl)
