#!/usr/bin/env gurax
import(cbridge)

r = cbridge.Renderer()

r.DeclareType('String', 'const char*', 'String',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickString();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickString() : ${defaultValue || 'nullptr'};
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<${this.cType}>(Gurax::Value_${this.vtype}::ValueForVector);
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Gurax::Value_${this.vtype}(rtn);
	''')

tmplHeader = tR'''
//==============================================================================
// VType_wx${className}.h
//==============================================================================
#ifndef GURAX_MODULE_WX_VTYPE_WX${className.Upper()}_H
#define GURAX_MODULE_WX_VTYPE_WX${className.Upper()}_H
#include <gurax.h>
#include <wx/wx.h>
#include "Util.h"
${if (classNameParent)}
#include "VType_wx${classNameParent}.h"
${end}
${if (className == 'Event')}
#include "VType_wxEventType.h"
${end}

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// VType_wx${className}
//------------------------------------------------------------------------------
class GURAX_DLLDECLARE VType_wx${className} : public VType {
public:
	using VType::VType;
	virtual void DoPrepare(Frame& frameOuter) override;
};

extern GURAX_DLLDECLARE VType_wx${className} VTYPE_wx${className};

//------------------------------------------------------------------------------
// Value_wx${className}
//------------------------------------------------------------------------------
${if (classNameParent)}
class GURAX_DLLDECLARE Value_wx${className} : public Value_wx${classNameParent} {
${else}
class GURAX_DLLDECLARE Value_wx${className} : public Value_Object {
${end}
public:
	// Referable declaration
	Gurax_DeclareReferable(Value_wx${className});
	// Uses MemoryPool allocator
	Gurax_MemoryPoolAllocator("Value_wx${className}");
${if (className == 'EvtHandler')}
protected:
	wxWeakRef<wx${className}> _pEntity;
${elsif (!classNameParent)}
protected:
	wx${className} _entity;
${elsif (className == 'Event')}
protected:
	RefPtr<Value> _pValueUserData;
${end}
${if (evtHandlerOrDerivFlag)}
public:
	class EntityT : public wx${className} {
	public:
		using wx${className}::wx${className};
	public:
		EntityCore core;
	};
${end}
public:
	static VType& vtype;
${if (eventDerivFlag)}
	static EventValueFactoryDeriv<Value_wx${className}> eventValueFactory;
${end}
public:
	// Constructor
	Value_wx${className}() = delete;
${if (className == 'EvtHandler')}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _pEntity(pEntity) {}
${elsif (!classNameParent)}
	explicit Value_wx${className}(const wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _entity(entity) {}
${elsif (className == 'Event')}
	explicit Value_wx${className}(const wx${classNameRoot}& entity, Value* pValueUserData, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(entity, vtype), _pValueUserData(pValueUserData) {}
${elsif (classNameRoot == 'EvtHandler')}
	explicit Value_wx${className}(wx${classNameRoot}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(pEntity, vtype) {}
${elsif (eventDerivFlag)}
	Value_wx${className}(const wx${classNameRoot}& entity, Value* pValueUserData, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(entity, pValueUserData, vtype) {}
${else}
	explicit Value_wx${className}(const wx${classNameRoot}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(entity, vtype) {}
${end}
	// Copy constructor/operator
	Value_wx${className}(const Value_wx${className}& src) = delete;
	Value_wx${className}& operator=(const Value_wx${className}& src) = delete;
	// Move constructor/operator
	Value_wx${className}(Value_wx${className}&& src) noexcept = delete;
	Value_wx${className}& operator=(Value_wx${className}&& src) noexcept = delete;
protected:
	// Destructor
	~Value_wx${className}() = default;
public:
${if (className == 'EvtHandler')}
	wx${className}& GetEntity() { return *_pEntity; }
	const wx${className}& GetEntity() const { return *_pEntity; }
	wx${className}* GetEntityPtr() { return _pEntity.get(); }
	const wx${className}* GetEntityPtr() const { return _pEntity.get(); }
${elsif (!classNameRoot)}
	wx${className}& GetEntity() { return _entity; }
	const wx${className}& GetEntity() const { return _entity; }
	wx${className}* GetEntityPtr() { return &_entity; }
	const wx${className}* GetEntityPtr() const { return &_entity; }
${else}
	wx${className}& GetEntity() {
		return reinterpret_cast<wx${className}&>(Value_wx${classNameRoot}::GetEntity());
	}
	const wx${className}& GetEntity() const {
		return reinterpret_cast<const wx${className}&>(Value_wx${classNameRoot}::GetEntity());
	}
	wx${className}* GetEntityPtr() {
		return reinterpret_cast<wx${className}*>(Value_wx${classNameRoot}::GetEntityPtr());
	}
	const wx${className}* GetEntityPtr() const {
		return reinterpret_cast<const wx${className}*>(Value_wx${classNameRoot}::GetEntityPtr());
	}
${end}
public:
	static wx${className}& GetEntity(Value& value) {
		return dynamic_cast<Value_wx${className}&>(value).GetEntity();
	}
	static const wx${className}& GetEntity(const Value& value) {
		return dynamic_cast<const Value_wx${className}&>(value).GetEntity();
	}
	static wx${className}* GetEntityPtr(Value& value) {
		return dynamic_cast<Value_wx${className}&>(value).GetEntityPtr();
	}
	static const wx${className}* GetEntityPtr(const Value& value) {
		return dynamic_cast<const Value_wx${className}&>(value).GetEntityPtr();
	}
public:
	// Virtual functions of Value
	virtual Value* Clone() const override { return Reference(); }
	virtual size_t DoCalcHash() const override {
		return reinterpret_cast<size_t>(GetEntityPtr(*this));
	}
	virtual bool IsEqualTo(const Value& value) const override {
		return IsSameType(value) && GetEntityPtr(*this) == GetEntityPtr(value);
	}
	virtual bool IsLessThan(const Value& value) const override {
		return IsSameType(value)?
			(GetEntityPtr(*this) < GetEntityPtr(value)) :
			GetVTypeCustom().IsLessThan(value.GetVTypeCustom());
	}
	virtual String ToString(const StringStyle& ss) const override;
};

Gurax_EndModuleScope(wx)

#endif
'''

tmplSource = tR'''
//==============================================================================
// VType_wx${className}.cpp
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Help
//------------------------------------------------------------------------------
static const char* g_docHelp_en = u8R"**(
# Overview

# Predefined Variable

# Property

# Operator

# Cast Operation

# Constructor

# Method
)**";

//------------------------------------------------------------------------------
// Implementation of constructor
//------------------------------------------------------------------------------
${if (funcInfoConstructor)}
${classInfo.EvalTmplConstructorImplementation(funcInfoConstructor)}
${end}

//-----------------------------------------------------------------------------
// Implementation of method
//-----------------------------------------------------------------------------
${EvalTmplMethodImplementation(className, funcInfoTbl.Each()).Join('\n')}

//-----------------------------------------------------------------------------
// Implementation of property
//-----------------------------------------------------------------------------

//------------------------------------------------------------------------------
// VType_wx${className}
//------------------------------------------------------------------------------
VType_wx${className} VTYPE_wx${className}("${className}");

void VType_wx${className}::DoPrepare(Frame& frameOuter)
{
	// Add help
	AddHelpTmpl(Gurax_Symbol(en), g_docHelp_en);
	// Declaration of VType
${if (classNameParent)}
	Declare(VTYPE_wx${classNameParent}, Flag::Mutable${if (funcInfoConstructor) {
		Format(', Gurax_CreateConstructor(%s_gurax)', funcInfoConstructor.name) }});
${else}
	Declare(VTYPE_Object, Flag::Mutable${if (funcInfoConstructor) {
		Format(', Gurax_CreateConstructor(%s_gurax)', funcInfoConstructor.name) }});
${end}
	// Assignment of method
	${funcInfoTbl.Each() {|funcInfo|}}
	Assign(Gurax_CreateMethod(wx${className}, ${funcInfo.name}_gurax));
	${end}
	${//(codePrefix + cbriege.EvalTmplFunctionAssignment(funcInfoTbl.Each())).Join('\n')}
}

//------------------------------------------------------------------------------
// Value_wx${className}
//------------------------------------------------------------------------------
VType& Value_wx${className}::vtype = VTYPE_wx${className};
${if (eventDerivFlag)}
EventValueFactoryDeriv<Value_wx${className}> Value_wx${className}::eventValueFactory;
${end}

String Value_wx${className}::ToString(const StringStyle& ss) const
{
	return ToStringGeneric(ss, "wx.${className}");
}

Gurax_EndModuleScope(wx)
'''

tmplMethodImplementation = tR'''
// ${Format('%s.%s#%s(%s)', funcInfo.moduleName, className, funcInfo.name, funcInfo.argInfoTbl:*ToString().Join(', '))}
Gurax_DeclareMethodAlias(wx${className}, ${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.typeInfo.vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	AddHelp(
		Gurax_Symbol(en),
		"");
}

Gurax_ImplementMethodEx(wx${className}, ${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	// Target
	auto& valueThis_gurax = GetValueThis(argument_gurax);
	auto pEntity_gurax = valueThis_gurax.GetEntityPtr();
	if (!pEntity_gurax) return Value::nil();
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	${funcInfo.typeInfo.ComposeFunctionBody('pEntity_gurax->' + funcInfo.ComposeCaller())}
	${end}
}
'''

EvalTmplMethodImplementation(className as String, funcInfo as cbridge.FuncInfo):map = tmplMethodImplementation.Eval()

expr = `{
	AnyButton = Class(Control) {
	}
	App = Class(AppConsole) {
	}
	AppConsole = Class(EvtHandler) {
	}
	Button = Class(AnyButton) {
	}
	CommandEvent = Class(Event) {
	}
	Control = Class(Window) {
		__init__(parent:nil as Window_p, id as int, pos as Point = wxDefaultPosition, size as Size = wxDefaultSize,
			style as int = 0, validator as Validator = wxDefaultValidator, name as String = wxControlNameStr)
	}
	Event = Class(Object) {
	}
	EventType = Class {
	}
	EvtHandler = Class {
		__init__()
		//Bind(eventType as EventType, funct as Any, id? as int, lastId? as int, userData as Any):void
	}
	Frame = Class(Window) {
		__init__(parent:nil as Window_p, id as int, title as String, pos as Point = wxDefaultPosition, size as Size = wxDefaultSize,
			style as long = wxDEFAULT_FRAME_STYLE, name as String = wxFrameNameStr)
		CreateStatusBar(number as int = 1, style as long = wxSTB_DEFAULT_STYLE, id as int = 0, name as String = wxStatusBarNameStr)
	}
	Menu = Class(EvtHandler) {
	}
	MenuBar = Class(Window) {
		__init__()
		Append(menu as Menu_p, title as String) as bool
	}
	MenuItem = Class(Object) {
	}
	Object = Class {
	}
	Panel = Class(Window) {
	}
	Point = Class {
		__init__(x? as int, y? as int)
	}
	Size = Class {
		__init__(width? as int, height? as int)
	}
	StatusBar = Class(Control) {
		__init__()
	}
	Validator = Class(EvtHandler) {
		__init__()
	}
	Window = Class(EvtHandler) {
		__init__()
		Close(force? as bool) as bool
		Show(show? as bool) as bool
	}
}

ClassInfo = class {
	typeInfo as cbridge.TypeInfo
	className as String
	classNameParent:nil as String
	classInfoParent:nil as ClassInfo
	funcInfoConstructor as cbridge.FuncInfo
	tmplConstructorImplementation as Template
	funcInfoTbl[] as cbridge.FuncInfo = []
	__init__(className as String, classNameParent:nil as String) = {
		this.className = className
		this.classNameParent = classNameParent
	}
	GetClassInfoRoot() = {
		classInfo = this.classInfoParent
		while (classInfo) {
			!classInfo.classInfoParent && return(classInfo)
			classInfo = classInfo.classInfoParent
		}
		nil
	}
	IsEventDeriv() = {
		classInfo = this.classInfoParent
		while (classInfo) {
			(classInfo.className == 'Event') && return(true)
			classInfo = classInfo.classInfoParent
		}
		false
	}
	IsEvtHandlerOrDeriv() = {
		(this.className == 'EvtHandler') && return(true)
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.className == 'EvtHandler'
	}
	EvalTmplConstructorImplementation(funcInfo as cbridge.FuncInfo):map = {
		this.tmplConstructorImplementation.Eval()
	}
}

classInfoTbl = []

expr.EachElem {|expr|
	if (expr.IsAssign() && expr.left.IsIdentifier() && expr.right.IsCaller() && expr.right.car.IsIdentifier(`Class)) {
		className = expr.left.symbolName
		params = expr.right.EachParam():list
		if (!params.first) {
			classNameParent = nil
		} elsif (params.first.IsIdentifier()) {
			classNameParent = params.first.symbolName
		} else {
			sys.cerr.Printf('%d: identifier must be specified\n', expr.lineNoTop)
			sys.Exit(1)
		}
		classInfo = ClassInfo(className, classNameParent)
		expr.right.block.EachElem {|expr|
			funcInfo = cbridge.CreateFuncInfo(r, 'wx', expr)
			if (funcInfo.name == '__init__') {
				funcInfo.name = classInfo.className
				classInfo.funcInfoConstructor = funcInfo
			} else {
				classInfo.funcInfoTbl.Add(funcInfo)
			}
		}
		classInfoTbl.Add(classInfo)
	}
}

tmplConstructorImplementation_Object = tR'''
// ${funcInfo.ToString()} {block?}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.typeInfo.vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	AddHelp(
		Gurax_Symbol(en),
		"Creates an instance of wx.${className}.");
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	return argument_gurax.ReturnValue(processor_gurax, new Value_${funcInfo.typeInfo.vtype}(
		wx${funcInfo.ComposeCaller()}));
	${end}
}
'''

tmplConstructorImplementation_EvtHandler = tR'''
// ${funcInfo.ToString()} {block?}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.typeInfo.vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	AddHelp(
		Gurax_Symbol(en),
		"Creates an instance of wx.${className}.");
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	auto pEntity_gurax = new Value_${funcInfo.typeInfo.vtype}::EntityT(${funcInfo.ComposeArgs()});
	RefPtr<Value_${funcInfo.typeInfo.vtype}> pValue_gurax(new Value_${funcInfo.typeInfo.vtype}(pEntity_gurax));
	pEntity_gurax->core.SetInfo(processor_gurax.Reference(), *pValue_gurax);
	return argument_gurax.ReturnValue(processor_gurax, pValue_gurax.release());
	${end}
}
'''

classInfoTbl.Each {|classInfo|
	if (classInfo.classNameParent) {
		classInfo.classInfoParent = classInfoTbl.Find(classInfoTbl:*className == classInfo.classNameParent)
		if (!classInfo.classInfoParent) {
			sys.cerr.Printf('class is not found: %s\n', classInfo.classNameParent)
			sys.Exit(1)
		}
	}
}

classInfoTbl.Each {|classInfo|
	typeInfo_p = r.DeclareType(classInfo.className + '_p', 'wx' + classInfo.className + '*',
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		codePicker = R'''
		${this.cType} ${varName} = args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr() : nullptr;
		'''
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			${caller}));
		''')
	typeInfo = r.DeclareType(classInfo.className, 'wx' + classInfo.className,
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		codePicker = R'''
		const ${this.cType}& ${varName} = args_gurax.Pick<Value_${this.vtype}>().GetEntity();
		'''
		codePickerValidation = R'''
		const ${this.cType}& ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntity() : ${defaultValue || '0'};
		'''
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			${caller}));
		''')
	if (classInfo.IsEvtHandlerOrDeriv()) {
		classInfo.typeInfo = typeInfo_p
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_EvtHandler
	} else {
		classInfo.typeInfo = typeInfo
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_Object
	}
	if (classInfo.funcInfoConstructor) {
		classInfo.funcInfoConstructor.typeInfo = classInfo.typeInfo
	}
}

classInfoTbl.Each {|classInfo|
	classInfoParent = classInfo.classInfoParent
	classInfoRoot = classInfo.GetClassInfoRoot()
	className = classInfo.className
	classNameParent = cond(classInfoParent, classInfoParent.className)
	classNameRoot = cond(classInfoRoot, classInfoRoot.className)
	funcInfoConstructor = classInfo.funcInfoConstructor
	funcInfoTbl = classInfo.funcInfoTbl
	fileNameHeader = Format('VType_wx%s.h', className)
	fileNameSource = Format('VType_wx%s.cpp', className)
	eventDerivFlag = classInfo.IsEventDeriv()
	evtHandlerOrDerivFlag = classInfo.IsEvtHandlerOrDeriv()
	//if (className in ['Object', 'Event', 'CommandEvent', 'MenuItem', 'Point', 'Size', 'Window', 'StatusBar',
	//	'Validator', 'MenuBar', 'Control']) {
	if (className in ['Frame']) {
		Println(className)
		tmplHeader.Render(fileNameHeader)
		tmplSource.Render(fileNameSource)
	}
}
