#!/usr/bin/env gurax
import(cbridge)

r = cbridge.Renderer()

tmplHeader = tR'''
//==============================================================================
// VType_${className}.h
//==============================================================================
#ifndef GURAX_MODULE_WX_VTYPE_${className.Upper()}_H
#define GURAX_MODULE_WX_VTYPE_${className.Upper()}_H
#include <gurax.h>
#include <wx/wx.h>
#include "Util.h"
${if (classNameParent)}
#include "VType_${classNameParent}.h"
${end}
${if (className == 'wxEvent')}
#include "VType_wxEventType.h"
${end}

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// VType_${className}
//------------------------------------------------------------------------------
class GURAX_DLLDECLARE VType_${className} : public VType {
public:
	using VType::VType;
	virtual void DoPrepare(Frame& frameOuter) override;
};

extern GURAX_DLLDECLARE VType_${className} VTYPE_${className};

//------------------------------------------------------------------------------
// Value_${className}
//------------------------------------------------------------------------------
${if (classNameParent)}
class GURAX_DLLDECLARE Value_${className} : public Value_${classNameParent} {
${else}
class GURAX_DLLDECLARE Value_${className} : public Value_Object {
${end}
public:
	// Referable declaration
	Gurax_DeclareReferable(Value_${className});
	// Uses MemoryPool allocator
	Gurax_MemoryPoolAllocator("Value_${className}");
${if (className == 'wxEvtHandler')}
protected:
	wxWeakRef<${className}> _pEntity;
${elsif (!classNameParent)}
protected:
	${className} _entity;
${elsif (className == 'wxEvent')}
protected:
	RefPtr<Value> _pValueUserData;
${end}
${if (evtHandlerOrDerivFlag)}
public:
	class EntityT : public ${className} {
	public:
		using ${className}::${className};
	public:
		EntityCore core;
	};
${end}
public:
	static VType& vtype;
${if (eventDerivFlag)}
	static EventValueFactoryDeriv<Value_${className}> eventValueFactory;
${end}
public:
	// Constructor
	Value_${className}() = delete;
${if (className == 'wxEvtHandler')}
	explicit Value_${className}(${className}* pEntity, VType& vtype = VTYPE_${className}) :
		Value_Object(vtype), _pEntity(pEntity) {}
${elsif (!classNameParent)}
	explicit Value_${className}(const ${className}& entity, VType& vtype = VTYPE_${className}) :
		Value_Object(vtype), _entity(entity) {}
${elsif (className == 'wxEvent')}
	explicit Value_${className}(const ${classNameRoot}& entity, Value* pValueUserData, VType& vtype = VTYPE_${className}) :
		Value_${classNameParent}(entity, vtype), _pValueUserData(pValueUserData) {}
${elsif (classNameRoot == 'wxEvtHandler')}
	explicit Value_${className}(${classNameRoot}* pEntity, VType& vtype = VTYPE_${className}) :
		Value_${classNameParent}(pEntity, vtype) {}
${elsif (eventDerivFlag)}
	Value_${className}(const ${classNameRoot}& entity, Value* pValueUserData, VType& vtype = VTYPE_${className}) :
		Value_${classNameParent}(entity, pValueUserData, vtype) {}
${else}
	explicit Value_${className}(const ${classNameRoot}& entity, VType& vtype = VTYPE_${className}) :
		Value_${classNameParent}(entity, vtype) {}
${end}
	// Copy constructor/operator
	Value_${className}(const Value_${className}& src) = delete;
	Value_${className}& operator=(const Value_${className}& src) = delete;
	// Move constructor/operator
	Value_${className}(Value_${className}&& src) noexcept = delete;
	Value_${className}& operator=(Value_${className}&& src) noexcept = delete;
protected:
	// Destructor
	~Value_${className}() = default;
public:
${if (className == 'wxEvtHandler')}
	${className}& GetEntity() { return *_pEntity; }
	const ${className}& GetEntity() const { return *_pEntity; }
	${className}* GetEntityPtr() { return _pEntity.get(); }
	const ${className}* GetEntityPtr() const { return _pEntity.get(); }
${elsif (!classNameRoot)}
	${className}& GetEntity() { return _entity; }
	const ${className}& GetEntity() const { return _entity; }
	${className}* GetEntityPtr() { return &_entity; }
	const ${className}* GetEntityPtr() const { return &_entity; }
${else}
	${className}& GetEntity() {
		return reinterpret_cast<${className}&>(Value_${classNameRoot}::GetEntity());
	}
	const ${className}& GetEntity() const {
		return reinterpret_cast<const ${className}&>(Value_${classNameRoot}::GetEntity());
	}
	${className}* GetEntityPtr() {
		return reinterpret_cast<${className}*>(Value_${classNameRoot}::GetEntityPtr());
	}
	const ${className}* GetEntityPtr() const {
		return reinterpret_cast<const ${className}*>(Value_${classNameRoot}::GetEntityPtr());
	}
${end}
public:
	static ${className}& GetEntity(Value& value) {
		return dynamic_cast<Value_${className}&>(value).GetEntity();
	}
	static const ${className}& GetEntity(const Value& value) {
		return dynamic_cast<const Value_${className}&>(value).GetEntity();
	}
	static ${className}* GetEntityPtr(Value& value) {
		return dynamic_cast<Value_${className}&>(value).GetEntityPtr();
	}
	static const ${className}* GetEntityPtr(const Value& value) {
		return dynamic_cast<const Value_${className}&>(value).GetEntityPtr();
	}
public:
	// Virtual functions of Value
	virtual Value* Clone() const override { return Reference(); }
	virtual size_t DoCalcHash() const override {
		return reinterpret_cast<size_t>(GetEntityPtr(*this));
	}
	virtual bool IsEqualTo(const Value& value) const override {
		return IsSameType(value) && GetEntityPtr(*this) == GetEntityPtr(value);
	}
	virtual bool IsLessThan(const Value& value) const override {
		return IsSameType(value)?
			(GetEntityPtr(*this) < GetEntityPtr(value)) :
			GetVTypeCustom().IsLessThan(value.GetVTypeCustom());
	}
	virtual String ToString(const StringStyle& ss) const override;
};

Gurax_EndModuleScope(wx)

#endif
'''

tmplSource = tR'''
//==============================================================================
// VType_${className}.cpp
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Help
//------------------------------------------------------------------------------
static const char* g_docHelp_en = u8R"**(
# Overview

# Predefined Variable

# Property

# Operator

# Cast Operation

# Constructor

# Method
)**";

//------------------------------------------------------------------------------
// Implementation of constructor
//------------------------------------------------------------------------------
${if (funcInfoConstructor)}
${classInfo.EvalTmplConstructorImplementation(funcInfoConstructor)}
${end}

//-----------------------------------------------------------------------------
// Implementation of method
//-----------------------------------------------------------------------------
${EvalTmplMethodImplementation(funcInfoTbl.Each()).Join('\n')}

//-----------------------------------------------------------------------------
// Implementation of property
//-----------------------------------------------------------------------------

//------------------------------------------------------------------------------
// VType_${className}
//------------------------------------------------------------------------------
VType_${className} VTYPE_${className}("${className.Mid(2)}");

void VType_${className}::DoPrepare(Frame& frameOuter)
{
	// Add help
	AddHelpTmpl(Gurax_Symbol(en), g_docHelp_en);
	// Declaration of VType
${if (classNameParent)}
	Declare(VTYPE_${classNameParent}, Flag::Mutable${if (funcInfoConstructor) {
		Format(', Gurax_CreateConstructor(%s_gurax)', funcInfoConstructor.name) }});
${else}
	Declare(VTYPE_Object, Flag::Mutable${if (funcInfoConstructor) {
		Format(', Gurax_CreateConstructor(%s_gurax)', funcInfoConstructor.name) }});
${end}
	// Assignment of method
	${//(codePrefix + cbriege.EvalTmplFunctionAssignment(funcInfoTbl.Each())).Join('\n')}
	// Assignment of property
}

//------------------------------------------------------------------------------
// Value_${className}
//------------------------------------------------------------------------------
VType& Value_${className}::vtype = VTYPE_${className};
${if (eventDerivFlag)}
EventValueFactoryDeriv<Value_${className}> Value_${className}::eventValueFactory;
${end}

String Value_${className}::ToString(const StringStyle& ss) const
{
	return ToStringGeneric(ss, "wx.${className.Mid(2)}");
}

Gurax_EndModuleScope(wx)
'''

tmplMethodImplementation = tR'''
// ${Format('%s.%s#%s(%s)', funcInfo.moduleName, className, funcInfo.name, funcInfo.argInfoTbl:*ToString().Join(', '))}
Gurax_DeclareMethodAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.typeInfo.vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	AddHelp(
		Gurax_Symbol(en),
		"");
}

Gurax_ImplementMethodEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	// Target
	auto& valueThis_gurax = GetValueThis(argument);
	auto pEntity_gurax = valueThis.GetEntityPtr();
	if (!pEntity_gurax) return Value::nil();
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	${funcInfo.typeInfo.ComposeFunctionBody(funcInfo.ComposeCaller())}
	${end}
}
'''

EvalTmplMethodImplementation(funcInfo as cbridge.FuncInfo):map = tmplMethodImplementation.Eval()

expr = `{
	wxAnyButton = Class(wxControl) {
	}
	wxApp = Class(wxAppConsole) {
	}
	wxAppConsole = Class(wxEvtHandler) {
	}
	wxButton = Class(wxAnyButton) {
	}
	wxCommandEvent = Class(wxEvent) {
	}
	wxControl = Class(wxWindow) {
	}
	wxEvent = Class(wxObject) {
	}
	wxEventType = Class {
	}
	wxEvtHandler = Class {
		__init__()
		//Bind(eventType as wx.EventType, funct as Any, id? as int, lastId? as int, userData as Any):void
	}
	wxFrame = Class(wxWindow) {
	}
	wxMenu = Class(wxEvtHandler) {
	}
	wxMenuBar = Class(wxWindow) {
	}
	wxMenuItem = Class(wxObject) {
	}
	wxObject = Class {
	}
	wxPanel = Class(wxWindow) {
	}
	wxPoint = Class {
		__init__(x? as int, y? as int)
	}
	wxSize = Class {
		__init__(width? as int, height? as int)
	}
	wxStatusBar = Class(wxWindow) {
	}
	wxValidator = Class(wxEvtHandler) {
	}
	wxWindow = Class(wxEvtHandler) {
		__init__()
		Close(force? as bool)
		Show(show? as bool)
	}
}

ClassInfo = class {
	typeInfo as cbridge.TypeInfo
	className as String
	classNameParent:nil as String
	classInfoParent:nil as ClassInfo
	funcInfoConstructor as cbridge.FuncInfo
	tmplConstructorImplementation as Template
	funcInfoTbl[] as cbridge.FuncInfo = []
	__init__(className as String, classNameParent:nil as String) = {
		this.className = className
		this.classNameParent = classNameParent
	}
	GetClassInfoRoot() = {
		classInfo = this.classInfoParent
		while (classInfo) {
			!classInfo.classInfoParent && return(classInfo)
			classInfo = classInfo.classInfoParent
		}
		nil
	}
	IsEventDeriv() = {
		classInfo = this.classInfoParent
		while (classInfo) {
			(classInfo.className == 'wxEvent') && return(true)
			classInfo = classInfo.classInfoParent
		}
		false
	}
	IsEvtHandlerOrDeriv() = {
		(this.className == 'wxEvtHandler') && return(true)
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.className == 'wxEvtHandler'
	}
	EvalTmplConstructorImplementation(funcInfo as cbridge.FuncInfo):map = {
		this.tmplConstructorImplementation.Eval()
	}
}

classInfoTbl = []

expr.EachElem {|expr|
	if (expr.IsAssign() && expr.left.IsIdentifier() && expr.right.IsCaller() && expr.right.car.IsIdentifier(`Class)) {
		className = expr.left.symbolName
		params = expr.right.EachParam():list
		if (!params.first) {
			classNameParent = nil
		} elsif (params.first.IsIdentifier()) {
			classNameParent = params.first.symbolName
		} else {
			sys.cerr.Printf('%d: identifier must be specified\n', expr.lineNoTop)
			sys.Exit(1)
		}
		classInfo = ClassInfo(className, classNameParent)
		expr.right.block.EachElem {|expr|
			funcInfo = cbridge.CreateFuncInfo(r, 'wx', expr)
			if (funcInfo.name == '__init__') {
				funcInfo.name = classInfo.className
				classInfo.funcInfoConstructor = funcInfo
			} else {
				classInfo.funcInfoTbl.Add(funcInfo)
			}
		}
		classInfoTbl.Add(classInfo)
	}
}

tmplConstructorImplementation_Object = tR'''
// ${funcInfo.ToString()} {block?}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.typeInfo.vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	AddHelp(
		Gurax_Symbol(en),
		"Creates an instance of ${funcInfo.typeInfo.vtype}.");
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	return argument_gurax.ReturnValue(processor_gurax, new Value_${funcInfo.typeInfo.vtype}(
		${funcInfo.ComposeCaller()}));
	${end}
}
'''

tmplConstructorImplementation_EvtHandler = tR'''
// ${funcInfo.ToString()} {block?}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.typeInfo.vtype}, Flag::None);
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	AddHelp(
		Gurax_Symbol(en),
		"Creates an instance of ${funcInfo.typeInfo.vtype}.");
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	auto pEntity_gurax = new Value_${funcInfo.typeInfo.vtype}::EntityT();
	RefPtr<Value_${funcInfo.typeInfo.vtype}> pValue_gurax(new Value_${funcInfo.typeInfo.vtype}(pEntity_gurax));
	pEntity_gurax->core.SetInfo(processor_gurax.Reference(), *pValue_gurax);
	return argument_gurax.ReturnValue(processor_gurax, pValue_gurax.release());
	${end}
}
'''

classInfoTbl.Each {|classInfo|
	if (classInfo.classNameParent) {
		classInfo.classInfoParent = classInfoTbl.Find(classInfoTbl:*className == classInfo.classNameParent)
		if (!classInfo.classInfoParent) {
			sys.cerr.Printf('class is not found: %s\n', classInfo.classNameParent)
			sys.Exit(1)
		}
	}
}

classInfoTbl.Each {|classInfo|
	if (classInfo.IsEvtHandlerOrDeriv()) {
		classInfo.typeInfo = r.DeclareType(classInfo.className + '_p', classInfo.className + '*', classInfo.className,
			codePicker = R'''
			auto& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
			${this.cType} ${varName} = value_${varName}.GetEntityPtr();
			'''
			codeFunctionBody = R'''
			return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
				${caller}));
			''')
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_EvtHandler
	} else {
		classInfo.typeInfo = r.DeclareType(classInfo.className, classInfo.className, classInfo.className,
			codePicker = R'''
			auto& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
			${this.cType}& ${varName} = value_${varName}.GetEntity();
			'''
			codeFunctionBody = R'''
			return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
				${caller}));
			''')
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_Object
	}
	if (classInfo.funcInfoConstructor) {
		classInfo.funcInfoConstructor.typeInfo = classInfo.typeInfo
	}
}

classInfoTbl.Each {|classInfo|
	classInfoParent = classInfo.classInfoParent
	classInfoRoot = classInfo.GetClassInfoRoot()
	className = classInfo.className
	classNameParent = cond(classInfoParent, classInfoParent.className)
	classNameRoot = cond(classInfoRoot, classInfoRoot.className)
	funcInfoConstructor = classInfo.funcInfoConstructor
	funcInfoTbl = classInfo.funcInfoTbl
	fileNameHeader = Format('_VType_%s.h', className)
	fileNameSource = Format('_VType_%s.cpp', className)
	eventDerivFlag = classInfo.IsEventDeriv()
	evtHandlerOrDerivFlag = classInfo.IsEvtHandlerOrDeriv()
	//if (className in ['wxObject', 'wxEvent', 'wxCommandEvent', 'wxMenuItem', 'wxPoint', 'wxSize']) {
	if (className in ['wxWindow']) {
		Println(className)
		tmplHeader.Render(fileNameHeader)
		tmplSource.Render(fileNameSource)
	}
}
