#!/usr/bin/env gurax
import(cbridge)

r = cbridge.Renderer()

r.DeclareType('LongLong', 'wxLongLong', 'Number',
	codePicker = R'''
	${this.cType} ${varName}(args_gurax.PickNumber<wxLongLong_t>());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Gurax::Value_${this.vtype}(rtn.GetValue());
	''')

r.DeclareType_Number('FileOffset', 'wxFileOffset')

r.DeclareType('const_wxChar_p', 'const wxChar*', 'String',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickString();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickString() : ${defaultValue || 'nullptr'};
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<${this.cType}>(Gurax::Value_${this.vtype}::ValueForVector);
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Gurax::Value_${this.vtype}(rtn);
	''')

r.DeclareType('String', 'const char*', 'String',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickString();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickString() : ${defaultValue || 'nullptr'};
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<${this.cType}>(Gurax::Value_${this.vtype}::ValueForVector);
	'''
	codeFunctionBody = R'''
	wxString rtn = ${caller};
	//return new Gurax::Value_${this.vtype}(static_cast<const char*>(rtn.c_str()));
	return new Gurax::Value_${this.vtype}(rtn.utf8_str().data());
	''')

r.DeclareType('wxString', 'wxString', 'String',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickString();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickString() : ${defaultValue || 'wxEmptyString'};
	'''
	codeConvToC = 'Value_String::GetString(${src})'
	codeFunctionBody = R'''
	wxString rtn = ${caller};
	//return new Gurax::Value_${this.vtype}(static_cast<const char*>(rtn.c_str()));
	return new Gurax::Value_${this.vtype}(rtn.utf8_str().data());
	''')

r.DeclareType('const_String_r', 'const char*', 'String',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickString();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickString() : ${defaultValue || 'nullptr'};
	'''
	codePickerVec = R'''
	auto ${varName} = args_gurax.PickListT<${this.cType}>(Gurax::Value_${this.vtype}::ValueForVector);
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return new Gurax::Value_${this.vtype}(rtn);
	''')

r.DeclareType('const_ArrayString_r', 'const wxArrayString&', 'String[]',
	codePickerVec = R'''
	wxArrayString ${varName} = Util::CreateArrayString(args_gurax.PickList());
	''')

r.DeclareType('const_ArrayShort_r', 'const wxArrayShort&', 'Number[]',
	codePickerVec = R'''
	wxArrayShort ${varName} = Util::CreateArrayShort(args_gurax.PickList());
	''')

r.DeclareType('const_ArrayInt_r', 'const wxArrayInt&', 'Number[]',
	codePickerVec = R'''
	wxArrayInt ${varName} = Util::CreateArrayInt(args_gurax.PickList());
	''')

r.DeclareType('const_ArrayDouble_r', 'const wxArrayDouble&', 'Number[]',
	codePickerVec = R'''
	wxArrayDouble ${varName} = Util::CreateArrayDouble(args_gurax.PickList());
	''')

r.DeclareType('const_ArrayLong_r', 'const wxArrayLong&', 'Number[]',
	codePickerVec = R'''
	wxArrayLong ${varName} = Util::CreateArrayLong(args_gurax.PickList());
	''')

r.DeclareType('ArrayString', 'wxArrayString', 'Number[]',
	codePickerVec = R'''
	wxArrayString ${varName} = Util::CreateArrayString(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

r.DeclareType('ArrayShort', 'wxArrayShort', 'Number[]',
	codePickerVec = R'''
	wxArrayShort ${varName} = Util::CreateArrayShort(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

r.DeclareType('ArrayInt', 'wxArrayInt', 'Number[]',
	codePickerVec = R'''
	wxArrayInt ${varName} = Util::CreateArrayInt(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

r.DeclareType('ArrayDouble', 'wxArrayDouble', 'Number[]',
	codePickerVec = R'''
	wxArrayDouble ${varName} = Util::CreateArrayDouble(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

r.DeclareType('ArrayLong', 'wxArrayLong', 'Number[]',
	codePickerVec = R'''
	wxArrayLong ${varName} = Util::CreateArrayLong(args_gurax.PickList());
	'''
	codeFunctionBody = R'''
	${this.cType} rtn = ${caller};
	return Util::CreateList(rtn);
	''')

r.DeclareType('const_PointList_p', 'wxPointList', 'wxPoint[]', 'wx.Point',
	codePickerVec = R'''
	std::unique_ptr<wxPointList> ${varName}(Util::CreatePointList(args_gurax.PickList()));
	'''
	codeArgRef = '${varName}.get()')

r.DeclareType('TreeItemData_p', 'const Value&', 'Any',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickValue();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickValue() : Value::C_nil();
	'''
	codeArgRef = 'TreeItemData::Create(${varName})'
	codeFunctionBody = R'''
	TreeItemData* rtn = dynamic_cast<TreeItemData*>(${caller});
	if (!rtn) return Value::nil();
	return rtn->GetValue().Reference();
	'''
	)

r.DeclareType('ClientData_p', 'const Value&', 'Any',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickValue();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickValue() : Value::C_nil();
	'''
	codeArgRef = 'ClientData::Create(${varName})'
	codeFunctionBody = R'''
	ClientData* rtn = dynamic_cast<ClientData*>(${caller});
	if (!rtn) return Value::nil();
	return rtn->GetValue().Reference();
	'''
	)

tmplVTypesCMake = tR'''
#===============================================================================
# VTypes.cmake
# Don't edit this file since it's been generated by Generate.gura.
#===============================================================================
set(SRCFILES_VTYPE
	VType_wxEventType.cpp
	${fileNamesSource + '\n'}
)
'''

tmplVTypesH = tR'''
//==============================================================================
// VTypes.h
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#ifndef GURAX_MODULE_WX_VTYPES_H
#define GURAX_MODULE_WX_VTYPES_H
#include <gurax.h>
#include "VType_wxApp.h"
#include "VType_wxEventType.h"
${fileNamesHeader.Each {|fileNameHeader|}}
#include "${fileNameHeader}"
${end}

Gurax_BeginModuleScope(wx)

void AssignVTypes(Frame& frame);

Gurax_EndModuleScope(wx)

#endif
'''

tmplVTypesCPP = tR'''
//==============================================================================
// VTypes.cpp
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Assignment
//------------------------------------------------------------------------------
void AssignVTypes(Frame& frame)
{
	frame.Assign(VTYPE_wxEventType);
	${classNames.Each {|className|}}
	frame.Assign(VTYPE_wx${className});
	${end}
}

Gurax_EndModuleScope(wx)
'''

tmplHeader = tR'''
//==============================================================================
// VType_wx${className}.h
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#ifndef GURAX_MODULE_WX_VTYPE_WX${className.Upper()}_H
#define GURAX_MODULE_WX_VTYPE_WX${className.Upper()}_H
#include <gurax.h>
#include <wx/wx.h>
${classInfo.includeFiles.Each {|includeFile|}}
#include <${includeFile}>
${end}
#include "Util.h"
${if (classNameParent)}
#include "VType_wx${classNameParent}.h"
${end}
${if (className == 'Event')}
#include "VType_wxEventType.h"
${end}

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// VType_wx${className}
//------------------------------------------------------------------------------
class GURAX_DLLDECLARE VType_wx${className} : public VType {
public:
	using VType::VType;
	virtual void DoPrepare(Frame& frameOuter) override;
${if (funcInfoCast)}
	virtual Value* DoCastFrom(const Value& value, DeclArg::Flags flags) const override;
${end}
};

extern GURAX_DLLDECLARE VType_wx${className} VTYPE_wx${className};

//------------------------------------------------------------------------------
// Value_wx${className}
//------------------------------------------------------------------------------
${if (classNameParent)}
class GURAX_DLLDECLARE Value_wx${className} : public Value_wx${classNameParent} {
${else}
class GURAX_DLLDECLARE Value_wx${className} : public Value_Object {
${end}
public:
	// Referable declaration
	Gurax_DeclareReferable(Value_wx${className});
	// Uses MemoryPool allocator
	Gurax_MemoryPoolAllocator("Value_wx${className}");
${if (evtHandlerOrDerivFlag)}
protected:
	wxWeakRef<wx${className}> _pEntity;
${elsif (refCounterOrDerivFlag)}
protected:
	wxObjectDataPtr<wx${className}> _pEntity;
${elsif (classInfo.loosePointerFlag || (classInfoRoot && classInfoRoot.loosePointerFlag))}
protected:
	wx${className}* _pEntity;
${elsif (className == 'CmdLineParser')}
protected:
	wx${className}& _entity;
${elsif (className == 'Event')}
protected:
	wx${className}& _entity;
	RefPtr<Value> _pValueUserData;
public:
	const Value& GetValueUserData() const { return *_pValueUserData; }
${elsif (className == 'DC')}
protected:
	std::unique_ptr<wx${className}> _pEntityHolder;	// this may be nullptr
	wx${className}& _entity;
${elsif (!classNameParent || classInfo.holdEntityFlag)}
protected:
	wx${className} _entity;
${end}
${if (evtHandlerOrDerivFlag)}
public:
	class EntityT : public wx${className} {
	public:
		using wx${className}::wx${className};
	public:
		EntityCore core_gurax;
		${funcInfoVirtualTbl.Each {|funcInfo|}}
		virtual ${funcInfo.ComposeCDecl()} override;
		${end}
		${funcInfoVirtualTbl.Each {|funcInfo|}}
		${if (funcInfo.IsVoid())}
		${funcInfo.ComposeCDecl('public_')} { wx${className}::${funcInfo.ComposeCaller()}; }
		${else}
		${funcInfo.ComposeCDecl('public_')} { return wx${className}::${funcInfo.ComposeCaller()}; }
		${end}
		${end}
	};
${end}
public:
	static VType& vtype;
${if (eventDerivFlag)}
	static EventValueFactoryDeriv<Value_wx${className}> eventValueFactory;
${end}
public:
	// Constructor
	Value_wx${className}() = delete;
${if (classInfo.noCopyConstructorFlag)}
	explicit Value_wx${className}(VType& vtype = VTYPE_wx${className}) : Value_Object(vtype) {}
${elsif (className == 'EvtHandler' || classInfo.loosePointerFlag)}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _pEntity(pEntity) {}
	explicit Value_wx${className}(const wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _pEntity(const_cast<wx${className}*>(&entity)) {}
${elsif (className == 'RefCounter')}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _pEntity(pEntity) {}
${elsif (className == 'Event')}
	explicit Value_wx${className}(wx${className}& entity, Value* pValueUserData, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _entity(entity), _pValueUserData(pValueUserData) {}
${elsif (className == 'DC')}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _pEntityHolder(pEntity), _entity(*pEntity) {}
	explicit Value_wx${className}(wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _entity(entity) {}
${elsif (className == 'CmdLineParser')}
	explicit Value_wx${className}(wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _entity(entity) {}
${elsif (!classNameParent)}
	explicit Value_wx${className}(const wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_Object(vtype), _entity(entity) {}
${elsif (classInfo.holdEntityFlag)}
	explicit Value_wx${className}(const wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(entity, vtype), _entity(entity) {}
${elsif (classNameRoot == 'EvtHandler' || classInfoRoot.loosePointerFlag)}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(pEntity, vtype), _pEntity(pEntity) {}
${elsif (classNameRoot == 'RefCounter')}
	explicit Value_wx${className}(wx${className}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(pEntity, vtype), _pEntity(pEntity) { pEntity->IncRef(); }
${elsif (eventDerivFlag)}
	Value_wx${className}(wx${classNameRoot}& entity, Value* pValueUserData, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(entity, pValueUserData, vtype) {}
${elsif (dcDerivFlag)}
	Value_wx${className}(wx${classNameRoot}* pEntity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(pEntity, vtype) {}
${else}
	explicit Value_wx${className}(const wx${className}& entity, VType& vtype = VTYPE_wx${className}) :
		Value_wx${classNameParent}(entity, vtype) {}
${end}
	// Copy constructor/operator
	Value_wx${className}(const Value_wx${className}& src) = delete;
	Value_wx${className}& operator=(const Value_wx${className}& src) = delete;
	// Move constructor/operator
	Value_wx${className}(Value_wx${className}&& src) noexcept = delete;
	Value_wx${className}& operator=(Value_wx${className}&& src) noexcept = delete;
protected:
	// Destructor
	~Value_wx${className}() = default;
public:
${if (evtHandlerOrDerivFlag || refCounterOrDerivFlag)}
	wx${className}& GetEntity() { return *_pEntity; }
	const wx${className}& GetEntity() const { return *_pEntity; }
	wx${className}* GetEntityPtr() { return _pEntity.get(); }
	const wx${className}* GetEntityPtr() const { return _pEntity.get(); }
${elsif (className in ['Event'])}
	wx${className}& GetEntity() { return _entity; }
	const wx${className}& GetEntity() const { return _entity; }
	wx${className}* GetEntityPtr() { return &_entity; }
	const wx${className}* GetEntityPtr() const { return &_entity; }
${elsif (classInfo.loosePointerFlag || (classInfoRoot && classInfoRoot.loosePointerFlag))}
	wx${className}& GetEntity() { return *_pEntity; }
	const wx${className}& GetEntity() const { return *_pEntity; }
	wx${className}* GetEntityPtr() { return _pEntity; }
	const wx${className}* GetEntityPtr() const { return _pEntity; }
${elsif (className in ['DC'] || !classNameParent || classInfo.holdEntityFlag)}
	wx${className}& GetEntity() { return _entity; }
	const wx${className}& GetEntity() const { return _entity; }
	wx${className}* GetEntityPtr() { return &_entity; }
	const wx${className}* GetEntityPtr() const { return &_entity; }
${else}
	wx${className}& GetEntity() { return reinterpret_cast<wx${className}&>(Value_wx${classNameParent}::GetEntity()); }
	const wx${className}& GetEntity() const { return reinterpret_cast<const wx${className}&>(Value_wx${classNameParent}::GetEntity()); }
	wx${className}* GetEntityPtr() { return reinterpret_cast<wx${className}*>(Value_wx${classNameParent}::GetEntityPtr()); }\
	const wx${className}* GetEntityPtr() const { return reinterpret_cast<const wx${className}*>(Value_wx${classNameParent}::GetEntityPtr()); }
${end}
public:
	static wx${className}& GetEntity(Value& value) {
		return dynamic_cast<Value_wx${className}&>(value).GetEntity();
	}
	static const wx${className}& GetEntity(const Value& value) {
		return dynamic_cast<const Value_wx${className}&>(value).GetEntity();
	}
	static wx${className}* GetEntityPtr(Value& value) {
		return dynamic_cast<Value_wx${className}&>(value).GetEntityPtr();
	}
	static const wx${className}* GetEntityPtr(const Value& value) {
		return dynamic_cast<const Value_wx${className}&>(value).GetEntityPtr();
	}
public:
	// Virtual functions of Value
	virtual Value* Clone() const override { return Reference(); }
	virtual size_t DoCalcHash() const override {
		return reinterpret_cast<size_t>(GetEntityPtr(*this));
	}
	virtual bool IsEqualTo(const Value& value) const override {
		return IsSameType(value) && GetEntityPtr(*this) == GetEntityPtr(value);
	}
	virtual bool IsLessThan(const Value& value) const override {
		return IsSameType(value)?
			(GetEntityPtr(*this) < GetEntityPtr(value)) :
			GetVTypeCustom().IsLessThan(value.GetVTypeCustom());
	}
	virtual String ToString(const StringStyle& ss) const override;
};

Gurax_EndModuleScope(wx)

#endif
'''

tmplSource = tR'''
//==============================================================================
// VType_wx${className}.cpp
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Help
//------------------------------------------------------------------------------
${helpInfoTbl.Each {|helpInfo, idx|}}
${cond(idx > 0, "")}
static const char* g_docHelp_${helpInfo.langCode} = u8R"""(
${helpInfo.doc}
)""";
${end}

//------------------------------------------------------------------------------
// Implementation of constructor
//------------------------------------------------------------------------------
${if (funcInfoConstructor)}
${classInfo.EvalTmplConstructorImplementation(className, funcInfoConstructor)}
${end}

//-----------------------------------------------------------------------------
// Implementation of method
//-----------------------------------------------------------------------------
${if (!funcInfoTbl.IsEmpty())}
${EvalTmplMethodImplementation(className, funcInfoTbl.Each()).Join('\n')}
${end}

//-----------------------------------------------------------------------------
// Implementation of property
//-----------------------------------------------------------------------------
${if (!propInfoTbl.IsEmpty())}
${EvalTmplPropertyImplementation(className, propInfoTbl.Each()).Join('\n')}
${end}

//------------------------------------------------------------------------------
// VType_wx${className}
//------------------------------------------------------------------------------
VType_wx${className} VTYPE_wx${className}("${className}");

void VType_wx${className}::DoPrepare(Frame& frameOuter)
{
	// Add help
${helpInfoTbl.Each {|helpInfo|}}
	AddHelp(Gurax_Symbol(${helpInfo.langCode}), g_docHelp_${helpInfo.langCode});
${end}
	// Declaration of VType
${if (classNameParent)}
	Declare(VTYPE_wx${classNameParent}, Flag::Mutable${if (funcInfoConstructor) {
		Format(', Gurax_CreateConstructor(%s_gurax)', funcInfoConstructor.name) }});
${else}
	Declare(VTYPE_Object, Flag::Mutable${if (funcInfoConstructor) {
		Format(', Gurax_CreateConstructor(%s_gurax)', funcInfoConstructor.name) }});
${end}
${if (!classInfo.constNameTbl.IsEmpty())}
	// Assignment of constant value
${classInfo.constNameTbl.Each {|constName|}}
	GetFrame().Assign("${constName}", new Value_Number(wx${className}::${constName}));
${end}
${end}
	// Assignment of method
	${funcInfoTbl.Each {|funcInfo|}}
	Assign(Gurax_CreateMethod(wx${className}, ${funcInfo.name}_gurax));
	${end}
	${if (!propInfoTbl.IsEmpty())}
	// Assignment of property
	${propInfoTbl.Each {|propInfo|}}
	Assign(Gurax_CreateProperty(wx${className}, ${propInfo.GetName()}));
	${end}
	${end}
	${//(codePrefix + cbriege.EvalTmplFunctionAssignment(funcInfoTbl.Each())).Join('\n')}
}

${if (funcInfoCast)}
Value* VType_wx${className}::DoCastFrom(const Value& value, DeclArg::Flags flags) const
{
	${if (funcInfoCast.tmplFunctionBody)}
	${funcInfoCast.tmplFunctionBody.Eval()}
	${else}
	return nullptr;
	${end}
}

${end}
//------------------------------------------------------------------------------
// Value_wx${className}
//------------------------------------------------------------------------------
VType& Value_wx${className}::vtype = VTYPE_wx${className};
${if (eventDerivFlag)}
EventValueFactoryDeriv<Value_wx${className}> Value_wx${className}::eventValueFactory;
${end}

String Value_wx${className}::ToString(const StringStyle& ss) const
{
${if (funcInfoToString)}
	${funcInfoToString.tmplFunctionBody.Eval()}
${else}
	return ToStringGeneric(ss, "wx.${className}");
${end}
}
${if (evtHandlerOrDerivFlag)}

//------------------------------------------------------------------------------
// Value_wx${className}::EntityT
//------------------------------------------------------------------------------
${funcInfoVirtualTbl.Each {|funcInfo|}}
${funcInfo.ComposeCDecl('Value_wx' + className + '::EntityT::')}
{
	static const Symbol* pSymbolFunc = nullptr;
	if (!pSymbolFunc) pSymbolFunc = Symbol::Add("${funcInfo.name}");
	do {
		Gurax::Function* pFunc_gurax;
		RefPtr<Gurax::Argument> pArgument_gurax;
		if (!core_gurax.PrepareOverrideMethod(pSymbolFunc, &pFunc_gurax, pArgument_gurax)) break;
		// Argument
		${if (funcInfo.argInfoTbl.IsEmpty())}
		// (none)
		${else}
		Gurax::ArgFeeder args_gurax(*pArgument_gurax, core_gurax.GetProcessor().GetFrameCur());
		${funcInfo.argInfoTbl.Each {|argInfo|}}
		if (!args_gurax.FeedValue(${argInfo.ComposeConvToGurax()})) {
			Util::ExitMainLoop();
			break;
		}
		${end}
		${end}
		// Evaluation
		RefPtr<Value> pValueRtn(pFunc_gurax->Eval(core_gurax.GetProcessor(), *pArgument_gurax));
		if (Error::IsIssued()) {
			Util::ExitMainLoop();
			break;
		}
		${if (funcInfo.IsVoid())}
		return;
		${else}
		// Return Value
		${if (funcInfo.returnNilFlag)}
		if (pValueRtn->IsNil()) return nullptr;
		${end}
		if (!pValueRtn->IsType(VTYPE_${funcInfo.GetTypeInfo().vtype})) {
			Error::Issue(ErrorType::TypeError, "the function is expected to return a value of %s",
				VTYPE_${funcInfo.GetTypeInfo().vtype}.MakeFullName().c_str());
			Util::ExitMainLoop();
			break;
		}
		return ${funcInfo.GetTypeInfo().ComposeConvToC('*pValueRtn')};
		${end}
	} while (0);
	${if (funcInfo.IsVoid())}
	${funcInfo.ComposeCaller('public_')};
	${else}
	return ${funcInfo.ComposeCaller('public_')};
	${end}
}

${end}
${end}
${cond (funcInfoVirtualTbl.IsEmpty(), '')}
Gurax_EndModuleScope(wx)
'''

tmplMethodImplementation = tR'''
// ${Format('%s.%s#%s(%s)%s%s', funcInfo.moduleName, className, funcInfo.name,
	funcInfo.argInfoTbl:*ToString().Join(', '), cond(funcInfo.mapFlag, ':map', ''),
	cond(funcInfo.GetTypeInfo().blockOccurFlag, ' {block?}', ''))}
Gurax_DeclareMethodAlias(wx${className}, ${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, ${funcInfo.GetFlags()});
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	${if (funcInfo.GetTypeInfo().blockOccurFlag)}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	${end}
	${funcInfo.helpInfoTbl.Each {|helpInfo|}}
	AddHelp(Gurax_Symbol(${helpInfo.langCode}), u8R"""(
${helpInfo.doc}
)""");
	${end}
}

Gurax_ImplementMethodEx(wx${className}, ${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	// Target
	auto& valueThis_gurax = GetValueThis(argument_gurax);
	${if (funcInfo.virtualFlag)}
	auto pEntity_gurax = dynamic_cast<Value_wx${className}::EntityT*>(valueThis_gurax.GetEntityPtr());
	${else}
	auto pEntity_gurax = valueThis_gurax.GetEntityPtr();
	${end}
	if (!pEntity_gurax) return Value::nil();
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${elsif (funcInfo.returnThisFlag)}
	pEntity_gurax->${funcInfo.ComposeCaller()};
	return valueThis_gurax.Reference();
	${else}
	${funcInfo.GetTypeInfo().ComposeFunctionBody('pEntity_gurax->' + funcInfo.ComposeCaller())}
	${end}
}
'''

tmplClassMethodImplementation = tR'''
// ${Format('%s.%s.%s(%s)%s%s', funcInfo.moduleName, className, funcInfo.name,
	funcInfo.argInfoTbl:*ToString().Join(', '), cond(funcInfo.mapFlag, ':map', ''),
	cond(funcInfo.GetTypeInfo().blockOccurFlag, ' {block?}', ''))}
Gurax_DeclareClassMethodAlias(wx${className}, ${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, ${funcInfo.GetFlags()});
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	${funcInfo.helpInfoTbl.Each {|helpInfo|}}
	AddHelp(Gurax_Symbol(${helpInfo.langCode}), u8R"""(
${helpInfo.doc}
)""");
	${end}
}

Gurax_ImplementClassMethodEx(wx${className}, ${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${elsif (funcInfo.returnThisFlag)}
	wx${className}::${funcInfo.ComposeCaller()};
	return valueThis_gurax.Reference();
	${else}
	${funcInfo.GetTypeInfo().ComposeFunctionBody('wx' + className + '::' + funcInfo.ComposeCaller())}
	${end}
}
'''

tmplPropertyImplementation_R = tR'''
Gurax_DeclareProperty_R(wx${className}, ${propInfo.GetName()})
{
	Declare(VTYPE_${propInfo.GetTypeInfo().vtype}, Flag::None);
	AddHelp(Gurax_Symbol(en), u8R"""(
)""");
}

Gurax_ImplementPropertyGetter(wx${className}, ${propInfo.GetName()})
{
	auto& valueThis_gurax = GetValueThis(valueTarget);
	${propInfo.funcInfo_propGetter.tmplFunctionBody.Eval()}
}
'''

tmplPropertyImplementation_W = tR'''
Gurax_DeclareProperty_W(wx${className}, ${propInfo.GetName()})
{
	Declare(VTYPE_${propInfo.GetTypeInfo().vtype}, Flag::None);
	AddHelp(Gurax_Symbol(en), u8R"""(
)""");
}

Gurax_ImplementPropertySetter(wx${className}, ${propInfo.GetName()})
{
	auto& valueThis_gurax = GetValueThis(valueTarget);
	auto& value_gurax = value;
	${propInfo.funcInfo_propSetter.tmplFunctionBody.Eval()}
}
'''

tmplPropertyImplementation_RW = tR'''
Gurax_DeclareProperty_RW(wx${className}, ${propInfo.GetName()})
{
	Declare(VTYPE_${propInfo.GetTypeInfo().vtype}, Flag::None);
	AddHelp(Gurax_Symbol(en), u8R"""(
)""");
}

Gurax_ImplementPropertyGetter(wx${className}, ${propInfo.GetName()})
{
	auto& valueThis_gurax = GetValueThis(valueTarget);
	${propInfo.funcInfo_propGetter.tmplFunctionBody.Eval()}
}

Gurax_ImplementPropertySetter(wx${className}, ${propInfo.GetName()})
{
	auto& valueThis_gurax = GetValueThis(valueTarget);
	auto& value_gurax = value;
	${propInfo.funcInfo_propSetter.tmplFunctionBody.Eval()}
}
'''

tmplConsts = tR'''
//==============================================================================
// Consts.cpp
// Don't edit this file since it's been generated by Generate.gura.
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

void AssignConsts(Frame& frame)
{
	${constNameTbl.Each {|constName|}}
	frame.Assign("${constName}", new Value_Number(${cond(constName.StartsWith('WXK_'), '', 'wx') + constName}));
	${end}
	${stringNameTbl.Each {|stringName|}}
	frame.Assign("${stringName}", new Value_String(wx${stringName}));
	${end}
}

Gurax_EndModuleScope(wx)
'''

tmplFunctions = tR'''
//==============================================================================
// Functions.cpp
//==============================================================================
#include "stdafx.h"
Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Implementation of function
//------------------------------------------------------------------------------
${funcInfoTbl.Each() {|funcInfo|}}
// ${funcInfo.ToString()}
Gurax_DeclareFunctionAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, ${funcInfo.GetFlags()});
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	${if (funcInfo.GetTypeInfo().blockOccurFlag)}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	${end}
	${funcInfo.helpInfoTbl.Each {|helpInfo|}}
	AddHelp(Gurax_Symbol(${helpInfo.langCode}), u8R"""(
${helpInfo.doc}
)""");
	${end}
}

Gurax_ImplementFunctionEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	${funcInfo.GetTypeInfo().ComposeFunctionBody(funcInfo.ComposeCaller('wx'))}
	${end}
}

${end}
//------------------------------------------------------------------------------
// Assignment
//------------------------------------------------------------------------------
void AssignFunctions(Frame& frame)
{
	${funcInfoTbl.Each() {|funcInfo|}}
	frame.Assign(Gurax_CreateFunction(${funcInfo.name}_gurax));
	${end}
}

Gurax_EndModuleScope(wx)
'''

tmplOperators = tR'''
//==============================================================================
// Operators.cpp
//==============================================================================
#include "stdafx.h"
Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Implementation of function
//------------------------------------------------------------------------------
${funcInfoTbl.Each() {|funcInfo|}}
${cbridge.EvalTmplOperatorImplementation(funcInfo)}

${end}
//------------------------------------------------------------------------------
// Assignment
//------------------------------------------------------------------------------
void AssignOperators(Frame& frame)
{
	${funcInfoTbl.Each() {|funcInfo|}}
	${cbridge.EvalTmplOperatorAssignment(funcInfo)}
	${end}
}

Gurax_EndModuleScope(wx)
'''

PropInfo = class {
	funcInfo_propSetter as cbridge.FuncInfo
	funcInfo_propGetter as cbridge.FuncInfo
	GetName() = (this.funcInfo_propSetter || this.funcInfo_propGetter).name
	GetTypeInfo() = (this.funcInfo_propGetter || this.funcInfo_propSetter).GetTypeInfo()
}

EvalTmplMethodImplementation(className as String, funcInfo as cbridge.FuncInfo):map = {
	cond(funcInfo.staticFlag, tmplClassMethodImplementation, tmplMethodImplementation).Eval()
}

EvalTmplPropertyImplementation(className as String, propInfo as PropInfo):map = {
	if (propInfo.funcInfo_propGetter && !propInfo.funcInfo_propSetter) {
		tmplPropertyImplementation_R.Eval()
	} elsif (!propInfo.funcInfo_propGetter && propInfo.funcInfo_propSetter) {
		tmplPropertyImplementation_W.Eval()
	} else {
		tmplPropertyImplementation_RW.Eval()
	}
}

ClassInfo = class {
	typeInfo as cbridge.TypeInfo
	className as String
	classNameParent:nil as String
	helpInfoTbl[] as cbridge.HelpInfo = []
	classInfoParent:nil as ClassInfo
	funcInfoConstructor as cbridge.FuncInfo
	funcInfoCast as cbridge.FuncInfo
	funcInfoToString as cbridge.FuncInfo
	tmplConstructorImplementation as Template
	loosePointerFlag as Bool = false
	holdEntityFlag as Bool = false
	noCopyConstructorFlag as Bool = false
	funcInfoTbl[] as cbridge.FuncInfo = []
	propInfoTbl[] as PropInfo = []
	includeFiles[] as String = []
	classNamesToMixin[] as String = []
	enumNameTbl[] as String = []
	constNameTbl[] as String = []
	stringNameTbl[] as String = []
	mixinDoneFlag as Bool = false
	__init__(className as String, classNameParent:nil as String) = {
		this.className = className
		this.classNameParent = classNameParent
	}
	GetClassInfoRoot() = {
		classInfo = this.classInfoParent
		while (classInfo) {
			!classInfo.classInfoParent && return(classInfo)
			classInfo = classInfo.classInfoParent
		}
		nil
	}
	IsEventDeriv() = {
		classInfo = this.classInfoParent
		while (classInfo) {
			(classInfo.className == 'Event') && return(true)
			classInfo = classInfo.classInfoParent
		}
		false
	}
	IsDCDeriv() = {
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.className == 'DC'
	}
	IsDCOrDeriv() = {
		(this.className == 'DC') && return(true)
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.className == 'DC'
	}
	IsEvtHandlerOrDeriv() = {
		(this.className == 'EvtHandler') && return(true)
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.className == 'EvtHandler'
	}
	IsRefCounterOrDeriv() = {
		(this.className == 'RefCounter') && return(true)
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.className == 'RefCounter'
	}
	IsLoosePointer() = {
		this.loosePointerFlag && return(true)
		classInfo = this.GetClassInfoRoot()
		classInfo && classInfo.loosePointerFlag
	}
	EvalTmplConstructorImplementation(className as String, funcInfo as cbridge.FuncInfo):map = {
		this.tmplConstructorImplementation.Eval()
	}
	PrepareClassInfoParent() = {
		if (this.classNameParent) {
			this.classInfoParent = classInfoTbl.Find(classInfoTbl:*className == this.classNameParent)
			if (!this.classInfoParent) {
				sys.cerr.Printf('class is not found: %s\n', this.classNameParent)
				sys.Exit(1)
			}
		}
	}
	DoMixin() = {
		this.mixinDoneFlag && return
		this.classNamesToMixin.Each {|classNameToMixin|
			classInfoToMixin = classInfoToMixinTbl.Find(classInfoToMixinTbl:*className == classNameToMixin)
			if (!classInfoToMixin) {
				sys.cerr.Printf('class is not found: %s\n', classNameToMixin)
				sys.Exit(1)
			}
			classInfoToMixin.DoMixin()
			classInfoToMixin.funcInfoTbl.Each {|funcInfo|
				if (!(this.funcInfoTbl:*name == funcInfo.name).Or()) {
					this.funcInfoTbl.Add(funcInfo)
				}
			}
		}
	}
}

EventInfo = struct { eventName as String, className as String }

funcInfoTbl = []
funcInfoOpTbl = []
classInfoTbl = []
classInfoToMixinTbl = []
constNameTbl = []
stringNameTbl = []
enumNameTbl = []
eventInfoTbl = []

path.Glob('metafile/*.gura').Each {|pathName|
	fileName = path.FileName(pathName)
	Println(fileName)
	(fileName in ['VType_wxEventType.gura']) && continue
	Expr(pathName).EachElem {|expr|
		if (expr.IsAssign() && expr.left.IsIdentifier()) {
			exprBody = expr.right
			helpInfoTbl = []
			while (exprBody.IsBinaryOp() && exprBody.operator.symbol == `%%) {
				exprHelp = exprBody.right
				if (exprHelp.IsString()) {
					helpInfoTbl.Add(cbridge.HelpInfo(`en, exprHelp.string))
				} elsif (exprHelp.IsSuffixed()) {
					helpInfoTbl.Add(cbridge.HelpInfo(exprHelp.symbol, exprHelp.string))
				} else {
					sys.cerr.Printf('invalid help format')
					sys.Exit(1)
				}
				exprBody = exprBody.left
			}
			helpInfoTbl = helpInfoTbl.Reverse():list
			if (exprBody.IsCaller() && exprBody.car.IsIdentifier(`Class)) {
				className = expr.left.symbolName
				params = exprBody.EachParam():list
				if (!params.first) {
					classNameParent = nil
				} elsif (params.first.IsIdentifier()) {
					classNameParent = params.first.symbolName
				} else {
					sys.cerr.Printf('%d: identifier must be specified\n', expr.lineNoTop)
					sys.Exit(1)
				}
				classInfo = ClassInfo(className, classNameParent)
				classInfo.helpInfoTbl = helpInfoTbl
				classInfo.loosePointerFlag = exprBody.attr.IsSet(`loosePointer)
				classInfo.holdEntityFlag = exprBody.attr.IsSet(`holdEntity)
				classInfo.noCopyConstructorFlag = exprBody.attr.IsSet(`noCopyConstructor)
				exprBody.block.EachElem {|expr|
					if (expr.IsIndexer()) {
						params = expr.EachParam():list
						if (!expr.car.IsIdentifier()) {
							sys.cerr.Printf('%d: identifier must be specified\n', expr.lineNoTop)
							sys.Exit(1)
						}
						if (expr.car.symbolName == '@include') {
							classInfo.includeFiles = params::string
						} elsif (expr.car.symbolName == '@mixin') {
							classInfo.classNamesToMixin = params::symbolName
						} else {
							sys.cerr.Printf('unknown directive: %s\n', expr.car.symbolName)
							sys.Exit(1)
						}
					} elsif (expr.IsCaller() && expr.car.symbolName == '@enum') {
						params = expr.block.EachElem():list
						params.Each {|param|
							if (param.IsIdentifier()) {
								classInfo.enumNameTbl.Append(param.symbolName)
							} elsif (param.IsCaller()) {
								classInfo.enumNameTbl.Append(param.car.symbolName)
								classInfo.constNameTbl.Append(param.block.EachElem():*symbolName)
							}
						}
					} else {
						funcInfo = cbridge.CreateFuncInfo(r, 'wx', expr)
						if (funcInfo.name == '__init__') {
							funcInfo.name = classInfo.className
							classInfo.funcInfoConstructor = funcInfo
						} elsif (funcInfo.name == '__cast__') {
							classInfo.funcInfoCast = funcInfo
						} elsif (funcInfo.name == '__toString__') {
							classInfo.funcInfoToString = funcInfo
						} elsif (funcInfo.type == `function) {
							classInfo.funcInfoTbl.Add(funcInfo)
						} elsif (funcInfo.type == `propGetter || funcInfo.type == `propSetter) {
							propInfo = classInfo.propInfoTbl.Find(classInfo.propInfoTbl:*GetName() == funcInfo.name)
							if (!propInfo) {
								propInfo = PropInfo()
								classInfo.propInfoTbl.Add(propInfo)
							}
							if (funcInfo.type == `propGetter) {
								propInfo.funcInfo_propGetter = funcInfo
							} else {
								propInfo.funcInfo_propSetter = funcInfo
							}
						}
					}
				}
				if (exprBody.attr.IsSet(`mixin)) {
					classInfoToMixinTbl.Add(classInfo)
				} else {
					classInfoTbl.Add(classInfo)
				}
			}
		} elsif (expr.IsCaller()) {
			if (!expr.car.IsIdentifier()) {
				sys.cerr.Printf('%d: identifier must be specified\n', expr.lineNoTop)
				sys.Exit(1)
			}
			if (expr.car.symbolName == '@const') {
				params = expr.block.EachElem():list
				constNameTbl.Append(params:*symbolName)
			} elsif (expr.car.symbolName == '@string') {
				params = expr.block.EachElem():list
				stringNameTbl.Append(params:*symbolName)
			} elsif (expr.car.symbolName == '@enum') {
				params = expr.block.EachElem():list
				params.Each {|param|
					if (param.IsIdentifier()) {
						enumNameTbl.Append(param.symbolName)
					} elsif (param.IsCaller()) {
						enumNameTbl.Append(param.car.symbolName)
						constNameTbl.Append(param.block.EachElem():*symbolName)
					}
				}
			} elsif (expr.car.symbolName == '@event') {
				params = expr.block.EachElem():list
				params.Each {|param|
					if (param.IsBinaryOp()) {
						eventInfoTbl.Add(EventInfo(param.left.symbolName, param.right.symbolName))
					} else {
						sys.cerr.Printf('invalid syntax of event list\n')
						sys.Exit(1)
					}
				}
			} else {
				funcInfoTbl.Add(cbridge.CreateFuncInfo(r, 'wx', expr))
				//sys.cerr.Printf('unknown directive: %s\n', expr.car.symbolName)
				//sys.Exit(1)
			}
		} else {
			funcInfo = cbridge.CreateFuncInfo(r, 'wx', expr)
			if (funcInfo.type == `function) {
				funcInfoTbl.Add(funcInfo)
			} elsif (funcInfo.type == `operator) {
				funcInfoOpTbl.Add(funcInfo)
			}
		}
	}
}

enumNameTbl.Each {|enumName|
	r.DeclareType_Number(enumName, 'wx' + enumName)
}

classInfoTbl.Each {|classInfo|
	classInfo.enumNameTbl.Each {|enumName|
		r.DeclareType_Number(classInfo.className + '.' + enumName,
						'wx' + classInfo.className + '::' + enumName)
	}
}

tmplConstructorImplementation_Object = tR'''
// ${funcInfo.ToString()}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, ${funcInfo.GetFlags()});
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	${funcInfo.helpInfoTbl.Each {|helpInfo|}}
	AddHelp(Gurax_Symbol(${helpInfo.langCode}), u8R"""(
${helpInfo.doc}
)""");
	${end}
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (	funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	return argument_gurax.ReturnValue(processor_gurax, new Value_${funcInfo.GetTypeInfo().vtype}(
		wx${funcInfo.ComposeCaller()}));
	${end}
}
'''

tmplConstructorImplementation_EvtHandler = tR'''
// ${funcInfo.ToString()}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, ${funcInfo.GetFlags()});
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	${funcInfo.helpInfoTbl.Each {|helpInfo|}}
	AddHelp(Gurax_Symbol(${helpInfo.langCode}), u8R"""(
${helpInfo.doc}
)""");
	${end}
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	auto pEntity_gurax = new Value_${funcInfo.GetTypeInfo().vtype}::EntityT(${funcInfo.ComposeArgs()});
	RefPtr<Value_${funcInfo.GetTypeInfo().vtype}> pValue_gurax(new Value_${funcInfo.GetTypeInfo().vtype}(pEntity_gurax));
	pEntity_gurax->core_gurax.SetInfo(processor_gurax.Reference(), *pValue_gurax);
	return argument_gurax.ReturnValue(processor_gurax, pValue_gurax.release());
	${end}
}
'''

tmplConstructorImplementation_Pointer = tR'''
// ${funcInfo.ToString()}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, ${funcInfo.GetFlags()});
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	${funcInfo.helpInfoTbl.Each {|helpInfo|}}
	AddHelp(Gurax_Symbol(${helpInfo.langCode}), u8R"""(
${helpInfo.doc}
)""");
	${end}
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	auto pEntity_gurax = new ${funcInfo.GetTypeInfo().vtype}(${funcInfo.ComposeArgs()});
	RefPtr<Value_${funcInfo.GetTypeInfo().vtype}> pValue_gurax(new Value_${funcInfo.GetTypeInfo().vtype}(pEntity_gurax));
	return argument_gurax.ReturnValue(processor_gurax, pValue_gurax.release());
	${end}
}
'''

tmplConstructorImplementation_RefCounter = tR'''
// ${funcInfo.ToString()}
Gurax_DeclareConstructorAlias(${funcInfo.name}_gurax, "${funcInfo.name}")
{
	Declare(VTYPE_${funcInfo.GetTypeInfo().vtype}, ${funcInfo.GetFlags()});
	${funcInfo.argInfoTbl::ComposeDeclaration()}
	DeclareBlock(BlkOccur::ZeroOrOnce);
	${funcInfo.helpInfoTbl.Each {|helpInfo|}}
	AddHelp(Gurax_Symbol(${helpInfo.langCode}), u8R"""(
${helpInfo.doc}
)""");
	${end}
}

Gurax_ImplementConstructorEx(${funcInfo.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!funcInfo.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${funcInfo.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (funcInfo.tmplFunctionBody)}
	${funcInfo.tmplFunctionBody.Eval()}
	${else}
	${funcInfo.GetTypeInfo().vtype}* pEntity_gurax = new ${funcInfo.GetTypeInfo().vtype}(${funcInfo.ComposeArgs()});
	RefPtr<Value_${funcInfo.GetTypeInfo().vtype}> pValue_gurax(new Value_${funcInfo.GetTypeInfo().vtype}(pEntity_gurax));
	return argument_gurax.ReturnValue(processor_gurax, pValue_gurax.release());
	${end}
}
'''

tmplEvents = tR'''
//==============================================================================
// Events.cpp
//==============================================================================
#include "stdafx.h"

Gurax_BeginModuleScope(wx)

//------------------------------------------------------------------------------
// Assignment
//------------------------------------------------------------------------------
void AssignEvents(Frame& frame)
{
	${eventInfoTbl.Each {|eventInfo|}}
	${AppendTab('Gurax_AssignEvent(' + eventInfo.eventName + ',', colAlign)}wx${eventInfo.className});
	${end}
}

Gurax_EndModuleScope(wx)
'''

classInfoTbl.Each {|classInfo|
	classInfo.PrepareClassInfoParent()
	classInfo.DoMixin()
}

r.DeclareType('EventType', 'wxEventType', 'wxEventType', 'wxEventType',
	codePicker = R'''
	Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
	${this.cType} ${varName} = value_${varName}.GetEntity();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntity() : -1;
	'''
	codeFunctionBody = R'''
	return Util::LookupEventType(${caller}).Reference();
	''')

classInfoTbl.Each {|classInfo|
	if (classInfo.IsEvtHandlerOrDeriv() || classInfo.IsLoosePointer() || classInfo.IsRefCounterOrDeriv()) {
		typeInfo_p = r.DeclareType(classInfo.className + '_p', 'wx' + classInfo.className + '*',
			'wx' + classInfo.className, 'wx.' + classInfo.className,
			blockOccurFlag = true
			codePicker = R'''
			Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
			${this.cType} ${varName} = value_${varName}.GetEntityPtr();
			'''
			codePickerValidation = R'''
			${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr() : nullptr;
			'''
			codeConvToC = 'Value_${this.vtype}::GetEntityPtr(${src})'
			codeConvToGurax = 'new Value_${this.vtype}(${varName})'
			codeFunctionBody = R'''
			return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
				${caller}));
			''')
	} else {
		typeInfo_p = r.DeclareType(classInfo.className + '_p', 'wx' + classInfo.className + '*',
			'wx' + classInfo.className, 'wx.' + classInfo.className,
			blockOccurFlag = true
			codePicker = R'''
			Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
			${this.cType} ${varName} = value_${varName}.GetEntityPtr();
			'''
			codePickerValidation = R'''
			${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr() : nullptr;
			'''
			codeConvToC = 'Value_${this.vtype}::GetEntityPtr(${src})'
			codeConvToGurax = 'new Value_${this.vtype}(${varName})'
			codeFunctionBody = R'''
			return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
				*${caller}));
			''')
	}
	typeInfo = r.DeclareType(classInfo.className, 'wx' + classInfo.className,
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		blockOccurFlag = true
		codePicker = R'''
		Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
		const ${this.cType}& ${varName} = value_${varName}.GetEntity();
		'''
		codePickerValidation = R'''
		const ${this.cType}& ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntity() : ${defaultValue || '0'};
		'''
		codeConvToC = 'Value_${this.vtype}::GetEntity(${src})'
		codeConvToGurax = 'new Value_${this.vtype}(${varName})'
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			${caller}));
		''')
	r.DeclareType('const_' + classInfo.className + '_p', 'const wx' + classInfo.className + '*',
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		blockOccurFlag = true
		codePicker = R'''
		Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
		${this.cType} ${varName} = value_${varName}.GetEntityPtr();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntityPtr() : nullptr;
		'''
		codeConvToC = 'Value_${this.vtype}::GetEntityPtr(${src})'
		codeConvToGurax = 'new Value_${this.vtype}(${varName})'
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			*${caller}));
		''')
	r.DeclareType(classInfo.className + '_r', 'wx' + classInfo.className + '&',
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		blockOccurFlag = true
		codePicker = R'''
		Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
		${this.cType} ${varName} = value_${varName}.GetEntity();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntity() : ${defaultValue || '0'};
		'''
		codeConvToC = 'Value_${this.vtype}::GetEntity(${src})'
		codeConvToGurax = 'new Value_${this.vtype}(${varName})'
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			${caller}));
		''')
	r.DeclareType('const_' + classInfo.className + '_r', 'const wx' + classInfo.className + '&',
		'wx' + classInfo.className, 'wx.' + classInfo.className,
		blockOccurFlag = true
		codePicker = R'''
		Value_${this.vtype}& value_${varName} = args_gurax.Pick<Value_${this.vtype}>();
		${this.cType} ${varName} = value_${varName}.GetEntity();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Value_${this.vtype}>().GetEntity() : ${defaultValue || '0'};
		'''
		codeConvToC = 'Value_${this.vtype}::GetEntity(${src})'
		codeConvToGurax = 'new Value_${this.vtype}(${varName})'
		codeFunctionBody = R'''
		return argument_gurax.ReturnValue(processor_gurax, new Value_${this.vtype}(
			${caller}));
		''')
	if (classInfo.IsEvtHandlerOrDeriv()) {
		classInfo.typeInfo = typeInfo_p
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_EvtHandler
	} elsif (classInfo.IsLoosePointer() || classInfo.IsDCOrDeriv()) {
		classInfo.typeInfo = typeInfo_p
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_Pointer
	} elsif (classInfo.IsRefCounterOrDeriv()) {
		classInfo.typeInfo = typeInfo_p
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_RefCounter
	} else {
		classInfo.typeInfo = typeInfo
		classInfo.tmplConstructorImplementation = tmplConstructorImplementation_Object
	}
	if (classInfo.funcInfoConstructor) {
		classInfo.funcInfoConstructor.typeName = classInfo.typeInfo.decl
	}
}

// ======== Overwrite declaration of Object_p ========
r.DeclareType('Object_p', 'const Value&', 'Any',
	codePicker = R'''
	${this.cType} ${varName} = args_gurax.PickValue();
	'''
	codePickerValidation = R'''
	${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickValue() : Value::C_nil();
	'''
	codeArgRef = 'ClientObject::Create(${varName})'
	codeFunctionBody = R'''
	ClientObject* rtn = dynamic_cast<ClientObject*>(${caller});
	if (!rtn) return Value::nil();
	return rtn->GetValue().Reference();
	'''
	)

AppendTab(str as String, colAlign as Number) = {
	str + '\t' * Int((colAlign - str.width) / 4)
}

GenerateVType(classInfoTbl[] as ClassInfo) = {
	fileNamesHeader = []
	fileNamesSource = []
	classNames = []
	classInfoTbl.Each {|classInfo|
		classInfoParent = classInfo.classInfoParent
		classInfoRoot = classInfo.GetClassInfoRoot()
		className = classInfo.className
		classNameParent = cond(classInfoParent, classInfoParent.className)
		helpInfoTbl = classInfo.helpInfoTbl
		classNameRoot = cond(classInfoRoot, classInfoRoot.className)
		funcInfoConstructor = classInfo.funcInfoConstructor
		funcInfoCast = classInfo.funcInfoCast
		funcInfoToString = classInfo.funcInfoToString
		funcInfoTbl = classInfo.funcInfoTbl
		propInfoTbl = classInfo.propInfoTbl
		funcInfoVirtualTbl = funcInfoTbl.Filter(funcInfoTbl:*virtualFlag):list
		fileNameHeader = Format('VType_wx%s.h', className)
		fileNameSource = Format('VType_wx%s.cpp', className)
		fileNamesHeader.Add(fileNameHeader)
		fileNamesSource.Add(fileNameSource)
		classNames.Add(className)
		eventDerivFlag = classInfo.IsEventDeriv()
		dcDerivFlag = classInfo.IsDCDeriv()
		evtHandlerOrDerivFlag = classInfo.IsEvtHandlerOrDeriv()
		refCounterOrDerivFlag = classInfo.IsRefCounterOrDeriv()
		Println(className)
		tmplHeader.Render(Stream(fileNameHeader, 'w').Write(Codec.bom@utf8))
		tmplSource.Render(Stream(fileNameSource, 'w').Write(Codec.bom@utf8))
	}
	tmplVTypesH.Render(Stream('VTypes.h', 'w').Write(Codec.bom@utf8))
	tmplVTypesCPP.Render(Stream('VTypes.cpp', 'w').Write(Codec.bom@utf8))
	tmplVTypesCMake.Render(Stream('VTypes.cmake', 'w').Write(Codec.bom@utf8))
}

GenerateConst(constNameTbl[] as String, stringNameTbl[] as String) = {
	tmplConsts.Render(Stream('Consts.cpp', 'w').Write(Codec.bom@utf8))
}

GenerateEvent(eventInfoTbl[] as EventInfo, colAlign as Number) = {
	tmplEvents.Render(Stream('Events.cpp', 'w').Write(Codec.bom@utf8))
}

GenerateFunction(funcInfoTbl[] as cbridge.FuncInfo) = {
	tmplFunctions.Render(Stream('Functions.cpp', 'w').Write(Codec.bom@utf8))
}

GenerateOperator(funcInfoTbl[] as cbridge.FuncInfo) = {
	tmplOperators.Render(Stream('Operators.cpp', 'w').Write(Codec.bom@utf8))
}

GenerateVType(classInfoTbl)
GenerateConst(constNameTbl.Sort().Uniq():list, stringNameTbl.Sort().Uniq():list)
eventNames = eventInfoTbl::eventName
GenerateEvent(eventInfoTbl.Sort(keys = eventNames), Int((('Gurax_AssignEvent' + ',').width + ((eventNames:*len).Max()) + 3) / 4 * 4 + 4))
GenerateFunction(funcInfoTbl.Sort(keys = funcInfoTbl::name))
GenerateOperator(funcInfoOpTbl.Sort(keys = funcInfoOpTbl:*operator::typeId):stable)
