import(re)

//------------------------------------------------------------------------------
txt = R'''
wxLogFormatter * 	SetFormatter (wxLogFormatter *formatter)
 	Sets the specified formatter as the active one. More...
 
virtual void 	Flush ()
 	Some of wxLog implementations, most notably the standard wxLogGui class, buffer the messages (for example, to avoid showing the user a zillion of modal message boxes one after another â€“ which would be really annoying). More...
 
void 	LogRecord (wxLogLevel level, const wxString &msg, const wxLogRecordInfo &info)
 	Log the given record. More...
 
Static Public Member Functions
Trace mask functions
static void 	AddTraceMask (const wxString &mask)
 	Add the mask to the list of allowed masks for wxLogTrace(). More...
 
static void 	ClearTraceMasks ()
 	Removes all trace masks previously set with AddTraceMask(). More...
 
static const wxArrayString & 	GetTraceMasks ()
 	Returns the currently allowed list of string trace masks. More...
 
static bool 	IsAllowedTraceMask (const wxString &mask)
 	Returns true if the mask is one of allowed masks for wxLogTrace(). More...
 
static void 	RemoveTraceMask (const wxString &mask)
 	Remove the mask from the list of allowed masks for wxLogTrace(). More...
 
Log target functions
static void 	DontCreateOnDemand ()
 	Instructs wxLog to not create new log targets on the fly if there is none currently (see GetActiveTarget()). More...
 
static wxLog * 	GetActiveTarget ()
 	Returns the pointer to the active log target (may be NULL). More...
 
static wxLog * 	SetActiveTarget (wxLog *logtarget)
 	Sets the specified log target as the active one. More...
 
static wxLog * 	SetThreadActiveTarget (wxLog *logger)
 	Sets a thread-specific log target. More...
 
static void 	FlushActive ()
 	Flushes the current log target if any, does nothing if there is none. More...
 
static void 	Resume ()
 	Resumes logging previously suspended by a call to Suspend(). More...
 
static void 	Suspend ()
 	Suspends the logging until Resume() is called. More...
 
Log level functions
static wxLogLevel 	GetLogLevel ()
 	Returns the current log level limit. More...
 
static bool 	IsLevelEnabled (wxLogLevel level, wxString component)
 	Returns true if logging at this level is enabled for the current thread. More...
 
static void 	SetComponentLevel (const wxString &component, wxLogLevel level)
 	Sets the log level for the given component. More...
 
static void 	SetLogLevel (wxLogLevel logLevel)
 	Specifies that log messages with level greater (numerically) than logLevel should be ignored and not sent to the active log target. More...
 
Enable/disable features functions
static bool 	EnableLogging (bool enable=true)
 	Globally enable or disable logging. More...
 
static bool 	IsEnabled ()
 	Returns true if logging is enabled at all now. More...
 
static bool 	GetRepetitionCounting ()
 	Returns whether the repetition counting mode is enabled. More...
 
static void 	SetRepetitionCounting (bool repetCounting=true)
 	Enables logging mode in which a log message is logged once, and in case exactly the same message successively repeats one or more times, only the number of repetitions is logged. More...
 
static const wxString & 	GetTimestamp ()
 	Returns the current timestamp format string. More...
 
static void 	SetTimestamp (const wxString &format)
 	Sets the timestamp format prepended by the default log targets to all messages. More...
 
static void 	DisableTimestamp ()
 	Disables time stamping of the log messages. More...
 
static bool 	GetVerbose ()
 	Returns whether the verbose mode is currently active. More...
 
static void 	SetVerbose (bool verbose=true)
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
