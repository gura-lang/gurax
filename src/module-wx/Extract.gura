import(re)

//------------------------------------------------------------------------------
txt = R'''
int 	GetId () const
 
wxControl * 	GetControl () const
 
wxToolBarBase * 	GetToolBar () const
 
bool 	IsStretchable () const
 
bool 	IsButton () const
 
bool 	IsControl () const
 
bool 	IsSeparator () const
 
bool 	IsStretchableSpace () const
 
int 	GetStyle () const
 
wxItemKind 	GetKind () const
 
void 	MakeStretchable ()
 
bool 	IsEnabled () const
 
bool 	IsToggled () const
 
bool 	CanBeToggled () const
 
const wxBitmap & 	GetNormalBitmap () const
 
const wxBitmap & 	GetDisabledBitmap () const
 
const wxBitmap & 	GetBitmap () const
 
const wxString & 	GetLabel () const
 
const wxString & 	GetShortHelp () const
 
const wxString & 	GetLongHelp () const
 
wxObject * 	GetClientData () const
 
virtual bool 	Enable (bool enable)
 
virtual bool 	Toggle (bool toggle)
 
virtual bool 	SetToggle (bool toggle)
 
virtual bool 	SetShortHelp (const wxString &help)
 
virtual bool 	SetLongHelp (const wxString &help)
 
void 	Toggle ()
 
virtual void 	SetNormalBitmap (const wxBitmap &bmp)
 
virtual void 	SetDisabledBitmap (const wxBitmap &bmp)
 
virtual void 	SetLabel (const wxString &label)
 
void 	SetClientData (wxObject *clientData)
 
virtual void 	Detach ()
 
virtual void 	Attach (wxToolBarBase *tbar)
 
virtual void 	SetDropdownMenu (wxMenu *menu)
 
wxMenu * 	GetDropdownMenu () const
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
