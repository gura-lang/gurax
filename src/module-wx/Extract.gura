import(re)

//------------------------------------------------------------------------------
txt = R'''
long 	GetCacheFrom () const
 	For EVT_LIST_CACHE_HINT event only: return the first item which the list control advises us to cache. More...
 
long 	GetCacheTo () const
 	For EVT_LIST_CACHE_HINT event only: return the last item (inclusive) which the list control advises us to cache. More...
 
int 	GetColumn () const
 	The column position: it is only used with COL events. More...
 
wxUIntPtr 	GetData () const
 	The data. More...
 
int 	GetImage () const
 	The image. More...
 
long 	GetIndex () const
 	The item index. More...
 
const wxListItem & 	GetItem () const
 	An item object, used by some events. More...
 
int 	GetKeyCode () const
 	Key code if the event is a keypress event. More...
 
const wxString & 	GetLabel () const
 	The (new) item label for EVT_LIST_END_LABEL_EDIT event. More...
 
long 	GetMask () const
 	The mask. More...
 
wxPoint 	GetPoint () const
 	The position of the mouse pointer if the event is a drag event. More...
 
const wxString & 	GetText () const
 	The text. More...
 
bool 	IsEditCancelled () const
 	This method only makes sense for EVT_LIST_END_LABEL_EDIT message and returns true if it the label editing has been cancelled by the user (GetLabel() returns an empty string in this case but it doesn't allow the application to distinguish between really cancelling the edit and the admittedly rare case when the user wants to rename it to an empty string). More...
 
void 	SetKeyCode (int code)
 
void 	SetIndex (long index)
 
void 	SetColumn (int col)
 
void 	SetPoint (const wxPoint &point)
 
void 	SetItem (const wxListItem &item)
 
void 	SetCacheFrom (long cacheFrom)
 
void 	SetCacheTo (long cacheTo)
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
