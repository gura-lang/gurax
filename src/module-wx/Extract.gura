import(re)

//------------------------------------------------------------------------------
txt = R'''
virtual bool 	AddData (wxDataObject *data)
 	Call this function to add the data object to the clipboard. More...
 
virtual void 	Clear ()
 	Clears the global clipboard object and the system's clipboard if possible. More...
 
virtual void 	Close ()
 	Call this function to close the clipboard, having opened it with Open(). More...
 
virtual bool 	Flush ()
 	Flushes the clipboard: this means that the data which is currently on clipboard will stay available even after the application exits (possibly eating memory), otherwise the clipboard will be emptied on exit. More...
 
virtual bool 	GetData (wxDataObject &data)
 	Call this function to fill data with data on the clipboard, if available in the required format. More...
 
virtual bool 	IsOpened () const
 	Returns true if the clipboard has been opened. More...
 
virtual bool 	IsSupported (const wxDataFormat &format)
 	Returns true if there is data which matches the data format of the given data object currently available on the clipboard. More...
 
bool 	IsUsingPrimarySelection () const
 	Returns true if we are using the primary selection, false if clipboard one. More...
 
virtual bool 	Open ()
 	Call this function to open the clipboard before calling SetData() and GetData(). More...
 
virtual bool 	SetData (wxDataObject *data)
 	Call this function to set the data object to the clipboard. More...
 
virtual void 	UsePrimarySelection (bool primary=false)
 	On platforms supporting it (all X11-based ports), wxClipboard uses the CLIPBOARD X11 selection by default. More...
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
