import(re)

//------------------------------------------------------------------------------
txt = R'''
a 	wxAnimationCtrl (wxWindow *parent, wxWindowID id, const wxAnimation &anim=wxNullAnimation, const wxPoint &pos=wxDefaultPosition, const wxSize &size=wxDefaultSize, long style=wxAC_DEFAULT_STYLE, const wxString &name=wxAnimationCtrlNameStr)
 	Initializes the object and calls Create() with all the parameters. More...
 
bool 	Create (wxWindow *parent, wxWindowID id, const wxAnimation &anim=wxNullAnimation, const wxPoint &pos=wxDefaultPosition, const wxSize &size=wxDefaultSize, long style=wxAC_DEFAULT_STYLE, const wxString &name=wxAnimationCtrlNameStr)
 	Creates the control with the given anim animation. More...
 
virtual wxAnimation 	GetAnimation () const
 	Returns the animation associated with this control. More...
 
wxBitmap 	GetInactiveBitmap () const
 	Returns the inactive bitmap shown in this control when the; see SetInactiveBitmap() for more info. More...
 
virtual bool 	IsPlaying () const
 	Returns true if the animation is being played. More...
 
virtual bool 	LoadFile (const wxString &file, wxAnimationType animType=wxANIMATION_TYPE_ANY)
 	Loads the animation from the given file and calls SetAnimation(). More...
 
virtual bool 	Load (wxInputStream &file, wxAnimationType animType=wxANIMATION_TYPE_ANY)
 	Loads the animation from the given stream and calls SetAnimation(). More...
 
virtual bool 	Play ()
 	Starts playing the animation. More...
 
virtual void 	SetAnimation (const wxAnimation &anim)
 	Sets the animation to play in this control. More...
 
virtual void 	SetInactiveBitmap (const wxBitmap &bmp)
 	Sets the bitmap to show on the control when it's not playing an animation. More...
 
virtual void 	Stop ()
 	Stops playing the animation. More...
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
