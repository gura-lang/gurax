import(re)

//------------------------------------------------------------------------------
txt = R'''
a 	wxGenericProgressDialog (const wxString &title, const wxString &message, int maximum=100, wxWindow *parent=NULL, int style=wxPD_AUTO_HIDE|wxPD_APP_MODAL)
 	Constructor. More...
 
int 	GetValue () const
 	Returns the last value passed to the Update() function or wxNOT_FOUND if the dialog has no progress bar. More...
 
int 	GetRange () const
 	Returns the maximum value of the progress meter, as passed to the constructor or wxNOT_FOUND if the dialog has no progress bar. More...
 
wxString 	GetMessage () const
 	Returns the last message passed to the Update() function; if you always passed wxEmptyString to Update() then the message set through the constructor is returned. More...
 
virtual bool 	Pulse (const wxString &newmsg=wxEmptyString, bool *skip=NULL)
 	Like Update() but makes the gauge control run in indeterminate mode. More...
 
void 	Resume ()
 	Can be used to continue with the dialog, after the user had clicked the "Abort" button. More...
 
void 	SetRange (int maximum)
 	Changes the maximum value of the progress meter given in the constructor. More...
 
bool 	WasCancelled () const
 	Returns true if the "Cancel" button was pressed. More...
 
bool 	WasSkipped () const
 	Returns true if the "Skip" button was pressed. More...
 
virtual bool 	Update (int value, const wxString &newmsg=wxEmptyString, bool *skip=NULL)
 	Updates the dialog, setting the progress bar to the new value and updating the message if new one is specified. More...
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
