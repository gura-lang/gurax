import(re)

//------------------------------------------------------------------------------
txt = R'''
virtual void 	Clear ()
 	Clears the current region. More...
 
wxRegionContain 	Contains (wxCoord x, wxCoord y) const
 	Returns a value indicating whether the given point is contained within the region. More...
 
wxRegionContain 	Contains (const wxPoint &pt) const
 	Returns a value indicating whether the given point is contained within the region. More...
 
wxRegionContain 	Contains (wxCoord x, wxCoord y, wxCoord width, wxCoord height) const
 	Returns a value indicating whether the given rectangle is contained within the region. More...
 
wxRegionContain 	Contains (const wxRect &rect) const
 	Returns a value indicating whether the given rectangle is contained within the region. More...
 
wxBitmap 	ConvertToBitmap () const
 	Convert the region to a black and white bitmap with the white pixels being inside the region. More...
 
bool 	Intersect (wxCoord x, wxCoord y, wxCoord width, wxCoord height)
 	Finds the intersection of this region and another, rectangular region, specified using position and size. More...
 
bool 	Intersect (const wxRect &rect)
 	Finds the intersection of this region and another, rectangular region. More...
 
bool 	Intersect (const wxRegion &region)
 	Finds the intersection of this region and another region. More...
 
virtual bool 	IsEmpty () const
 	Returns true if the region is empty, false otherwise. More...
 
bool 	IsEqual (const wxRegion &region) const
 	Returns true if the region is equal to, i.e. covers the same area as, another one. More...
 
bool 	Subtract (const wxRect &rect)
 	Subtracts a rectangular region from this region. More...
 
bool 	Subtract (const wxRegion &region)
 	Subtracts a region from this region. More...
 
bool 	Union (wxCoord x, wxCoord y, wxCoord width, wxCoord height)
 	Finds the union of this region and another, rectangular region, specified using position and size. More...
 
bool 	Union (const wxRect &rect)
 	Finds the union of this region and another, rectangular region. More...
 
bool 	Union (const wxRegion &region)
 	Finds the union of this region and another region. More...
 
bool 	Union (const wxBitmap &bmp)
 	Finds the union of this region and the non-transparent pixels of a bitmap. More...
 
bool 	Union (const wxBitmap &bmp, const wxColour &transColour, int tolerance=0)
 	Finds the union of this region and the non-transparent pixels of a bitmap. More...
 
bool 	Xor (wxCoord x, wxCoord y, wxCoord width, wxCoord height)
 	Finds the Xor of this region and another, rectangular region, specified using position and size. More...
 
bool 	Xor (const wxRect &rect)
 	Finds the Xor of this region and another, rectangular region. More...
 
bool 	Xor (const wxRegion &region)
 	Finds the Xor of this region and another region. More...
 
wxRegion & 	operator= (const wxRegion &region)
 	Assignment operator, using Reference Counting. More...
 
void 	GetBox (wxCoord &x, wxCoord &y, wxCoord &width, wxCoord &height) const
 	Returns the outer bounds of the region. More...
 
wxRect 	GetBox () const
 	Returns the outer bounds of the region. More...
 
bool 	Offset (wxCoord x, wxCoord y)
 	Moves the region by the specified offsets in horizontal and vertical directions. More...
 
bool 	Offset (const wxPoint &pt)
 	Moves the region by the specified offsets in horizontal and vertical directions. More...
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
