import(re)

//------------------------------------------------------------------------------
txt = R'''
 
virtual int 	GetCurrentSelection () const
 	Returns the item being selected right now. More...
 
virtual long 	GetInsertionPoint () const
 	Same as wxTextEntry::GetInsertionPoint(). More...
 
bool 	IsEmpty () const
 	IsEmpty() is not available in this class. More...
 
bool 	IsListEmpty () const
 	Returns true if the list of combobox choices is empty. More...
 
bool 	IsTextEmpty () const
 	Returns true if the text of the combobox is empty. More...
 
virtual void 	SetSelection (long from, long to)
 	Same as wxTextEntry::SetSelection(). More...
 
virtual void 	SetValue (const wxString &text)
 	Sets the text for the combobox text field. More...
 
virtual void 	Popup ()
 	Shows the list box portion of the combo box. More...
 
virtual void 	Dismiss ()
 	Hides the list box portion of the combo box. More...
 
virtual int 	GetSelection () const
 	Returns the index of the selected item or wxNOT_FOUND if no item is selected. More...
 
virtual void 	GetSelection (long *from, long *to) const
 	Gets the current selection span. More...
 
virtual void 	SetSelection (int n)
 	Sets the selection to the given item n or removes the selection entirely if n == wxNOT_FOUND. More...
 
virtual int 	FindString (const wxString &s, bool bCase=false) const
 	Finds an item whose label matches the given string. More...
 
virtual wxString 	GetString (unsigned int n) const
 	Returns the label of the item with the given index. More...
 
virtual wxString 	GetStringSelection () const
 	Gets the text currently selected in the control. More...
 
virtual void 	SetString (unsigned int n, const wxString &text)
 	Changes the text of the specified combobox item. More...
 
virtual unsigned int 	GetCount () const
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
