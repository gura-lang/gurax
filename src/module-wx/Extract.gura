import(re)

//------------------------------------------------------------------------------
txt = R'''
void 	EnableEffects (bool enable)
 	Enables or disables "effects" under Windows or generic only. More...
 
bool 	GetAllowSymbols () const
 	Under Windows, returns a flag determining whether symbol fonts can be selected. More...
 
wxFont 	GetChosenFont () const
 	Gets the font chosen by the user if the user pressed OK (wxFontDialog::ShowModal() returned wxID_OK). More...
 
const wxColour & 	GetColour () const
 	Gets the colour associated with the font dialog. More...
 
bool 	GetEnableEffects () const
 	Determines whether "effects" are enabled under Windows. More...
 
wxFont 	GetInitialFont () const
 	Gets the font that will be initially used by the font dialog. More...
 
bool 	GetShowHelp () const
 	Returns true if the Help button will be shown (Windows only). More...
 
void 	SetAllowSymbols (bool allowSymbols)
 	Under Windows, determines whether symbol fonts can be selected. More...
 
void 	SetChosenFont (const wxFont &font)
 	Sets the font that will be returned to the user (for internal use only). More...
 
void 	SetColour (const wxColour &colour)
 	Sets the colour that will be used for the font foreground colour. More...
 
void 	SetInitialFont (const wxFont &font)
 	Sets the font that will be initially used by the font dialog. More...
 
void 	SetRange (int min, int max)
 	Sets the valid range for the font point size (Windows only). More...
 
void 	SetShowHelp (bool showHelp)
 	Determines whether the Help button will be displayed in the font dialog (Windows only). More...
 
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
