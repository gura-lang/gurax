import(re)

//------------------------------------------------------------------------------
txt = R'''
int 	GetId () const
 	Returns the ID of the events generated by this timer. More...
 
int 	GetInterval () const
 	Returns the current interval for the timer (in milliseconds). More...
 
wxEvtHandler * 	GetOwner () const
 	Returns the current owner of the timer. More...
 
bool 	IsOneShot () const
 	Returns true if the timer is one shot, i.e. if it will stop after firing the first notification automatically. More...
 
bool 	IsRunning () const
 	Returns true if the timer is running, false if it is stopped. More...
 
virtual void 	Notify ()
 	This member should be overridden by the user if the default constructor was used and SetOwner() wasn't called. More...
 
void 	SetOwner (wxEvtHandler *owner, int id=-1)
 	Associates the timer with the given owner object. More...
 
virtual bool 	Start (int milliseconds=-1, bool oneShot=wxTIMER_CONTINUOUS)
 	(Re)starts the timer. More...
 
bool 	StartOnce (int milliseconds=-1)
 	Starts the timer for a once-only notification. More...
 
virtual void 	Stop ()
 
	Stops the timer. More...
 
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
