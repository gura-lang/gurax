import(re)

//------------------------------------------------------------------------------
txt = R'''
a 	wxImageList (int width, int height, bool mask=true, int initialCount=1)
 	Constructor specifying the image size, whether image masks should be created, and the initial size of the list. More...
 
int 	Add (const wxBitmap &bitmap, const wxBitmap &mask=wxNullBitmap)
 	Adds a new image or images using a bitmap and optional mask bitmap. More...
 
int 	Add (const wxBitmap &bitmap, const wxColour &maskColour)
 	Adds a new image or images using a bitmap and mask colour. More...
 
int 	Add (const wxIcon &icon)
 	Adds a new image using an icon. More...
 
bool 	Create (int width, int height, bool mask=true, int initialCount=1)
 	Initializes the list. More...
 
virtual bool 	Draw (int index, wxDC &dc, int x, int y, int flags=wxIMAGELIST_DRAW_NORMAL, bool solidBackground=false)
 	Draws a specified image onto a device context. More...
 
wxBitmap 	GetBitmap (int index) const
 	Returns the bitmap corresponding to the given index. More...
 
wxIcon 	GetIcon (int index) const
 	Returns the icon corresponding to the given index. More...
 
virtual int 	GetImageCount () const
 	Returns the number of images in the list. More...
 
virtual bool 	GetSize (int index, int &width, int &height) const
 	Retrieves the size of the images in the list. More...
 
bool 	Remove (int index)
 	Removes the image at the given position. More...
 
bool 	RemoveAll ()
 	Removes all the images in the list. More...
 
bool 	Replace (int index, const wxBitmap &bitmap, const wxBitmap &mask=wxNullBitmap)
 	Replaces the existing image with the new image. More...
 
bool 	Replace (int index, const wxIcon &icon)
 	Replaces the existing image with the new image. More...
 
'''
//------------------------------------------------------------------------------

txt.EachLine {|line, iLine|
	iLine += 1
	if (m = line.Match('^@(.+)')) {
		Println('\t//--------------------------------------------------------------------------')
		Printf('\t// %s\n', m[1])
	} elsif (m = line.Match(r'^\s')) {
		// nothing to do
	} elsif (m = line.Match(r'^//')) {
		// nothing to do
	} elsif (m = line.Match(r'^(.+[^\w])(\w+)\s*\(([^)]*)\)')) {
		attrs = ''
		typeRtn = m[1].Strip()
		funcName = m[2]
		args = m[3].SplitReg(r',\s*'):list
		if (m = typeRtn.Match(r'^static\s+(.+)')) {
			attrs += ':static'
			typeRtn = m[1]
		}
		typeRtn = typeRtn.Sub(r'^virtual\s+', '').Sub(r'^const\s+', '').Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
		argsMod = args.Each():xiter {|arg|
			arg.IsEmpty() && continue
			fields = arg.Split('='):list
			m = fields[0].Strip().Match(r'^(.+[^\w])(\w+)$')
			if (!m) {
				Printf('Error:%d: %s\n', iLine, line.Chop())
				sys.Exit(1)
			}
			typeArg = m[1].Strip().Sub(r'^wx', '').Sub(r'([ &\*])wx', r'\1').Sub(r'\s*&', '_r').Sub(r'\s*\*', '_p').Sub(r'\s+', '_')
			argName = m[2]
			str = Format('%s as %s', argName, typeArg)
			if (fields.len == 2) {
				str += Format(' = %s', fields[1].Strip())
			}
			str
		}.Join(', ')
		Printf('\t%s(%s)%s as %s\n', funcName, argsMod, attrs, typeRtn)
	}
}
