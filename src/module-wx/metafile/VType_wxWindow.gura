//==============================================================================
// VType_wxWindow.gura
//==============================================================================
Window = Class(EvtHandler) {
	__init__()
	//--------------------------------------------------------------------------
	// Focus functions
	//--------------------------------------------------------------------------
	AcceptsFocus():const:virtual as bool
	AcceptsFocusFromKeyboard():const:virtual as bool
	AcceptsFocusRecursively():const:virtual as bool
	IsFocusable() as bool
	CanAcceptFocus() as bool
	CanAcceptFocusFromKeyboard() as bool
	HasFocus():const:virtual as bool
	SetCanFocus(canFocus as bool):virtual as void
	SetFocus() as void
	SetFocusFromKbd() as void
	//--------------------------------------------------------------------------
	// Child management functions
	//--------------------------------------------------------------------------
	AddChild(child as Window_p) as void
	DestroyChildren() as bool
	FindWindow(args* as any) as void = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("id", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			long id = args.PickNumber<long>();
			wxWindow* rtn = pEntity_gurax->FindWindow(id);
			return new Value_wxWindow(rtn);
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("name", VTYPE_String);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const char* name = args.PickString();
			wxWindow* rtn = pEntity_gurax->FindWindow(name);
			return new Value_wxWindow(rtn);
		} while (0);
		return Value::nil();
		'''
	//GetChildren() as WindowList
	//GetChildren() as WindowList
	RemoveChild(child as Window_p) as void
	//--------------------------------------------------------------------------
	// Sibling and parent management functions
	//--------------------------------------------------------------------------
	GetGrandParent() as Window_p
	GetNextSibling() as Window_p
	GetParent() as Window_p
	GetPrevSibling() as Window_p
	//IsDescendant(win as WindowBase_p) as bool
	Reparent(newParent as Window_p) as bool
	//--------------------------------------------------------------------------
	// Scrolling and scrollbars functions
	//--------------------------------------------------------------------------
	AlwaysShowScrollbars(hflag as bool = true, vflag as bool = true) as void
	GetScrollPos(orientation as int) as int
	GetScrollRange(orientation as int) as int
	GetScrollThumb(orientation as int) as int
	CanScroll(orient as int) as bool
	HasScrollbar(orient as int) as bool
	IsScrollbarAlwaysShown(orient as int) as bool
	ScrollLines(lines as int) as bool
	ScrollPages(pages as int) as bool
	ScrollWindow(dx as int, dy as int, rect? as const_Rect_p) as void
	LineUp() as bool
	LineDown() as bool
	PageUp() as bool
	PageDown() as bool
	SetScrollPos(orientation as int, pos as int, refresh as bool = true) as void
	SetScrollbar(orientation as int, position as int, thumbSize as int, range as int, refresh as bool = true) as void
	//--------------------------------------------------------------------------
	// Sizing functions
	//--------------------------------------------------------------------------
	//DoGetBestClientSize() as See_also_the_protected_functions_DoGetBestSize()_and
	BeginRepositioningChildren() as bool
	EndRepositioningChildren() as void
	CacheBestSize(size as const_Size_r) as void
	ClientToWindowSize(size as const_Size_r) as Size
	WindowToClientSize(size as const_Size_r) as Size
	Fit() as void
	FitInside() as void
	GetBestSize() as Size
	GetBestHeight(width as int) as int
	GetBestWidth(height as int) as int
	GetClientSize() as Size
	GetClientSizeWH() as Tuple@gurax = \
		R'''
		int width, height;
		pEntity_gurax->GetClientSize(&width, &height);
		return Value_Tuple::Create(new Value_Number(width), new Value_Number(height));
		'''
	GetEffectiveMinSize() as Size
	GetMaxClientSize() as Size
	GetMaxSize() as Size
	GetMinClientSize() as Size
	GetMinSize() as Size
	GetMinWidth() as int
	GetMinHeight() as int
	GetMaxWidth() as int
	GetMaxHeight() as int
	GetSize() as Size
	GetSizeWH() as Tuple@gurax = \
		R'''
		int width, height;
		pEntity_gurax->GetSize(&width, &height);
		return Value_Tuple::Create(new Value_Number(width), new Value_Number(height));
		'''
	GetVirtualSize() as Size
	GetVirtualSizeWH() as Tuple@gurax = \
		R'''
		int width, height;
		pEntity_gurax->GetVirtualSize(&width, &height);
		return Value_Tuple::Create(new Value_Number(width), new Value_Number(height));
		'''
	GetBestVirtualSize() as Size
	GetContentScaleFactor() as double
	GetWindowBorderSize() as Size
	InformFirstDirection(direction as int, size as int, availableOtherDir as int) as bool
	InvalidateBestSize() as void
	PostSizeEvent() as void
	PostSizeEventToParent() as void
	SendSizeEvent(flags as int = 0) as void
	SendSizeEventToParent(flags as int = 0) as void
	SetClientSize(args* as any) as void = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int width = args.PickNumber<int>();
			int height = args.PickNumber<int>();
			pEntity_gurax->SetClientSize(width, height);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("size", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxSize& size = args.Pick<Value_wxSize>().GetEntity();
			pEntity_gurax->SetClientSize(size);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("rect", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxRect& rect = args.Pick<Value_wxRect>().GetEntity();
			pEntity_gurax->SetClientSize(rect);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	SetContainingSizer(sizer as Sizer_p) as void
	SetInitialSize(size as const_Size_r = wxDefaultSize) as void
	SetMaxClientSize(size as const_Size_r) as void
	SetMaxSize(size as const_Size_r) as void
	SetMinClientSize(size as const_Size_r) as void
	SetMinSize(size as const_Size_r) as void
	SetSize(args* as any) as void = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
				pDeclCallable->DeclareArg("sizeFlags", VTYPE_Number, DeclArg::Occur::ZeroOrOnce);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int x = args.PickNumber<int>();
			int y = args.PickNumber<int>();
			int width = args.PickNumber<int>();
			int height = args.PickNumber<int>();
			int sizeFlags = args.IsValid()? args.PickNumber<int>() : wxSIZE_AUTO;
			pEntity_gurax->SetSize(x, y, width, height, sizeFlags);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int width = args.PickNumber<int>();
			int height = args.PickNumber<int>();
			pEntity_gurax->SetSize(width, height);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("size", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxSize& size = args.Pick<Value_wxSize>().GetEntity();
			pEntity_gurax->SetSize(size);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("rect", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxRect& rect = args.Pick<Value_wxRect>().GetEntity();
			pEntity_gurax->SetSize(rect);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	SetSizeHints(args* as any) as void = \
		R'''
		// SetSizeHints(minSize as const_Size_r, maxSize as const_Size_r = wxDefaultSize, incSize as const_Size_r = wxDefaultSize) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("minSize", VTYPE_wxSize);
				pDeclCallable->DeclareArg("maxSize", VTYPE_wxSize, DeclArg::Occur::ZeroOrOnce);
				pDeclCallable->DeclareArg("incSize", VTYPE_wxSize, DeclArg::Occur::ZeroOrOnce);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxSize& minSize = args.Pick<Value_wxSize>().GetEntity();
			const wxSize& maxSize = args.IsValid()? args.Pick<Value_wxSize>().GetEntity() : wxDefaultSize;
			const wxSize& incSize = args.IsValid()? args.Pick<Value_wxSize>().GetEntity() : wxDefaultSize;
			pEntity_gurax->SetSizeHints(minSize, maxSize, incSize);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// SetSizeHints(minW as int, minH as int, maxW as int = -1, maxH as int = -1, incW as int = -1, incH as int = -1) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("minW", VTYPE_Number);
				pDeclCallable->DeclareArg("minH", VTYPE_Number);
				pDeclCallable->DeclareArg("maxW", VTYPE_Number, DeclArg::Occur::ZeroOrOnce);
				pDeclCallable->DeclareArg("maxH", VTYPE_Number, DeclArg::Occur::ZeroOrOnce);
				pDeclCallable->DeclareArg("incW", VTYPE_Number, DeclArg::Occur::ZeroOrOnce);
				pDeclCallable->DeclareArg("incH", VTYPE_Number, DeclArg::Occur::ZeroOrOnce);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int minW = args.PickNumber<int>();
			int minH = args.PickNumber<int>();
			int maxW = args.IsValid()? args.PickNumber<int>() : -1;
			int maxH = args.IsValid()? args.PickNumber<int>() : -1;
			int incW = args.IsValid()? args.PickNumber<int>() : -1;
			int incH = args.IsValid()? args.PickNumber<int>() : -1;
			pEntity_gurax->SetSizeHints(minW, minH, maxW, maxH, incW, incH);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	SetVirtualSize(args* as any) as void = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int width = args.PickNumber<int>();
			int height = args.PickNumber<int>();
			pEntity_gurax->SetVirtualSize(width, height);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("size", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxSize& size = args.Pick<Value_wxSize>().GetEntity();
			pEntity_gurax->SetVirtualSize(size);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	//--------------------------------------------------------------------------
	// Positioning functions
	//--------------------------------------------------------------------------
	Center(dir as int = wxBOTH) as void
	CenterOnParent(dir as int = wxBOTH) as void
	Centre(direction as int = wxBOTH) as void
	CentreOnParent(direction as int = wxBOTH) as void
	GetPositionXY() as Tuple@gurax = \
		R'''
		int x, y;
		pEntity_gurax->GetPosition(&x, &y);
		return Value_Tuple::Create(new Value_Number(x), new Value_Number(y));
		'''
	GetPosition() as Point
	GetRect() as Rect
	GetScreenPositionXY() as Tuple@gurax = \
		R'''
		int x, y;
		pEntity_gurax->GetScreenPosition(&x, &y);
		return Value_Tuple::Create(new Value_Number(x), new Value_Number(y));
		'''
	GetScreenPosition() as Point
	GetScreenRect() as Rect
	GetClientAreaOrigin() as Point
	GetClientRect() as Rect
	Move(args* as any) = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("flags", VTYPE_Number, DeclArg::Occur::ZeroOrOnce);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int x = args.PickNumber<int>();
			int y = args.PickNumber<int>();
			int flags = args.IsValid()? args.PickNumber<int>() : wxSIZE_USE_EXISTING;
			pEntity_gurax->Move(x, y, flags);
			return Value::nil();;
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("flags", VTYPE_Number, DeclArg::Occur::ZeroOrOnce);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			int flags = args.IsValid()? args.PickNumber<int>() : wxSIZE_USE_EXISTING;
			pEntity_gurax->Move(pt, flags);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	SetPosition(pt as const_Point_r) as void
	//--------------------------------------------------------------------------
	// Coordinate conversion functions
	//--------------------------------------------------------------------------
	ClientToScreen(args* as any) = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int x = args.PickNumber<int>();
			int y = args.PickNumber<int>();
			pEntity_gurax->ClientToScreen(&x, &y);
			return Value_Tuple::Create(new Value_Number(x), new Value_Number(y));
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			wxPoint rtn = pEntity_gurax->ClientToScreen(pt);
			return new Value_wxPoint(rtn);
		} while (0);
		return Value::nil();
		'''
	ConvertDialogToPixels(args* as any) = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			wxPoint rtn = pEntity_gurax->ConvertDialogToPixels(pt);
			return new Value_wxPoint(rtn);
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("sz", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxSize& sz = args.Pick<Value_wxSize>().GetEntity();
			wxSize rtn = pEntity_gurax->ConvertDialogToPixels(sz);
			return new Value_wxSize(rtn);
		} while (0);
		return Value::nil();
		'''
	ConvertPixelsToDialog(args* as any) = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			wxPoint rtn = pEntity_gurax->ConvertPixelsToDialog(pt);
			return new Value_wxPoint(rtn);
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("sz", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxSize& sz = args.Pick<Value_wxSize>().GetEntity();
			wxSize rtn = pEntity_gurax->ConvertPixelsToDialog(sz);
			return new Value_wxSize(rtn);
		} while (0);
		return Value::nil();
		'''
	ScreenToClient(args* as any) = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int x = args.PickNumber<int>();
			int y = args.PickNumber<int>();
			pEntity_gurax->ScreenToClient(&x, &y);
			return Value_Tuple::Create(new Value_Number(x), new Value_Number(y));
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			wxPoint rtn = pEntity_gurax->ScreenToClient(pt);
			return new Value_wxPoint(rtn);
		} while (0);
		return Value::nil();
		'''
	//--------------------------------------------------------------------------
	// Drawing-related functions
	//--------------------------------------------------------------------------
	ClearBackground() as void
	Freeze() as void
	Thaw() as void
	IsFrozen() as bool
	GetBackgroundColour() as Colour
	GetBackgroundStyle() as BackgroundStyle
	GetCharHeight() as int
	GetCharWidth() as int
	GetDefaultAttributes() as VisualAttributes
	GetFont() as Font
	GetForegroundColour() as Colour
	GetTextExtentWH(string as const_String_r, font? as const_Font_p) as Tuple@gurax = \
		R'''
		int w, h, descent, externalLeading;
		pEntity_gurax->GetTextExtent(string, &w, &h, &descent, &externalLeading, font);
		return Value_Tuple::Create(new Value_Number(w), new Value_Number(h), new Value_Number(descent), new Value_Number(externalLeading));
		'''
	GetTextExtent(string as const_String_r) as Size
	GetUpdateRegion() as Region
	GetUpdateClientRect() as Rect
	HasTransparentBackground() as bool
	Refresh(eraseBackground as bool = true, rect as const_Rect_p = NULL) as void
	RefreshRect(rect as const_Rect_r, eraseBackground as bool = true) as void
	Update() as void
	SetBackgroundColour(colour as const_Colour_r) as bool
	SetBackgroundStyle(style as BackgroundStyle) as bool
	IsTransparentBackgroundSupported(reason? as String) as bool = \
		R'''
		bool rtn;
		if (reason) {
			wxString reason_(reason);
			rtn = pEntity_gurax->IsTransparentBackgroundSupported(&reason_);
		} else {
			rtn = pEntity_gurax->IsTransparentBackgroundSupported();
		}
		return new Value_Bool(rtn);
		'''
	SetFont(font as const_Font_r) as bool
	SetForegroundColour(colour as const_Colour_r) as bool
	SetOwnBackgroundColour(colour as const_Colour_r) as void
	InheritsBackgroundColour() as bool
	UseBgCol() as bool
	SetOwnFont(font as const_Font_r) as void
	SetOwnForegroundColour(colour as const_Colour_r) as void
	SetPalette(pal as const_Palette_r) as void
	ShouldInheritColours() as bool
	SetThemeEnabled(enable as bool) as void
	GetThemeEnabled() as bool
	CanSetTransparent() as bool
	SetTransparent(alpha as Byte) as bool
	//--------------------------------------------------------------------------
	// Event-handling functions
	//--------------------------------------------------------------------------
	GetEventHandler() as EvtHandler_p
	HandleAsNavigationKey(event as const_KeyEvent_r) as bool
	HandleWindowEvent(event as Event_r) as bool
	ProcessWindowEvent(event as Event_r) as bool
	ProcessWindowEventLocally(event as Event_r) as bool
	PopEventHandler(deleteHandler as bool = false) as EvtHandler_p
	PushEventHandler(handler as EvtHandler_p) as void
	RemoveEventHandler(handler as EvtHandler_p) as bool
	SetEventHandler(handler as EvtHandler_p) as void
	SetNextHandler(handler as EvtHandler_p) as void
	SetPreviousHandler(handler as EvtHandler_p) as void
	//--------------------------------------------------------------------------
	// Window styles functions
	//--------------------------------------------------------------------------
	GetExtraStyle() as long
	GetWindowStyleFlag() as long
	GetWindowStyle() as long
	HasExtraStyle(exFlag as int) as bool
	HasFlag(flag as int) as bool
	SetExtraStyle(exStyle as long) as void
	SetWindowStyleFlag(style as long) as void
	SetWindowStyle(style as long) as void
	ToggleWindowStyle(flag as int) as bool
	//--------------------------------------------------------------------------
	// Tab order functions
	//--------------------------------------------------------------------------
	MoveAfterInTabOrder(win as Window_p) as void
	MoveBeforeInTabOrder(win as Window_p) as void
	Navigate(flags as int = wxNavigationKeyEvent::IsForward) as bool
	NavigateIn(flags as int = wxNavigationKeyEvent::IsForward) as bool
	//--------------------------------------------------------------------------
	// Z order functions
	//--------------------------------------------------------------------------
	Lower() as void
	Raise() as void
	//--------------------------------------------------------------------------
	// Window status functions
	//--------------------------------------------------------------------------
	Hide() as bool
	HideWithEffect(effect as ShowEffect, timeout as unsigned_int = 0) as bool
	IsEnabled() as bool
	IsExposed(args* as any) as bool = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int x = args.PickNumber<int>();
			int y = args.PickNumber<int>();
			bool rtn = pEntity_gurax->IsExposed(x, y);
			return new Value_Bool(rtn);
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("w", VTYPE_Number);
				pDeclCallable->DeclareArg("h", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int x = args.PickNumber<int>();
			int y = args.PickNumber<int>();
			int w = args.PickNumber<int>();
			int h = args.PickNumber<int>();
			bool rtn = pEntity_gurax->IsExposed(x, y, w, h);
			return new Value_Bool(rtn);
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			bool rtn = pEntity_gurax->IsExposed(pt);
			return new Value_Bool(rtn);
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("rect", VTYPE_wxRect);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxRect& rect = args.Pick<Value_wxRect>().GetEntity();
			bool rtn = pEntity_gurax->IsExposed(rect);
			return new Value_Bool(rtn);
		} while (0);
		return Value::nil();
		'''
	IsShown() as bool
	IsShownOnScreen() as bool
	Disable() as bool
	Enable(enable as bool = true) as bool
	Show(show as bool = true) as bool
	ShowWithEffect(effect as ShowEffect, timeout as unsigned_int = 0) as bool
	//--------------------------------------------------------------------------
	// Context-sensitive help functions
	//--------------------------------------------------------------------------
	GetHelpText() as String
	SetHelpText(helpText as const_String_r) as void
	//GetHelpTextAtPoint(point as const_Point_r, origin as HelpEvent::Origin) as String
	GetToolTip() as ToolTip_p
	GetToolTipText() as String
	SetToolTip(args* as any) as void = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("tipString", VTYPE_String);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxMenu& menu = args.Pick<Value_wxMenu>().GetEntity();
			const char* tipString = args.PickString();
			pEntity_gurax->SetToolTip(tipString);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("tip", VTYPE_wxToolTip);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxToolTip* tip = args.Pick<Value_wxToolTip>().GetEntityPtr();
			pEntity_gurax->SetToolTip(tip);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	UnsetToolTip() as void
	//--------------------------------------------------------------------------
	// Popup/context menu functions
	//--------------------------------------------------------------------------
	GetPopupMenuSelectionFromUser(args* as any) = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("menu", VTYPE_wxMenu);
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxMenu& menu = args.Pick<Value_wxMenu>().GetEntity();
			int x = args.PickNumber<int>();
			int y = args.PickNumber<int>();
			int rtn = pEntity_gurax->GetPopupMenuSelectionFromUser(menu, x, y);
			return new Value_Number(rtn);
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("menu", VTYPE_wxMenu);
				pDeclCallable->DeclareArg("pos", VTYPE_wxPoint, DeclArg::Occur::ZeroOrOnce);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxMenu& menu = args.Pick<Value_wxMenu>().GetEntity();
			const wxPoint& pos = args.IsValid()? args.Pick<Value_wxPoint>().GetEntity() : wxDefaultPosition;
			int rtn = pEntity_gurax->GetPopupMenuSelectionFromUser(menu, pos);
			return new Value_Number(rtn);
		} while (0);
		return Value::nil();
		'''
	PopupMenu(args* as any) = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("menu", VTYPE_wxMenu);
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxMenu* menu = args.Pick<Value_wxMenu>().GetEntityPtr();
			int x = args.PickNumber<int>();
			int y = args.PickNumber<int>();
			bool rtn = pEntity_gurax->PopupMenu(menu, x, y);
			return new Value_Bool(rtn);
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("menu", VTYPE_wxMenu);
				pDeclCallable->DeclareArg("pos", VTYPE_wxPoint, DeclArg::Occur::ZeroOrOnce);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxMenu* menu = args.Pick<Value_wxMenu>().GetEntityPtr();
			const wxPoint& pos = args.IsValid()? args.Pick<Value_wxPoint>().GetEntity() : wxDefaultPosition;
			bool rtn = pEntity_gurax->PopupMenu(menu, pos);
			return new Value_Bool(rtn);
		} while (0);
		return Value::nil();
		'''
	GetValidator() as Validator_p
	SetValidator(validator as const_Validator_r) as void
	TransferDataFromWindow() as bool
	TransferDataToWindow() as bool
	Validate() as bool
	//--------------------------------------------------------------------------
	// wxWindow properties functions
	//--------------------------------------------------------------------------
	GetId() as WindowID
	GetLabel() as String
	GetLayoutDirection() as LayoutDirection
	AdjustForLayoutDirection(x as Coord, width as Coord, widthTotal as Coord) as Coord
	GetName() as String
	GetWindowVariant() as WindowVariant
	SetId(winid as WindowID) as void
	SetLabel(label as const_String_r) as void
	SetLayoutDirection(dir as LayoutDirection) as void
	SetName(name as const_String_r) as void
	SetWindowVariant(variant as WindowVariant) as void
	GetAcceleratorTable() as AcceleratorTable_p
	GetAccessible() as Accessible_p
	SetAcceleratorTable(accel as const_AcceleratorTable_r) as void
	SetAccessible(accessible as Accessible_p) as void
	//--------------------------------------------------------------------------
	// Window deletion functions
	//--------------------------------------------------------------------------
	Close(force as bool = false) as bool
	Destroy() as bool
	IsBeingDeleted() as bool
	//--------------------------------------------------------------------------
	// Drag and drop functions
	//--------------------------------------------------------------------------
	GetDropTarget() as DropTarget_p
	SetDropTarget(target as DropTarget_p) as void
	DragAcceptFiles(accept as bool) as void
	//--------------------------------------------------------------------------
	// Constraints, sizers and window layout functions
	//--------------------------------------------------------------------------
	GetContainingSizer() as Sizer_p
	GetSizer() as Sizer_p
	SetSizer(sizer as Sizer_p, deleteOld as bool = true) as void
	SetSizerAndFit(sizer as Sizer_p, deleteOld as bool = true) as void
	GetConstraints() as LayoutConstraints_p
	SetConstraints(constraints as LayoutConstraints_p) as void
	Layout() as bool
	SetAutoLayout(autoLayout as bool) as void
	GetAutoLayout() as bool
	//--------------------------------------------------------------------------
	// Mouse functions
	//--------------------------------------------------------------------------
	CaptureMouse() as void
	GetCaret() as Caret_p
	GetCursor() as Cursor
	HasCapture() as bool
	ReleaseMouse() as void
	SetCaret(caret as Caret_p) as void
	SetCursor(cursor as const_Cursor_r) as bool
	WarpPointer(x as int, y as int) as void
	//--------------------------------------------------------------------------
	// Miscellaneous functions
	//--------------------------------------------------------------------------
	HitTest(args* as any) = \
		R'''
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			int x = args.PickNumber<int>();
			int y = args.PickNumber<int>();
			wxHitTest rtn = pEntity_gurax->HitTest(x, y);
			return new Value_Number(rtn);
		} while (0);
		Error::ClearIssuedFlag();
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			wxHitTest rtn = pEntity_gurax->HitTest(pt);
			return new Value_Number(rtn);
		} while (0);
		return Value::nil();
		'''
	GetBorder(flags as long) as Border
	//GetBorder() as Border
	//DoUpdateWindowUI(event as UpdateUIEvent_r) as void
	//GetHandle() as WXWidget
	HasMultiplePages() as bool
	InheritAttributes() as void
	InitDialog() as void
	IsDoubleBuffered() as bool
	SetDoubleBuffered(on as bool) as void
	IsRetained() as bool
	IsThisEnabled() as bool
	IsTopLevel() as bool
	OnInternalIdle() as void
	SendIdleEvents(event as IdleEvent_r) as bool
	RegisterHotKey(hotkeyId as int, modifiers as int, virtualKeyCode as int) as bool
	UnregisterHotKey(hotkeyId as int) as bool
	UpdateWindowUI(flags as long = wxUPDATE_UI_NONE) as void
}

@const { // Styles
	BORDER_DEFAULT
	BORDER_SIMPLE
	BORDER_SUNKEN
	BORDER_RAISED
	BORDER_STATIC
	BORDER_THEME
	BORDER_NONE
	BORDER_DOUBLE
	TRANSPARENT_WINDOW
	TAB_TRAVERSAL
	WANTS_CHARS
	NO_FULL_REPAINT_ON_RESIZE
	VSCROLL
	HSCROLL
	ALWAYS_SHOW_SB
	CLIP_CHILDREN
	FULL_REPAINT_ON_RESIZE
}

@const { // Extra Styles
	WS_EX_VALIDATE_RECURSIVELY
	WS_EX_BLOCK_EVENTS
	WS_EX_TRANSIENT
	WS_EX_CONTEXTHELP
	WS_EX_PROCESS_IDLE
	WS_EX_PROCESS_UI_UPDATES
}
