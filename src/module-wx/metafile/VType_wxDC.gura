//==============================================================================
// VType_wxDC.gura
//==============================================================================
DC = Class {
	@include['wx/dc.h']
	CopyAttributes(dc as const_DC_r) as void
	GetDepth() as int
	GetDeviceOrigin() as Point
	GetLogicalFunction() as RasterOperationMode
	GetMapMode() as MappingMode
	GetPixel(x as Coord, y as Coord) as Colour = \
		R'''
		wxColour colour;
		bool rtn = pEntity_gurax->GetPixel(x, y, &colour);
		if (!rtn) return Value::nil();
		return new Value_wxColour(colour);
		'''
	GetPPI() as Size
	GetSize() as Size
	GetSizeMM() as Size
	GetUserScale(&x:nilRef as double, &y:nilRef as double) as void = \
		R'''
		double x_, y_;
		pEntity_gurax->GetUserScale(&x_, &y_);
		x->SetValue(new Value_Number(x_));
		y->SetValue(new Value_Number(y_));
		return Value::nil();
		'''
	IsOk() as bool
	SetAxisOrientation(xLeftRight as bool, yBottomUp as bool) as void
	SetDeviceOrigin(x as Coord, y as Coord) as void
	SetLogicalFunction(function as RasterOperationMode) as void
	SetMapMode(mode as MappingMode) as void
	SetPalette(palette as const_Palette_r) as void
	SetUserScale(xScale as double, yScale as double) as void
	//GetHandle()
	GetAsBitmap(subrect as const_Rect_p = nullptr) as Bitmap
	SetLogicalScale(x as double, y as double) as void
	GetLogicalScale(&x:nilRef as double, &y:nilRef as double) as void = \
		R'''
		double x_, y_;
		pEntity_gurax->GetLogicalScale(&x_, &y_);
		x->SetValue(new Value_Number(x_));
		y->SetValue(new Value_Number(y_));
		return Value::nil();
		'''
	SetLogicalOrigin(x as Coord, y as Coord) as void
	// Coordinate conversion functions
	DeviceToLogicalX(x as Coord):map as Coord
	DeviceToLogicalXRel(x as Coord):map as Coord
	DeviceToLogicalY(y as Coord):map as Coord
	DeviceToLogicalYRel(y as Coord):map as Coord
	LogicalToDeviceX(x as Coord):map as Coord
	LogicalToDeviceXRel(x as Coord):map as Coord
	LogicalToDeviceY(y as Coord):map as Coord
	LogicalToDeviceYRel(y as Coord):map as Coord
	// Drawing function
	Clear() as void
	DrawArc(args* as any):map as void = \
		R'''
		// DrawArc(xStart as Coord, yStart as Coord, xEnd as Coord, yEnd as Coord, xc as Coord, yc as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("xStart", VTYPE_Number);
				pDeclCallable->DeclareArg("yStart", VTYPE_Number);
				pDeclCallable->DeclareArg("xEnd", VTYPE_Number);
				pDeclCallable->DeclareArg("yEnd", VTYPE_Number);
				pDeclCallable->DeclareArg("xc", VTYPE_Number);
				pDeclCallable->DeclareArg("yc", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord xStart = args.PickNumber<wxCoord>();
			wxCoord yStart = args.PickNumber<wxCoord>();
			wxCoord xEnd = args.PickNumber<wxCoord>();
			wxCoord yEnd = args.PickNumber<wxCoord>();
			wxCoord xc = args.PickNumber<wxCoord>();
			wxCoord yc = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawArc(xStart, yStart, xEnd, yEnd, xc, yc);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawArc(ptStart as const_Point_r, ptEnd as const_Point_r, centre as const_Point_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("ptStart", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("ptEnd", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("centre", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& ptStart = args.Pick<Value_wxPoint>().GetEntity();
			const wxPoint& ptEnd = args.Pick<Value_wxPoint>().GetEntity();
			const wxPoint& centre = args.Pick<Value_wxPoint>().GetEntity();
			pEntity_gurax->DrawArc(ptStart, ptEnd, centre);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawBitmap(args* as any):map as void = \
		R'''
		// DrawBitmap(bitmap as const_Bitmap_r, x as Coord, y as Coord, useMask as bool = false) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("bitmap", VTYPE_wxBitmap);
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("useMask", VTYPE_Bool, DeclArg::Occur::ZeroOrOnce);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxBitmap& bitmap = args.Pick<Value_wxBitmap>().GetEntity();
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			bool useMask = args.IsValid()? args.PickBool() : false;
			pEntity_gurax->DrawBitmap(bitmap, x, y, useMask);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawBitmap(bmp as const_Bitmap_r, pt as const_Point_r, useMask as bool = false) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("bitmap", VTYPE_wxBitmap);
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("useMask", VTYPE_Bool, DeclArg::Occur::ZeroOrOnce);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxBitmap& bitmap = args.Pick<Value_wxBitmap>().GetEntity();
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			bool useMask = args.IsValid()? args.PickBool() : false;
			pEntity_gurax->DrawBitmap(bitmap, pt, useMask);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawCheckMark(args* as any):map as void = \
		R'''
		// DrawCheckMark(x as Coord, y as Coord, width as Coord, height as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			wxCoord width = args.PickNumber<wxCoord>();
			wxCoord height = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawCheckMark(x, y, width, height);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawCheckMark(rect as const_Rect_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("rect", VTYPE_wxRect);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxRect& rect = args.Pick<Value_wxRect>().GetEntity();
			pEntity_gurax->DrawCheckMark(rect);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawCircle(args* as any):map as void = \
		R'''
		// DrawCircle(x as Coord, y as Coord, radius as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("radius", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			wxCoord radius = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawCircle(x, y, radius);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawCircle(pt as const_Point_r, radius as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("radius", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			wxCoord radius = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawCircle(pt, radius);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawEllipse(args* as any):map as void = \
		R'''
		// DrawEllipse(x as Coord, y as Coord, width as Coord, height as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			wxCoord width = args.PickNumber<wxCoord>();
			wxCoord height = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawEllipse(x, y, width, height);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawEllipse(pt as const_Point_r, size as const_Size_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("size", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			const wxSize& size = args.Pick<Value_wxSize>().GetEntity();
			pEntity_gurax->DrawEllipse(pt, size);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawEllipse(rect as const_Rect_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("rect", VTYPE_wxRect);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxRect& rect = args.Pick<Value_wxRect>().GetEntity();
			pEntity_gurax->DrawEllipse(rect);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawEllipticArc(args* as any):map as void = \
		R'''
		// DrawEllipticArc(x as Coord, y as Coord, width as Coord, height as Coord, start as double, end as double) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
				pDeclCallable->DeclareArg("start", VTYPE_Number);
				pDeclCallable->DeclareArg("end", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			wxCoord width = args.PickNumber<wxCoord>();
			wxCoord height = args.PickNumber<wxCoord>();
			double start = args.PickNumber<double>();
			double end = args.PickNumber<double>();
			pEntity_gurax->DrawEllipticArc(x, y, width, height, start, end);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawEllipticArc(pt as const_Point_r, sz as const_Size_r, sa as double, ea as double) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("sz", VTYPE_wxSize);
				pDeclCallable->DeclareArg("sa", VTYPE_Number);
				pDeclCallable->DeclareArg("ea", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			const wxSize& sz = args.Pick<Value_wxSize>().GetEntity();
			double start = args.PickNumber<double>();
			double end = args.PickNumber<double>();
			pEntity_gurax->DrawEllipticArc(pt, sz, start, end);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawIcon(args* as any):map as void = \
		R'''
		// DrawIcon(icon as const_Icon_r, x as Coord, y as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("icon", VTYPE_wxIcon);
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxIcon& icon = args.Pick<Value_wxIcon>().GetEntity();
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawIcon(icon, x, y);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawIcon(icon as const_Icon_r, pt as const_Point_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("icon", VTYPE_wxIcon);
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxIcon& icon = args.Pick<Value_wxIcon>().GetEntity();
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			pEntity_gurax->DrawIcon(icon, pt);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	//DrawLabel(text as String, bitmap as const_Bitmap_r, rect as const_Rect_r, alignment as int = wxALIGN_LEFT | wxALIGN_TOP,  indexAccel as int = -1, rectBounding as Rect_r = nullptr) as void
	DrawLabel(text as String, rect as const_Rect_r, alignment as int = wxALIGN_LEFT | wxALIGN_TOP, indexAccel as int = -1):map as void
	DrawLine(args* as any):map as void = \
		R'''
		// DrawLine(x1 as Coord, y1 as Coord, x2 as Coord, y2 as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x1", VTYPE_Number);
				pDeclCallable->DeclareArg("y1", VTYPE_Number);
				pDeclCallable->DeclareArg("x2", VTYPE_Number);
				pDeclCallable->DeclareArg("y2", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x1 = args.PickNumber<wxCoord>();
			wxCoord y1 = args.PickNumber<wxCoord>();
			wxCoord x2 = args.PickNumber<wxCoord>();
			wxCoord y2 = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawLine(x1, y1, x2, y2);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawLine(pt1 as const_Point_r, pt2 as const_Point_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt1", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("pt2", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt1 = args.Pick<Value_wxPoint>().GetEntity();
			const wxPoint& pt2 = args.Pick<Value_wxPoint>().GetEntity();
			pEntity_gurax->DrawLine(pt1, pt2);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawLines(points as const_PointList_p, xoffset as Coord = 0, yoffset as Coord = 0):map as void
	DrawPoint(args* as any):map as void = \
		R'''
		// DrawPoint(x as Coord, y as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawPoint(x, y);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawPoint(pt as const_Point_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			pEntity_gurax->DrawPoint(pt);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawPolygon(points as const_PointList_p, xoffset as Coord = 0, yoffset as Coord = 0, fill_style as PolygonFillMode = wxODDEVEN_RULE):map as void
	//DrawPolyPolygon(int n, const int count[], const wxPoint points[], xoffset as Coord=0, yoffset as Coord=0, wxPolygonFillMode fill_style=wxODDEVEN_RULE) as void
	DrawPolyPolygon(count[] as int, points[] as any, xoffset as Coord = 0, yoffset as Coord = 0, fill_style as PolygonFillMode = wxODDEVEN_RULE):map as void = \
		R'''
		std::vector<wxPoint> points_;
		points_.reserve(points.size());
		int n = count.size();
		if (n != points.size()) {
			Error::Issue(ErrorType::RangeError, "count and points must have the same length.");
			return Value::nil();
		}
		for (const Value* pValue : points) {
			if (!pValue->IsType(VTYPE_wxPoint)) {
				Error::Issue(ErrorType::TypeError, "the element must be of wx.Point.");
				return Value::nil();
			}
			points_.push_back(Value_wxPoint::GetEntity(*pValue));
		}
		pEntity_gurax->DrawPolyPolygon(n, count.data(), points_.data(), xoffset, yoffset, fill_style);
		return Value::nil();
		'''
	DrawRectangle(args* as any):map as void = \
		R'''
		// DrawRectangle(x as Coord, y as Coord, width as Coord, height as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			wxCoord width = args.PickNumber<wxCoord>();
			wxCoord height = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawRectangle(x, y, width, height);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawRectangle(pt as const_Point_r, size as const_Size_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("size", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			const wxSize& size = args.Pick<Value_wxSize>().GetEntity();
			pEntity_gurax->DrawRectangle(pt, size);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawRectangle(rect as const_Rect_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("rect", VTYPE_wxRect);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxRect& rect = args.Pick<Value_wxRect>().GetEntity();
			pEntity_gurax->DrawRectangle(rect);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawRotatedText(args* as any):map as void = \
		R'''
		// DrawRotatedText(text as String, x as Coord, y as Coord, angle as double) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("text", VTYPE_String);
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("angle", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const char* text = args.PickString();
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			double angle = args.PickNumber<double>();
			pEntity_gurax->DrawRotatedText(text, x, y, angle);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawRotatedText(text as String, point as const_Point_r, angle as double) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("text", VTYPE_String);
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("angle", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const char* text = args.PickString();
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			double angle = args.PickNumber<double>();
			pEntity_gurax->DrawRotatedText(text, pt, angle);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawRoundedRectangle(args* as any):map as void = \
		R'''
		// DrawRoundedRectangle(x as Coord, y as Coord, width as Coord, height as Coord, radius as double) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
				pDeclCallable->DeclareArg("radius", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			wxCoord width = args.PickNumber<wxCoord>();
			wxCoord height = args.PickNumber<wxCoord>();
			double radius = args.PickNumber<double>();
			pEntity_gurax->DrawRoundedRectangle(x, y, width, height, radius);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawRoundedRectangle(pt as const_Point_r, sz as const_Size_r, radius as double) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("size", VTYPE_wxSize);
				pDeclCallable->DeclareArg("radius", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			const wxSize& size = args.Pick<Value_wxSize>().GetEntity();
			double radius = args.PickNumber<double>();
			pEntity_gurax->DrawRoundedRectangle(pt, size, radius);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawRoundedRectangle(rect as const_Rect_r, radius as double) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("rect", VTYPE_wxRect);
				pDeclCallable->DeclareArg("radius", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxRect& rect = args.Pick<Value_wxRect>().GetEntity();
			double radius = args.PickNumber<double>();
			pEntity_gurax->DrawRoundedRectangle(rect, radius);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	DrawSpline(points as const_PointList_p):map as void
	DrawSplineXY(x1 as Coord, y1 as Coord, x2 as Coord, y2 as Coord, x3 as Coord, y3 as Coord):map as void = DrawSpline
	DrawText(args* as any):map as void = \
		R'''
		// DrawText(text as String, x as Coord, y as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("text", VTYPE_String);
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const char* text = args.PickString();
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			pEntity_gurax->DrawText(text, x, y);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// DrawText(text as String, pt as const_Point_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("text", VTYPE_String);
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const char* text = args.PickString();
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			pEntity_gurax->DrawText(text, pt);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	GradientFillConcentric(rect as const_Rect_r, initialColour as const_Colour_r, destColour as const_Colour_r, circleCenter? as const_Point_p) as void = \
		R'''
		if (circleCenter) {
			pEntity_gurax->GradientFillConcentric(rect, initialColour, destColour, *circleCenter);
		} else {
			pEntity_gurax->GradientFillConcentric(rect, initialColour, destColour);
		}
		return Value::nil();
		'''
	GradientFillLinear(rect as const_Rect_r, initialColour as const_Colour_r, destColour as const_Colour_r, nDirection as Direction = wxRIGHT) as void

	FloodFill(args* as any) as void = \
		R'''
		// FloodFill(x as Coord, y as Coord, colour as const_Colour_r, style as FloodFillStyle = wxFLOOD_SURFACE) as void = FloodFill
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("colour", VTYPE_wxColour);
				pDeclCallable->DeclareArg("style", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			const wxColour& colour = args.Pick<Value_wxColour>().GetEntity();
			wxFloodFillStyle style = args.PickNumber<wxFloodFillStyle>();
			pEntity_gurax->FloodFill(x, y, colour, style);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// FloodFill(pt as const_Point_r, col as const_Colour_r, style as FloodFillStyle = wxFLOOD_SURFACE) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("colour", VTYPE_wxColour);
				pDeclCallable->DeclareArg("style", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			const wxColour& colour = args.Pick<Value_wxColour>().GetEntity();
			wxFloodFillStyle style = args.PickNumber<wxFloodFillStyle>();
			pEntity_gurax->FloodFill(pt, colour, style);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	CrossHair(args* as any) as void = \
		R'''
		// CrossHair(x as Coord, y as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			pEntity_gurax->CrossHair(x, y);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// CrossHair(pt as const_Point_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			pEntity_gurax->CrossHair(pt);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	// Clipping region functions
	DestroyClippingRegion() as void
	GetClippingBox(&x:nilRef as Coord, &y:nilRef as Coord, &width:nilRef as Coord, &height:nilRef as Coord) as void = \
		R'''
		wxCoord x_, y_, width_, height_;
		pEntity_gurax->GetClippingBox(&x_, &y_, &width_, &height_);
		x->SetValue(new Value_Number(x_));
		y->SetValue(new Value_Number(y_));
		width->SetValue(new Value_Number(width_));
		height->SetValue(new Value_Number(height_));
		return Value::nil();
		'''
	SetClippingRegion(args* as any) as void = \
		R'''
		// SetClippingRegion(x as Coord, y as Coord, width as Coord, height as Coord) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("x", VTYPE_Number);
				pDeclCallable->DeclareArg("y", VTYPE_Number);
				pDeclCallable->DeclareArg("width", VTYPE_Number);
				pDeclCallable->DeclareArg("height", VTYPE_Number);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			wxCoord x = args.PickNumber<wxCoord>();
			wxCoord y = args.PickNumber<wxCoord>();
			wxCoord width = args.PickNumber<wxCoord>();
			wxCoord height = args.PickNumber<wxCoord>();
			pEntity_gurax->SetClippingRegion(x, y, width, height);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// SetClippingRegion(pt as const_Point_r, size as const_Size_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("pt", VTYPE_wxPoint);
				pDeclCallable->DeclareArg("size", VTYPE_wxSize);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxPoint& pt = args.Pick<Value_wxPoint>().GetEntity();
			const wxSize& size = args.Pick<Value_wxSize>().GetEntity();
			pEntity_gurax->SetClippingRegion(pt, size);
			return Value::nil();
		} while (0);
		Error::ClearIssuedFlag();
		// SetClippingRegion(rect as const_Rect_r) as void
		do {
			static DeclCallable* pDeclCallable = nullptr;
			if (!pDeclCallable) {
				pDeclCallable = new DeclCallable();
				pDeclCallable->DeclareArg("rect", VTYPE_wxRect);
			}
			RefPtr<Argument> pArgument(new Argument(processor_gurax, pDeclCallable->Reference()));
			if (!pArgument->FeedValuesAndComplete(processor_gurax, args)) break;
			Error::Clear();
			ArgPicker args(*pArgument);
			const wxRect& rect = args.Pick<Value_wxRect>().GetEntity();
			pEntity_gurax->SetClippingRegion(rect);
			return Value::nil();
		} while (0);
		return Value::nil();
		'''
	SetDeviceClippingRegion(region as const_Region_r) as void
	// Text/character extent functions
	GetCharHeight() as Coord
	GetCharWidth() as Coord
	GetFontMetrics() as FontMetrics
	//GetMultiLineTextExtent(string as String, wxCoord *w, wxCoord *h, wxCoord *heightLine=NULL, const wxFont *font=NULL) as void
	GetMultiLineTextExtentWH(string as String, &w:nilRef as Coord, &h:nilRef as Coord, &heightLine?:nilRef as Coord, font? as const_Font_p) as void = \
		R'''
		wxCoord w_, h_, heightLine_;
		pEntity_gurax->GetMultiLineTextExtent(string, &w_, &h_, &heightLine_, font);
		w->SetValue(new Value_Number(w_));
		h->SetValue(new Value_Number(h_));
		if (heightLine) heightLine->SetValue(new Value_Number(heightLine_));
		return Value::nil();
		'''
	GetMultiLineTextExtent(string as String) as Size
	//GetPartialTextExtents(text as String, wxArrayInt &widths) as bool
	//GetTextExtent(const wxString &string, wxCoord *w, wxCoord *h, wxCoord *descent=NULL, wxCoord *externalLeading=NULL, const wxFont *font=NULL) as void
	GetTextExtentWH(string as const_String_r, &w:nilRef as Coord, &h:nilRef as Coord, &descent?:nilRef as Coord, &externalLeading?:nilRef as Coord, font? as const_Font_p) as void = \
		R'''
		wxCoord w_, h_, descent_, externalLeading_;
		pEntity_gurax->GetTextExtent(string, &w_, &h_, &descent_, &externalLeading_, font);
		w->SetValue(new Value_Number(w_));
		h->SetValue(new Value_Number(h_));
		if (descent) descent->SetValue(new Value_Number(descent_));
		if (externalLeading) externalLeading->SetValue(new Value_Number(externalLeading_));
		return Value::nil();
		'''
	GetTextExtent(string as String) as Size
	// Text properties functions
	GetBackgroundMode() as int
	GetFont() as Font
	GetLayoutDirection() as LayoutDirection
	GetTextBackground() as Colour
	GetTextForeground() as Colour
	SetBackgroundMode(mode as int) as void
	SetFont(font as const_Font_r) as void
	SetTextBackground(colour as const_Colour_r) as void
	SetTextForeground(colour as const_Colour_r) as void
	SetLayoutDirection(dir as LayoutDirection) as void
	// Bounding box functions
	CalcBoundingBox(x as Coord, y as Coord) as void
	MaxX() as Coord
	MaxY() as Coord
	MinX() as Coord
	MinY() as Coord
	ResetBoundingBox() as void
	// Page and document start/end functions
	StartDoc(message as const_String_r) as bool
	StartPage() as void
	EndDoc() as void
	EndPage() as void
	// Bit-Block Transfer operations (blit)
	Blit(xdest as Coord, ydest as Coord, width as Coord, height as Coord, source as DC_p, xsrc as Coord, ysrc as Coord, logicalFunc as RasterOperationMode = wxCOPY, useMask as bool = false, xsrcMask as Coord = wxDefaultCoord, ysrcMask as Coord = wxDefaultCoord) as bool
	StretchBlit(xdest as Coord, ydest as Coord, dstWidth as Coord, dstHeight as Coord, source as DC_p, xsrc as Coord, ysrc as Coord, srcWidth as Coord, srcHeight as Coord, logicalFunc as RasterOperationMode = wxCOPY, useMask as bool = false, xsrcMask as Coord = wxDefaultCoord, ysrcMask as Coord = wxDefaultCoord) as bool
	// Background/foreground brush and pen
	GetBackground() as Brush
	GetBrush() as Brush
	GetPen() as Pen
	SetBackground(brush as const_Brush_r) as void
	SetBrush(brush as const_Brush_r) as void
	SetPen(pen as const_Pen_r) as void
	// Transformation matrix
	CanUseTransformMatrix() as bool
	SetTransformMatrix(matrix as const_AffineMatrix2D_r) as bool
	GetTransformMatrix() as AffineMatrix2D
	ResetTransformMatrix() as void
	// query capabilities
	CanDrawBitmap() as bool
	CanGetTextExtent() as bool
	GetLogicalOriginXY(&x:nilRef as Coord, &y:nilRef as Coord) as void = \
		R'''
		wxCoord x_, y_;
		pEntity_gurax->GetLogicalOrigin(&x_, &y_);
		x->SetValue(new Value_Number(x_));
		y->SetValue(new Value_Number(y_));
		return Value::nil();
		'''
	GetLogicalOrigin() as Point
} %% R'''
# Overview

# Predefined Variable

${help.ComposePropertyHelp(wx.DC, `en)}

# Operator

# Cast Operation

${help.ComposeConstructorHelp(wx.DC, `en)}

${help.ComposeMethodHelp(wx.DC, `en)}
''' %% R'''
# 概要

# 定数

${help.ComposePropertyHelp(wx.DC, `ja)}

# オペレータ

# キャスト

${help.ComposeConstructorHelp(wx.DC, `ja)}

${help.ComposeMethodHelp(wx.DC, `ja)}
'''ja
