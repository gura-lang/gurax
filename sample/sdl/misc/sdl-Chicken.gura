#!/usr/bin/env gurax
import(sdl) {*}
import(jpeg)
import(gif)

I(fileName as String) = path.Join('../../resource', fileName)

Chicken = struct {
	x as Number
	y as Number
	wd as Number
	dir:nil as Symbol
	texturesL as Iterator
	texturesR as Iterator
	Render(renderer as SDL_Renderer):void = {
		texture = cond(this.dir == `left, this.texturesL, this.texturesR).NextValue()
		ht = texture.ht * this.wd / texture.wd
		SDL_RenderCopy(renderer, texture.entity, nil, SDL_Rect(this.x, this.y - ht, this.wd, ht))
	}
	Move(wdScreen as Number):void = {
		xStep = this.wd * .2
		this.x += cond(this.dir == `left, -xStep, xStep)
		if (this.x + this.wd > wdScreen) {
			this.dir = `left
		} elsif (this.x <= 0) {
			this.dir = `right
		}
	}
}

Texture = class {
	entity as SDL_Texture
	wd as Number
	ht as Number
	__init__(renderer as SDL_Renderer, surface as SDL_Surface):map = {
		this.entity = SDL_CreateTextureFromSurface(renderer, surface)
		this.wd = surface.w
		this.ht = surface.h
		SDL_FreeSurface(surface)
	}
}

AddChicken(x as Number, y as Number, wd as Number, dir as Symbol) = {
	chickens.Add(Chicken(x, y, wd, dir, texturesChickenL.Cycle(), texturesChickenR.Cycle()))
}

SDL_Init(SDL_INIT_EVERYTHING)
[wdScreen, htScreen] = [800, 600]
window = SDL_CreateWindow(path.FileName(sys.argv[0]), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, wdScreen, htScreen, 0)
renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC)
textureBg = Texture(renderer, Image(I('seashore.jpg')))
imgs = gif.Content(I('chicken-anim.gif')):*EachImage():list
texturesChickenL = Texture(renderer, imgs):list
texturesChickenR = Texture(renderer, imgs:*Flip(`horz)):list
chickens = []
AddChicken(10, 100, 80, `left)
timePrev = SDL_GetTicks()
event = SDL_Event()
repeat {
	timeCur = SDL_GetTicks()
	if (timePrev > timeCur || timeCur > timePrev + 100) {
		SDL_RenderCopy(renderer, textureBg.entity, nil, nil)
		chickens:*Render(renderer)
		chickens:*Move(wdScreen)
		SDL_RenderPresent(renderer)
		timePrev = timeCur
	}
	rtn = SDL_WaitEventTimeout(event, 10) // 10msec
	if (rtn == 0) {
		// nothing to do
	} elsif (event.type == SDL_QUIT) {
		break
	} elsif (event.type == SDL_KEYDOWN) {
		(event.key.keysym.sym == SDLK_ESCAPE) && break
	} elsif (event.type == SDL_MOUSEBUTTONDOWN) {
		timeButtonDown = timeCur
	} elsif (event.type == SDL_MOUSEBUTTONUP) {
		dir = `right
		wd = Min((timeCur - timeButtonDown) / 10 + 40, 200)
		AddChicken(event.button.x, event.button.y, wd, dir)
	}
}
SDL_DestroyRenderer(renderer)
SDL_DestroyWindow(window)
SDL_Quit()
