#!/usr/bin/env gurax
import(opengl) {*}
import(glu) {*}

samples = []

SampleBase = class {
	Init() = nil
	Reshape(width as Number, height as Number) = nil
	Display() = nil
	Track(x as Number, y as Number) = nil
	TrackEnd(x as Number, y as Number) = nil
}

S_NUMPOINTS = 13
S_ORDER     = 3   
S_NUMKNOTS  = (S_NUMPOINTS + S_ORDER)
T_NUMPOINTS = 3
T_ORDER     = 3
T_NUMKNOTS  = (T_NUMPOINTS + T_ORDER)
SQRT_TWO    = 1.41421356237309504880

Sample_nurb = class(SampleBase) {
	name = 'Nurb'
	rotX = 0
	rotY = 0
	SQRT_TWO:static    = 1.41421356237309504880
	sknots = @{
		-1.0, -1.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0,
		4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 9.0, 9.0
	}
	glutnots = @{
		1.0, 1.0, 1.0, 2.0, 2.0, 2.0
	}
	ctlpoints = @{
		{
			{ 4.0, 2.0, 2.0, 1.0 }
			{ 4.0, 1.6, 2.5, 1.0 }
			{ 4.0, 2.0, 3.0, 1.0 }
		}, {
			{ 5.0, 4.0, 2.0, 1.0 }
			{ 5.0, 4.0, 2.5, 1.0 }
			{ 5.0, 4.0, 3.0, 1.0 }
		}, {
			{ 6.0, 5.0, 2.0, 1.0 }
			{ 6.0, 5.0, 2.5, 1.0 }
			{ 6.0, 5.0, 3.0, 1.0 }
		}, {
			{ SQRT_TWO*6.0, SQRT_TWO*6.0, SQRT_TWO*2.0, SQRT_TWO }
			{ SQRT_TWO*6.0, SQRT_TWO*6.0, SQRT_TWO*2.5, SQRT_TWO }
			{ SQRT_TWO*6.0, SQRT_TWO*6.0, SQRT_TWO*3.0, SQRT_TWO }  
		}, {
			{ 5.2, 6.7, 2.0, 1.0 }
			{ 5.2, 6.7, 2.5, 1.0 }
			{ 5.2, 6.7, 3.0, 1.0 }
		}, {
			{ SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*2.0, SQRT_TWO }
			{ SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*2.5, SQRT_TWO } 
			{ SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*3.0, SQRT_TWO }  
		}, {
			{ 4.0, 5.2, 2.0, 1.0 }
			{ 4.0, 4.6, 2.5, 1.0 }
			{ 4.0, 5.2, 3.0, 1.0 }  
		}, {
			{ SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*2.0, SQRT_TWO }
			{ SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*2.5, SQRT_TWO }
			{ SQRT_TWO*4.0, SQRT_TWO*6.0, SQRT_TWO*3.0, SQRT_TWO }  
		}, {
			{ 2.8, 6.7, 2.0, 1.0 }
			{ 2.8, 6.7, 2.5, 1.0 }
			{ 2.8, 6.7, 3.0, 1.0 }   
		}, {
			{ SQRT_TWO*2.0, SQRT_TWO*6.0, SQRT_TWO*2.0, SQRT_TWO }
			{ SQRT_TWO*2.0, SQRT_TWO*6.0, SQRT_TWO*2.5, SQRT_TWO }
			{ SQRT_TWO*2.0, SQRT_TWO*6.0, SQRT_TWO*3.0, SQRT_TWO }  
		}, {
			{ 2.0, 5.0, 2.0, 1.0 }
			{ 2.0, 5.0, 2.5, 1.0 }
			{ 2.0, 5.0, 3.0, 1.0 } 
		}, {
			{ 3.0, 4.0, 2.0, 1.0 }
			{ 3.0, 4.0, 2.5, 1.0 }
			{ 3.0, 4.0, 3.0, 1.0 } 
		}, {
			{ 4.0, 2.0, 2.0, 1.0 }
			{ 4.0, 1.6, 2.5, 1.0 }
			{ 4.0, 2.0, 3.0, 1.0 }	
		}
	}
	theNurbs as GLUnurbs
	Init() = {
		this.theNurbs = gluNewNurbsRenderer()
		//gluNurbsCallback(this.theNurbs, GLU_ERROR, ErrorCallback)
		gluNurbsProperty(this.theNurbs, GLU_SAMPLING_TOLERANCE, 15.0)
		gluNurbsProperty(this.theNurbs, GLU_DISPLAY_MODE, GLU_OUTLINE_PATCH)
		expectedError = GLU_INVALID_ENUM
		gluNurbsProperty(this.theNurbs, ~0, 15.0)
		expectedError = GLU_NURBS_ERROR13
		gluEndSurface(this.theNurbs)
		expectedError = 0
		glColor3f(1.0, 1.0, 1.0)
	}
	Reshape(width as Number, height as Number) = {
		glViewport(0, 0, width, height)
		glMatrixMode(GL_PROJECTION)
		glLoadIdentity()
		glFrustum(-2.0, 2.0, -2.0, 2.0, 0.8, 10.0)
		gluLookAt(7.0, 4.5, 4.0, 4.5, 4.5, 2.5, 6.0, -3.0, 2.0)
		glMatrixMode(GL_MODELVIEW)
	}
	Display() = {
		glClear(GL_COLOR_BUFFER_BIT)
		glPushMatrix()
			glTranslatef(4.0, 4.5, 2.5)
			glRotatef(this.rotY, 1, 0, 0)
			glRotatef(this.rotX, 0, 1, 0)
			glTranslatef(-4.0, -4.5, -2.5)
			gluBeginSurface(this.theNurbs)
				gluNurbsSurface(this.theNurbs, this.sknots, this.glutnots, 4 * T_NUMPOINTS, 4,
						this.ctlpoints.Flatten():list, S_ORDER, T_ORDER, GL_MAP2_VERTEX_4)
			gluEndSurface(this.theNurbs)
		glPopMatrix()
		glFlush()
	}
	Track(x as Number, y as Number) = {
		this.rotX = x
		this.rotY = y
		true
	}
}
samples.Add(Sample_nurb())

Sample_teapot = class(SampleBase) {
	name = 'Teapot'
	listTeapot as Number
	rotX = 0
	rotY = 0
	Teapot(grid as Number) = {
		patchData = @(@float) {
			[102,103,104,105, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
			[12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]
			[24, 25, 26, 27, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]
			[96, 96, 96, 96, 97, 98, 99, 100, 101, 101, 101, 101, 0, 1, 2, 3]
			[0, 1, 2, 3, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117]
			[118, 118, 118, 118, 124, 122, 119, 121, 123, 126, 125, 120, 40, 39, 38, 37]
			[41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56]
			[53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 28, 65, 66, 67]
			[68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83]
			[80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]
		}
		cpData = @(@float) {
			[0.2, 0, 2.7], [0.2, -0.112, 2.7], [0.112, -0.2, 2.7], [0, -0.2, 2.7],
			[1.3375, 0, 2.53125], [1.3375, -0.749, 2.53125], [0.749, -1.3375, 2.53125],
			[0, -1.3375, 2.53125], [1.4375, 0, 2.53125], [1.4375, -0.805, 2.53125],
			[0.805, -1.4375, 2.53125], [0, -1.4375, 2.53125], [1.5, 0, 2.4], [1.5, -0.84, 2.4],
			[0.84, -1.5, 2.4], [0, -1.5, 2.4], [1.75, 0, 1.875], [1.75, -0.98, 1.875],
			[0.98, -1.75, 1.875], [0, -1.75, 1.875], [2, 0, 1.35], [2, -1.12, 1.35],
			[1.12, -2, 1.35], [0, -2, 1.35], [2, 0, 0.9], [2, -1.12, 0.9], [1.12, -2, 0.9],
			[0, -2, 0.9], [-2, 0, 0.9], [2, 0, 0.45], [2, -1.12, 0.45], [1.12, -2, 0.45],
			[0, -2, 0.45], [1.5, 0, 0.225], [1.5, -0.84, 0.225], [0.84, -1.5, 0.225],
			[0, -1.5, 0.225], [1.5, 0, 0.15], [1.5, -0.84, 0.15], [0.84, -1.5, 0.15],
			[0, -1.5, 0.15], [-1.6, 0, 2.025], [-1.6, -0.3, 2.025], [-1.5, -0.3, 2.25],
			[-1.5, 0, 2.25], [-2.3, 0, 2.025], [-2.3, -0.3, 2.025], [-2.5, -0.3, 2.25],
			[-2.5, 0, 2.25], [-2.7, 0, 2.025], [-2.7, -0.3, 2.025], [-3, -0.3, 2.25],
			[-3, 0, 2.25], [-2.7, 0, 1.8], [-2.7, -0.3, 1.8], [-3, -0.3, 1.8], [-3, 0, 1.8],
			[-2.7, 0, 1.575], [-2.7, -0.3, 1.575], [-3, -0.3, 1.35], [-3, 0, 1.35],
			[-2.5, 0, 1.125], [-2.5, -0.3, 1.125], [-2.65, -0.3, 0.9375], [-2.65, 0, 0.9375],
			[-2, -0.3, 0.9], [-1.9, -0.3, 0.6], [-1.9, 0, 0.6], [1.7, 0, 1.425],
			[1.7, -0.66, 1.425], [1.7, -0.66, 0.6], [1.7, 0, 0.6], [2.6, 0, 1.425],
			[2.6, -0.66, 1.425], [3.1, -0.66, 0.825], [3.1, 0, 0.825], [2.3, 0, 2.1],
			[2.3, -0.25, 2.1], [2.4, -0.25, 2.025], [2.4, 0, 2.025], [2.7, 0, 2.4],
			[2.7, -0.25, 2.4], [3.3, -0.25, 2.4], [3.3, 0, 2.4], [2.8, 0, 2.475],
			[2.8, -0.25, 2.475], [3.525, -0.25, 2.49375], [3.525, 0, 2.49375],
			[2.9, 0, 2.475], [2.9, -0.15, 2.475], [3.45, -0.15, 2.5125], [3.45, 0, 2.5125],
			[2.8, 0, 2.4], [2.8, -0.15, 2.4], [3.2, -0.15, 2.4], [3.2, 0, 2.4], [0, 0, 3.15],
			[0.8, 0, 3.15], [0.8, -0.45, 3.15], [0.45, -0.8, 3.15], [0, -0.8, 3.15],
			[0, 0, 2.85], [1.4, 0, 2.4], [1.4, -0.784, 2.4], [0.784, -1.4, 2.4], [0, -1.4, 2.4],
			[0.4, 0, 2.55], [0.4, -0.224, 2.55], [0.224, -0.4, 2.55], [0, -0.4, 2.55],
			[1.3, 0, 2.55], [1.3, -0.728, 2.55], [0.728, -1.3, 2.55], [0, -1.3, 2.55],
			[1.3, 0, 2.4], [1.3, -0.728, 2.4], [0.728, -1.3, 2.4], [0, -1.3, 2.4], [0, 0, 0],
			[1.425, -0.798, 0], [1.5, 0, 0.075], [1.425, 0, 0], [0.798, -1.425, 0],
			[0, -1.5, 0.075], [0, -1.425, 0], [1.5, -0.84, 0.075], [0.84, -1.5, 0.075],
		}
		this.listTeapot = 1
		[p, q, r, s] = repeat(4):list { Dim(4, 4, 3) {0} }
		this.listTeapot = 1
		glNewList(this.listTeapot, GL_COMPILE)
		glPushMatrix()
		glRotatef(270.0, 1.0, 0.0, 0.0)
		repeat(10) {|i|
			repeat(4) {|j|
				repeat(4) {|k|
					repeat(3) {|l|
						p[j][k][l] = cpData[patchData[i][j * 4 + k]][l]
						q[j][k][l] = cpData[patchData[i][j * 4 + (3 - k)]][l]
						if (l == 1) {
							q[j][k][l] *= -1.0
						}
						if (i < 6) {
							r[j][k][l] = cpData[patchData[i][j * 4 + (3 - k)]][l]
							if (l == 0) {
								r[j][k][l] *= -1.0
							}
							s[j][k][l] = cpData[patchData[i][j * 4 + k]][l]
							if (l == 0) {
								s[j][k][l] *= -1.0
							}
							if (l == 1) {
								s[j][k][l] *= -1.0
							}
						}
					}
				}
			}
			glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, @float(p.Flatten():list))
			glEnable(GL_MAP2_VERTEX_3)
			glMapGrid2f(grid, 0.0, 1.0, grid, 0.0, 1.0)
			glEvalMesh2(GL_FILL, 0, grid, 0, grid)
			glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, @float(q.Flatten():list))
			glEvalMesh2(GL_FILL, 0, grid, 0, grid)
			if (i < 6) {
				glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, @float(r.Flatten():list))
				glEvalMesh2(GL_FILL, 0, grid, 0, grid)
				glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, @float(s.Flatten():list))
				glEvalMesh2(GL_FILL, 0, grid, 0, grid)
			}
		}
		glDisable(GL_MAP2_VERTEX_3)
		glPopMatrix()
		glEndList()
	}
	Init() = {
		position = @float([0.0, 3.0, 3.0, 0.0])
		local_view = @float([0.0])
		ambient = @float([0.1745, 0.01175, 0.01175, 0])
		diffuse = @float([0.61424, 0.04136, 0.04136, 0])
		specular = @float([0.727811, 0.626959, 0.626959, 0])
		glEnable(GL_DEPTH_TEST)
		glDepthFunc(GL_LESS)
		glLightfv(GL_LIGHT0, GL_POSITION, position)
		glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view)
		glFrontFace(GL_CW)
		glEnable(GL_LIGHTING)
		glEnable(GL_LIGHT0)
		glEnable(GL_AUTO_NORMAL)
		glEnable(GL_NORMALIZE)
		glMaterialfv(GL_FRONT, GL_AMBIENT, ambient)
		glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse)
		glMaterialfv(GL_FRONT, GL_SPECULAR, specular)
		glMaterialf(GL_FRONT, GL_SHININESS, 0.6 * 128.0)
		glClearColor(0.5, 0.5, 0.5, 1.0)
		glColor3f(1.0, 1.0, 1.0)
		this.Teapot(14)
	}
	Reshape(w as Number, h as Number) = {
		glViewport(0, 0, w, h)
		glMatrixMode(GL_PROJECTION)
		glLoadIdentity()
		glOrtho(-6.0, 6.0, -6.0, 6.0, -1.0, 10.0)
		glMatrixMode(GL_MODELVIEW)
		glLoadIdentity()
	}
	Display() = {
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
		glPushMatrix()
			glTranslatef(0.0, 0.0, -5.0)
			glRotatef(this.rotX, 0.0, 1.0, 0.0)
			glRotatef(this.rotY, 1.0, 0.0, 0.0)
			glCallList(this.listTeapot)
		glPopMatrix()
		glFlush()
	}
	Track(x as Number, y as Number) = {
		this.rotX = x
		this.rotY = y
		true
	}
}
samples.Add(Sample_teapot())

Sample_cube = class(SampleBase) {
	name = "Cube"
	rotX = 0
	rotY = 0
	vertex = @(@double) {
		[-0.5, -0.5, -0.5], [0.5, -0.5, -0.5], [0.5, 0.5, -0.5], [-0.5, 0.5, -0.5]
		[-0.5, -0.5, 0.5], [0.5, -0.5, 0.5], [0.5, 0.5, 0.5], [-0.5, 0.5, 0.5]
	}
	Init() = {
		glEnable(GL_DEPTH_TEST)
		glEnable(GL_CULL_FACE)
		glEnable(GL_LIGHTING)
		glEnable(GL_LIGHT0)
		glEnable(GL_LIGHT1)
		glCullFace(GL_FRONT)
	}
	Reshape(width as Number, height as Number) = {
		glViewport(0, 0, width, height)
		glMatrixMode(GL_PROJECTION)
		glLoadIdentity()
		gluPerspective(30, width / height, 1, 100)
	}
	Display() = {
		glClearColor(1, 1, 1, 1)
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
		glMatrixMode(GL_MODELVIEW)
		glLoadIdentity()
		//gluLookAt(3, 4, 5, 0, 0, 0, 0, 1, 0)
		glTranslatef(0.0, 0.0, -4.0)
		glRotated(this.rotX, 0, 1, 0)
		glRotated(this.rotY, 1, 0, 0)
		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, @float([0.8, 0.2, 0.2, 1]))
		glBegin(GL_QUADS)
			glNormal3dv(@double([ 0,  0, -1])), this.vertex[0, 1, 2, 3].Each {|v| glVertex3dv(v)}
			glNormal3dv(@double([ 1,  0,  0])), this.vertex[1, 5, 6, 2].Each {|v| glVertex3dv(v)}
			glNormal3dv(@double([ 0,  0,  1])), this.vertex[5, 4, 7, 6].Each {|v| glVertex3dv(v)}
			glNormal3dv(@double([-1,  0,  0])), this.vertex[4, 0, 3, 7].Each {|v| glVertex3dv(v)}
			glNormal3dv(@double([ 0, -1,  0])), this.vertex[4, 5, 1, 0].Each {|v| glVertex3dv(v)}
			glNormal3dv(@double([ 0,  1,  0])), this.vertex[3, 2, 6, 7].Each {|v| glVertex3dv(v)}
		glEnd()
		glFlush()
	}
	Track(x as Number, y as Number) = {
		this.rotX = x
		this.rotY = y
		this
	}
}
samples.Add(Sample_cube())

Sample_triangle = class(SampleBase) {
	name = "Triangle"
	Init() = {}
	Reshape(width as Number, height as Number) = {}
	Display() = {
		glClearColor(0.3, 0.4, 0.6, 1.0)
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
		glBegin(GL_POLYGON)
			glColor3f(1, 0, 0); glVertex3f(-0.6, -0.75, 0.5)
			glColor3f(0, 1, 0); glVertex3f(0.6, -0.75, 0)
			glColor3f(0, 0, 1); glVertex3f(0, 0.75, 0)
		glEnd()
		glFlush()
	}
}
samples.Add(Sample_triangle())

Sample_tetrahedron = class(SampleBase) {
	name = "Tetrahedron"
	rotX = 0
	rotY = 0
	Init() = {
		// Set the current clear color to sky blue and the current drawing color to
		// white.
		glClearColor(0.1, 0.39, 0.88, 1.0);
		glColor3f(1.0, 1.0, 1.0);

		// Tell the rendering engine not to draw backfaces.  Without this code,
		// all four faces of the tetrahedron would be drawn and it is possible
		// that faces farther away could be drawn after nearer to the viewer.
		// Since there is only one closed polyhedron in the whole scene,
		// eliminating the drawing of backfaces gives us the realism we need.
		// THIS DOES NOT WORK IN GENERAL.
		glEnable(GL_CULL_FACE);
		glCullFace(GL_BACK);

		// Set the camera lens so that we have a perspective viewing volume whose
		// horizontal bounds at the near clipping plane are -2..2 and vertical
		// bounds are -1.5..1.5.  The near clipping plane is 1 unit from the camera
		// and the far clipping plane is 40 units away.
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glFrustum(-2, 2, -1.5, 1.5, 1, 40);

		// Set up transforms so that the tetrahedron which is defined right at
		// the origin will be rotated and moved into the view volume.  First we
		// rotate 70 degrees around y so we can see a lot of the left side.
		// Then we rotate 50 degrees around x to "drop" the top of the pyramid
		// down a bit.  Then we move the object back 3 units "into the screen".
		glMatrixMode(GL_MODELVIEW);
	}
	Reshape(width as Number, height as Number) = {
	}
	Display() = {
		glLoadIdentity();
		glTranslatef(0, 0, -4.5);
		glRotatef(this.rotX, 0, 1, 0);
		glRotatef(this.rotY, 1, 0, 0);
		glClear(GL_COLOR_BUFFER_BIT);

		// Draw a white grid "floor" for the tetrahedron to sit on.
		glColor3f(1.0, 1.0, 1.0);
		glBegin(GL_LINES);
		i = -2.5
		while (i <= 2.5) {
			glVertex3f(i, 0, 2.5); glVertex3f(i, 0, -2.5);
			glVertex3f(2.5, 0, i); glVertex3f(-2.5, 0, i);
			i += 0.25
		}
		glEnd();

		// Draw the tetrahedron.  It is a four sided figure, so when defining it
		// with a triangle strip we have to repeat the last two vertices.
		glBegin(GL_TRIANGLE_STRIP);
			glColor3f(1, 1, 1); glVertex3f(0, 2, 0);
			glColor3f(1, 0, 0); glVertex3f(-1, 0, 1);
			glColor3f(0, 1, 0); glVertex3f(1, 0, 1);
			glColor3f(0, 0, 1); glVertex3f(0, 0, -1.4);
			glColor3f(1, 1, 1); glVertex3f(0, 2, 0);
			glColor3f(1, 0, 0); glVertex3f(-1, 0, 1);
		glEnd();

		glFlush();
	}
	Track(x as Number, y as Number) = {
		this.rotX = x
		this.rotY = y
		this
	}
}
samples.Add(Sample_tetrahedron())
