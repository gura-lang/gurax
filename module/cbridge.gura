#!/usr/bin/env gurax

//------------------------------------------------------------------------------
// ErrorDone
//------------------------------------------------------------------------------
ErrorDone(expr as Expr, msg as String) = {
	sys.cerr.Printf('%s:%d: %s\n', expr.pathNameSrc, expr.lineNoTop, msg)
	sys.Exit(1)
}

//------------------------------------------------------------------------------
// TypeInfo
//------------------------------------------------------------------------------
TypeInfo = class {
	decl as String
	cType as String
	cTypeElem as String
	vtypeFullName as String
	moduleName as String = ''
	vtype as String = ''
	tmplPicker as Template
	tmplPickerValidation as Template
	tmplPickerListVar as Template
	tmplFunctionBody as Template
	tmplArgRef as Template
	__init__(decl as String, cType as String, vtypeFullName as String,
			codePicker as String, codePickerValidation as String,
			codePickerVec as String, codeFunctionBody as String, codeArgRef as String) = {
		this.decl = decl, this.cType = cType
		this.cTypeElem = cType.Sub(r'(const\s+)?(\w+).*', r'\2')
		this.vtypeFullName = vtypeFullName
		fields = vtypeFullName.Split('.'):list
		if (!fields.IsEmpty()) {
			this.moduleName = fields.Head(fields.len - 1).Join('.')
			this.vtype = fields.last
		}
		this.tmplPicker = Template().Parse(codePicker)
		this.tmplPickerValidation = Template().Parse(codePickerValidation)
		this.tmplPickerListVar = Template().Parse(codePickerVec)
		this.tmplFunctionBody = Template().Parse(codeFunctionBody)
		this.tmplArgRef = Template().Parse(codeArgRef)
	}
	ComposePicker(varName as String, listVarFlag as Bool, validationFlag as Bool) = {
		cond(listVarFlag, this.tmplPickerListVar, cond(validationFlag, this.tmplPickerValidation, this.tmplPicker)).Eval()
	}
	ComposeFunctionBody(caller as String) = this.tmplFunctionBody.Eval()
	ComposeArgRef(varName as String) = this.tmplArgRef.Eval()
}

//------------------------------------------------------------------------------
// ArgInfo
//------------------------------------------------------------------------------
ArgInfo = class {
	name as String
	typeName as String
	listVarFlag as Bool
	optionFlag as Bool
	nilFlag as Bool
	streamWFlag as Bool
	streamRFlag as Bool
	typeInfo as TypeInfo
	tmplDeclaration:static as Template
	tmplRangeCheck:static as Template
	__init__(r as Renderer, name as String, typeName:nil as String, attr as Attribute, listVarFlag as Bool, optionFlag as Bool) = {
		this.name = name
		this.typeName = typeName
		this.listVarFlag = listVarFlag
		this.optionFlag = optionFlag
		this.nilFlag = attr.IsSet(`nil)
		this.streamWFlag = attr.IsSet(`w)
		this.streamRFlag = attr.IsSet(`r)
		this.typeInfo = r.typeInfoMap[this.typeName]
	}
	ComposeDeclaration() = {
		strArgOccur = 'ArgOccur::' + cond(this.optionFlag, 'ZeroOrOnce', 'Once')
		argFlags = []
		this.listVarFlag && argFlags.Add('ListVar')
		this.nilFlag && argFlags.Add('Nil')
		this.streamWFlag && argFlags.Add('StreamW')
		this.streamRFlag && argFlags.Add('StreamR')
		argFlags.IsEmpty() && argFlags.Add('None')
		strArgFlags = ('ArgFlag::' + argFlags).Join(' | ')
		this.tmplDeclaration.Eval()
	}
	ComposeImplementation() = {
		str = this.typeInfo.ComposePicker(this.name, this.listVarFlag, this.optionFlag || this.nilFlag)
		str
	}
	ComposeArgRef() = this.typeInfo.ComposeArgRef(this.name)
	ToString() = Format('%s%s%s:%s%s%s%s', this.name, cond(this.listVarFlag, '[]', ''),
			cond(this.optionFlag, '?', ''), this.typeInfo.vtypeFullName,
			cond(this.nilFlag, ':nil', ''),
			cond(this.streamWFlag, ':w', ''),
			cond(this.streamRFlag, ':r', ''))
}

ArgInfo.tmplDeclaration = tR'''
DeclareArg("${this.name}", VTYPE_${this.typeInfo.vtype}, ${strArgOccur}, ${strArgFlags});
'''

ArgInfo.tmplRangeCheck = tR'''
if (${this.name}.size() != 3) {
	return Gurax::Value::nil();
}
'''

//------------------------------------------------------------------------------
// FuncInfo
//------------------------------------------------------------------------------
FuncInfo = class {
	moduleName as String
	name as String
	typeName as String
	typeInfo as TypeInfo
	argInfoTbl[] as ArgInfo = []
	tmplFunctionBody as Template
	tmplImplementation:static as Template
	tmplAssignment:static as Template
	ComposeImplementation() = this.tmplImplementation.Eval()
	ComposeAssignment() = this.tmplAssignment.Eval()
	__init__(r as Renderer, moduleName as String, name as String, typeName as String, codeFunctionBody:nil as String) = {
		if (typeName.IsEmpty()) { typeName = 'any' }
		this.moduleName = moduleName, this.name = name, this.typeName = typeName
		this.typeInfo = r.typeInfoMap[typeName]
		if (codeFunctionBody) { this.tmplFunctionBody = Template().Parse(codeFunctionBody) }
	}
	ComposeCaller() = {
		Format('%s(%s)', this.name, this.argInfoTbl:*ComposeArgRef().Join(', ')) 
	}
	ToString() = Format('%s.%s(%s)', this.moduleName, this.name, this.argInfoTbl:*ToString().Join(', '))
}

FuncInfo.tmplImplementation = tR'''
// ${this.ToString()}
Gurax_DeclareFunctionAlias(${this.name}_gurax, "${this.name}")
{
	Declare(VTYPE_${this.typeInfo.vtype}, Flag::None);
	${this.argInfoTbl::ComposeDeclaration()}
	AddHelp(
		Gurax_Symbol(en),
		"");
}

Gurax_ImplementFunctionEx(${this.name}_gurax, processor_gurax, argument_gurax)
{
	${if (!this.argInfoTbl.IsEmpty())}
	// Arguments
	Gurax::ArgPicker args_gurax(argument_gurax);
	${this.argInfoTbl::ComposeImplementation()}
	${end}
	// Function body
	${if (this.tmplFunctionBody)}
	${this.tmplFunctionBody.Eval()}
	${else}
	${this.typeInfo.ComposeFunctionBody(this.ComposeCaller())}
	${end}
}
'''

FuncInfo.tmplAssignment = t'Assign(Gurax_CreateFunction(${this.name}_gurax));'

//------------------------------------------------------------------------------
// Renderer
//------------------------------------------------------------------------------
Renderer = class {
	funcInfoTbl = []
	typeInfoMap = %{}
	DeclareType(decl as String, cType as String, vtypeFullName as String,
			codePicker as String = '', codePickerValidation as String = '',
			codePickerVec as String = '', codeFunctionBody as String = '', codeArgRef = '${varName}') = {
		this.typeInfoMap[decl] = TypeInfo(decl, cType, vtypeFullName,
				codePicker, codePickerValidation, codePickerVec, codeFunctionBody, codeArgRef)
	}
	DeclareType_Number(decl as String, cType? as String) = this.DeclareType(decl, cType || decl, 'Number',
		codePicker = R'''
		${this.cType} ${varName} = args_gurax.PickNumber<${this.cType}>();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickNumber<${this.cType}>() : 0;
		'''
		codePickerVec = R'''
		auto ${varName} = args_gurax.PickNumList<${this.cType}>();
		'''
		codeFunctionBody = R'''
		${this.cType} rtn = ${caller};
		return new Gurax::Value_${this.vtype}(rtn);
		''')
	DeclareType_Pointer(decl as String, cType as String) = this.DeclareType(decl, cType, 'Pointer',
		codePicker = R'''
		${this.cType} ${varName} = args_gurax.Pick<Gurax::Value_Pointer>().GetPointer().GetPointerC<${this.cTypeElem}>();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Gurax::Value_Pointer>().GetPointer().GetPointerC<${this.cTypeElem}>() : nullptr;
		'''
		codePickerVec = R'''
		auto ${varName} = args_gurax.PickListT<${this.cType}>([](Gurax::Value& value) {
			return Gurax::Value_Pointer::GetPointer(value).GetPointerC<${this.cTypeElem}>();
		});
		''')
	DeclareType_WritablePointer(decl as String, cType as String) = this.DeclareType(decl, cType, 'Pointer',
		codePicker = R'''
		${this.cType} ${varName} = args_gurax.Pick<Gurax::Value_Pointer>().GetPointer().GetWritablePointerC<${this.cTypeElem}>();
		if (!${varName}) {
			Error::Issue(ErrorType::MemoryError, "the pointer is not writable");
			return Value::nil();
		}
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.Pick<Gurax::Value_Pointer>().GetPointer().GetWritablePointerC<${this.cTypeElem}>() : nullptr;
		'''
		codePickerVec = R'''
		auto ${varName} = args_gurax.PickListT<${this.cType}>([](Gurax::Value& value) -> ${this.cType} {
			auto p = Gurax::Value_Pointer::GetPointer(value).GetWritablePointerC<${this.cTypeElem}>();
			if (!p) {
				Error::Issue(ErrorType::MemoryError, "the pointer is not writable");
				return nullptr;
			}
			return p;
		});
		''')
	Register(moduleName as String) {`block} = this.RegisterExpr(moduleName, block.EachElem())
	RegisterExpr(moduleName as String, expr as Expr):map:void = {
		if (expr.IsAssign() && expr.right.IsCaller() && expr.right.car == `class) {
			this.RegisterClass(moduleName, expr)
		} else {
			this.RegisterFunction(moduleName, expr)
		}
	}
	RegisterClass(moduleName as String, expr as Expr):map:void = {
		!expr.left.IsIdentifier() && ErrorDone(expr.left, 'Identifier is expected for class name')
		className = expr.left.symbolName
		Println(className)
	}
	RegisterFunction(moduleName as String, expr as Expr):map:void = {
		codeFunctionBody = nil
		if (expr.IsAssign()) {
			!expr.right.IsString() && ErrorDone(expr, 'assigned value must be a string')
			codeFunctionBody = expr.right.string
			expr = expr.left
		}
		typeNameResult = ''
		if (expr.IsBinaryOp()) {
			if (expr.operator.symbol == `as) {
				!expr.right.IsIdentifier() && ErrorDone('invalid format for value type')
				typeNameResult = expr.right.symbolName
			} else {
				ErrorDone(expr, 'invalid format of parameter')
			}
			expr = expr.left
		}
		!expr.IsCaller() && ErrorDone(expr, 'Caller is expected')
		!expr.car.IsIdentifier() && ErrorDone(expr, 'Identifier is expected')
		if (expr.attr.IsSet(`void)) { typeNameResult = 'void' }
		Println(expr.car.symbolName)
		try {
			funcInfo = FuncInfo(this, moduleName, expr.car.symbolName, typeNameResult, codeFunctionBody)
			this.funcInfoTbl.Add(funcInfo)
			expr.EachParam {|exprParam|
				//Println(exprParam)
				listVarFlag = false
				optionFlag = false
				typeName = 'Any'
				if (exprParam.IsBinaryOp()) {
					if (exprParam.operator.symbol == `as) {
						!exprParam.right.IsIdentifier() && ErrorDone('invalid format for value type')
						typeName = exprParam.right.symbolName
					} else {
						ErrorDone(exprParam, 'invalid format of parameter')
					}
					exprParam = exprParam.left
				}
				if (exprParam.IsUnaryOp()) {
					if (exprParam.operator.symbol == `?) {
						optionFlag = true
					} else {
						ErrorDone(exprParam, 'invalid format of parameter')
					}
					exprParam = exprParam.child
				}
				attr = exprParam.attr
				if (exprParam.IsIndexer()) {
					listVarFlag = true
					exprParam = exprParam.car
				}
				!exprParam.IsIdentifier() && ErrorDone(exprParam, 'Identifier is expected in parameter list')
				argInfo = ArgInfo(this, exprParam.symbolName, typeName, attr, listVarFlag, optionFlag)
				funcInfo.argInfoTbl.Add(argInfo)
			}
		} catch {|e|
			ErrorDone(expr, e.text)
		}
	}
	ComposeImplementation() = this.funcInfoTbl:*ComposeImplementation().Join('\n')
	ComposeAssignment(codePrefix as String) = (codePrefix + this.funcInfoTbl:*ComposeAssignment()).Join('\n')
}

Renderer.__init__() = {
	this.DeclareType('void', 'void', 'Nil',
		codeFunctionBody = R'''
		${caller};
		return Gurax::Value::nil();
		''')
	this.DeclareType('any', '', 'Any',
		codePicker = R'''
		Gurax::Value& ${varName} = args_gurax.PickValue();
		'''
		codeFunctionBody = R'''
		${caller};
		return Gurax::Value::nil();
		''')
	this.DeclareType('String@gurax', '', 'String')
	this.DeclareType('Number@gurax', '', 'Number',
		codePicker = R'''
		Gurax::Value_Number& ${varName} = args_gurax.Pick<Gurax::Value_Number>();
		'''
		codePickerVec = R'''
		const Gurax::ValueList& ${varName} = args_gurax.PickList();
		''')
	this.DeclareType('Function@gurax', '', 'Function',
		codePicker = R'''
		RefPtr<Function> ${varName}(args_gurax.PickFunction().Reference());
		'''
		codePickerValidation = R'''
		RefPtr<Function> ${varName}(args_gurax.IsValid()? args_gurax.PickFunction().Reference() : nullptr);
		'''
		codePickerVec = ''
		codeFunctionBody = '')
	this.DeclareType('Stream@gurax', '', 'Stream',
		codePicker = R'''
		RefPtr<Stream> ${varName}(args_gurax.PickStream().Reference());
		'''
		codePickerValidation = R'''
		RefPtr<Stream> ${varName}(args_gurax.IsValid()? args_gurax.PickStream().Reference() : nullptr);
		'''
		codePickerVec = ''
		codeFunctionBody = '')
	this.DeclareType_Number('char')
	this.DeclareType_Number('short')
	this.DeclareType_Number('long')
	this.DeclareType_Number('int')
	this.DeclareType_Number('long_long', 'long long')
	this.DeclareType_Number('float')
	this.DeclareType_Number('double')
	this.DeclareType_Number('unsigned_char', 'unsigned char')
	this.DeclareType_Number('unsigned_short', 'unsigned short')
	this.DeclareType_Number('unsigned_long', 'unsigned long')
	this.DeclareType_Number('unsigned_int', 'unsigned int')
	this.DeclareType_Number('unsigned_long_long', 'unsigned long long')
	this.DeclareType_Number('size_t')
	this.DeclareType_Number('int8_t')
	this.DeclareType_Number('int16_t')
	this.DeclareType_Number('int32_t')
	this.DeclareType_Number('int64_t')
	this.DeclareType_Number('uint8_t')
	this.DeclareType_Number('uint16_t')
	this.DeclareType_Number('uint32_t')
	this.DeclareType_Number('uint64_t')
	this.DeclareType_Number('Char@gurax')
	this.DeclareType_Number('UChar@gurax')
	this.DeclareType_Number('Short@gurax')
	this.DeclareType_Number('UShort@gurax')
	this.DeclareType_Number('Int@gurax')
	this.DeclareType_Number('UInt@gurax')
	this.DeclareType_Number('Long@gurax')
	this.DeclareType_Number('ULong@gurax')
	this.DeclareType_Number('Int8@gurax')
	this.DeclareType_Number('UInt8@gurax')
	this.DeclareType_Number('Int16@gurax')
	this.DeclareType_Number('UInt16@gurax')
	this.DeclareType_Number('Int32@gurax')
	this.DeclareType_Number('UInt32@gurax')
	this.DeclareType_Number('Int64@gurax')
	this.DeclareType_Number('UInt64@gurax')
	this.DeclareType_Number('Float@gurax')
	this.DeclareType_Number('Double@gurax')
	this.DeclareType_Pointer('const_void_p', 'const void*')
	this.DeclareType_WritablePointer('void_p', 'void*')
	this.DeclareType('bool', 'bool', 'Bool',
		codePicker = R'''
		${this.cType} ${varName} = args_gurax.PickBool();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickBool() : false;
		'''
		codePickerVec = R'''
		auto ${varName} = args_gurax.PickListT<bool>(Gurax::Value_${this.vtype}::ValueForVector);
		'''
		codeFunctionBody = R'''
		${this.cType} rtn = ${caller};
		return new Gurax::Value_${this.vtype}(rtn);
		''')
	this.DeclareType('Bool@gurax', 'Bool', 'Bool',
		codePicker = R'''
		${this.cType} ${varName} = args_gurax.PickBool();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickBool() : false;
		'''
		codePickerVec = R'''
		auto ${varName} = args_gurax.PickListT<bool>(Gurax::Value_${this.vtype}::ValueForVector);
		'''
		codeFunctionBody = R'''
		${this.cType} rtn = ${caller};
		return new Gurax::Value_${this.vtype}(rtn);
		''')
	this.DeclareType('const_char_p', 'const char*', 'String',
		codePicker = R'''
		${this.cType} ${varName} = args_gurax.PickString();
		'''
		codePickerValidation = R'''
		${this.cType} ${varName} = args_gurax.IsValid()? args_gurax.PickString() : nullptr;
		'''
		codePickerVec = R'''
		auto ${varName} = args_gurax.PickListT<${this.cType}>(Gurax::Value_${this.vtype}::ValueForVector);
		'''
		codeFunctionBody = R'''
		${this.cType} rtn = ${caller};
		return new Gurax::Value_${this.vtype}(rtn);
		''')
	this.DeclareType('const_char_p_NilIfNull', 'const char*', 'String',
		codeFunctionBody = R'''
		if (${this.cType} rtn = ${caller}) {
			return new Gurax::Value_${this.vtype}(rtn);
		}
		return Gurax::Value::nil();
		''')
}
