#!/usr/bin/env gurax
//==============================================================================
// util.modbuild.gura
//==============================================================================
import(argopt)

//------------------------------------------------------------------------------
// Builder
//------------------------------------------------------------------------------
Builder = class {
	targetName = ''
	pathNameGurd = ''
	pathNameHdr:nil = 'stdafx.h'
	pathNamePch:String = nil
	pathNamesSrc = []
	pathNamesScript = []
	pathNamesObj = []
	dirNamesInc = []
	dirNamesLib = []
	cflags = []
	ldflags = []
	libs = []
	opt = %{}
	dirNameOut = ''
	compiler = ''
	linker = ''
	cflagsBase = []
	ldflagsBase = []
	cflagsCompile = []
	cflagsPreCompile = []
	libsBase = []
	__init__(targetName:String) = {
		this.targetName = targetName
		if (sys.platform == `darwin) {
			this.dirNameOut = 'gnuc'
			this.compiler = 'clang'
			this.linker = 'clang'
			this.cflagsBase = ['-fPIC', '-Wall', '-std=c++14', '-DGURAX_MODULE_SEPARATED']
			this.ldflagsBase = ['-fPIC', '-shared', '-install_name', this.targetName + '.gurd']
			this.cflagsPreCompile = ['-x', 'c++-header']
			this.libsBase = ['stdc++', 'guraxcore']
		}
	}
	ShouldProcess(pathNameTgt:String, pathNamesDep+:String) = {
		this.opt['rebuild'] || !fs.Exists(pathNameTgt) || \
			(fs.Stat(pathNameTgt).mtime < fs.Stat(pathNamesDep):*mtime).Or()
	}
	Exec(pathName:String, args*:String) = {
		this.opt.Get('verbose') && Printf('%s %s\n', pathName, args.Join(' '))
		rtn = (os.Exec(pathName, args*) == 0)
		rtn
	}
	PreCompile() = {
		(!this.pathNameHdr || !this.ShouldProcess(this.pathNamePch, this.pathNameHdr)) && return(true)
		Printf('-- compiling: %s\n', this.pathNameHdr)
		this.Exec(this.compiler, this.cflagsBase*, this.cflagsPreCompile*, this.cflags*,
				  ('-I' + sys.dirInclude), ('-I' + this.dirNamesInc)*,
				  '-o' + this.pathNamePch, this.pathNameHdr)
		
	}
	Compile(pathNameObj:String, pathNameSrc:String) = {
		!this.ShouldProcess(pathNameObj, pathNameSrc) && return(true)
		Printf('-- compiling: %s\n', pathNameSrc)
		this.Exec(this.compiler, this.cflagsBase*, this.cflagsCompile*, this.cflags*,
				  ('-I' + sys.dirInclude), ('-I' + this.dirNamesInc)*,
				  '-o' + pathNameObj, '-c', pathNameSrc)
	}
	Link(pathNameGurd:String, pathNamesObj+:String) = {
		!this.ShouldProcess(pathNameGurd, pathNamesObj*) && return
		if (this.Exec(this.linker, this.ldflagsBase*, this.ldflags*,
					  '-L' + sys.dirLib, ('-L' + this.dirNamesLib)*,
					  '-o' + pathNameGurd, pathNamesObj*,
					  ('-l' + this.libsBase)*, ('-l' + this.libs)*)) {
			Printf('-- generated: %s\n', pathNameGurd)
		}
	}
	Command_build() = {
		!this.PreCompile() && return
		for (pathNameObj in this.pathNamesObj, pathNameSrc in this.pathNamesSrc) {
			!this.Compile(pathNameObj, pathNameSrc) && return
		}
		this.Link(this.pathNameGurd, this.pathNamesObj*)
	}
	Command_clean() = {
		fs.Remove(this.pathNameGurd)
		fs.Remove(this.pathNamesObj)
		this.pathNamePch && fs.Remove(this.pathNamePch)
		Printf('-- cleaned\n')
	}
	Command_install() = {
		for (pathName in (this.pathNameGurd |+| this.pathNamesScript)) {
			Printf('-- installing: %s\n', pathName)
			fs.Copy(pathName, path.Join(sys.dirModule, 'site')):overwrite
		}
	}
	Run() = {
		if (!this.pathNameHdr) {
			// nothing to do
		} elsif (sys.platform == `darwin) {
			this.pathNamePch = path.Join(this.dirNameOut, path.FileName(this.pathNameHdr) + '.gch')
			this.cflagsCompile.Add('-include-pch', this.pathNamePch)
		}
		this.pathNameGurd = path.Join(this.dirNameOut, this.targetName + '.gurd')
		this.pathNamesObj = path.Join(this.dirNameOut, path.BaseName(this.pathNamesSrc)::Replace('/', '_') + '.o')
		!fs.Exists(this.dirNameOut) && fs.CreateDir(this.dirNameOut)
		[argv, this.opt] = argopt.Parser {|p|
			p.AddFlag('verbose', 'v', 'verbose mode')
			p.AddFlag('rebuild', 'r', 'rebuild all sources')
			p.Parse(sys.argv)
		}
		if (argv.IsEmpty()) {
			this.Command_build()
		} elsif (argv[0] == 'clean') {
			this.Command_clean()
		} elsif (argv[0] == 'install') {
			this.Command_install()
		} else {
			sys.cerr.Printf('unknown command: %s\n', argv[0])
			sys.Exit(1)
		}
	}
}
