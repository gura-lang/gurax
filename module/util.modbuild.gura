#!/usr/bin/env gurax
//==============================================================================
// util.modbuild.gura
//==============================================================================
import(argopt)

//------------------------------------------------------------------------------
// PrintHelp
//------------------------------------------------------------------------------
PrintHelp(p:argopt.Parser) = tR'''
Usage: build.gura [options] [commands]
Commands:
  build    build the module
  rebuild  rebuld the module
  clean    clean all the generated files
  install  install the module and other files 
Options:
  ${p.FormatHelp() + '\n'}
'''.Render(sys.cerr)

//------------------------------------------------------------------------------
// CheckUpdate (not used yet)
//------------------------------------------------------------------------------
CheckUpdate(compiler:String, incDirs[]:String, pathNameObj:String, pathNameSrc:String) = {
	buff = B''
	os.Redirect(nil, buff) {
		os.Exec(compiler, '-I' + incDirs, "-MM", pathNameSrc)
	}
	statObj = fs.Stat(pathNameObj)
	buff.Reader().ReadLines {|line|
		if (m = line.Match(r'^[\w\.]+:\s*(.*)') || line.Match(r'^\s+(.*)')) {
			m[1].Sub(r'\\$', '').Strip().SplitReg(r'\s+') {|pathName|
				stat = fs.Stat(pathName)
				(statObj.mtime < stat.mtime) && return(true)
			}
		}
	}
	false
}

//------------------------------------------------------------------------------
// Builder
//------------------------------------------------------------------------------
Builder = class {
	targetName = ''
	pathNameGurd = ''
	pathNameHdr:nil = 'stdafx.h'
	pathNamePch:String = nil
	pathNamesSrc = []
	pathNamesScript = []
	pathNamesObj = []
	dirNamesInc = []
	dirNamesLib = []
	dirNameSysInc = sys.dirInclude
	dirNameSysLib = sys.dirLib
	dirNameSysModule = sys.dirModule
	cflags = []
	cxxflags = []
	ldflags = []
	libs = []
	opt = %{}
	rebuildFlag = false
	errorFlag = false
	nameOut = ''
	dirNameOut = ''
	compiler = ''
	linker = ''
	suffixObj = ''
	cflagsBase = []
	cxxflagsBase = []
	ldflagsBase = []
	cflagsCompile = []
	cxxflagsCompile = []
	cxxflagsPreCompile = []
	libsBase = []
	__init__(targetName:String) = {
		this.targetName = targetName
		if (sys.platform == `mswin) {
			this.nameOut = 'mswin'
			this.compiler = 'cl'
			this.linker = 'link'
			this.suffixObj = '.obj'
			this.cflagsBase = ['/nologo', '/DWIN32', '/D_WINDOWS', '/W3', '/GR', '/EHsc', '/MD',
				'/Zi', '/O2', '/Ob1', '/DNDEBUG', '/DGURAX_MODULE_SEPARATED']
			this.cxxflagsBase = ['/nologo', '/DWIN32', '/D_WINDOWS', '/W3', '/GR', '/EHsc', '/MD',
				'/Zi', '/O2', '/Ob1', '/DNDEBUG', '/DGURAX_MODULE_SEPARATED']
			this.ldflagsBase = ['/nologo', '/DLL', '/VERSION:0.0', '/MACHINE:x64', '/DEBUG', '/INCREMENTAL:NO']
			this.cxxflagsPreCompile = []
			this.libsBase = ['guraxcore', 'kernel32', 'user32', 'gdi32', 'winspool', 'shell32',
				'ole32', 'oleaut32', 'uuid', 'comdlg32', 'advapi32']
		} elsif (sys.platform == `darwin) {
			this.nameOut = 'gnuc'
			this.compiler = 'clang'
			this.linker = 'clang'
			this.suffixObj = '.o'
			this.cflagsBase = ['-fPIC', '-Wall', '-DGURAX_MODULE_SEPARATED']
			this.cxxflagsBase = ['-fPIC', '-Wall', '-std=c++14', '-DGURAX_MODULE_SEPARATED']
			this.ldflagsBase = ['-fPIC', '-shared', '-install_name', this.targetName + '.gurd']
			this.cxxflagsPreCompile = ['-x', 'c++-header']
			this.libsBase = ['stdc++', 'guraxcore']
		}
	}
	ShouldProcess(pathNameTgt:String, pathNamesDep+:String) = {
		this.rebuildFlag || !fs.Exists(pathNameTgt) || \
			(fs.Stat(pathNameTgt).mtime < fs.Stat(pathNamesDep):*mtime).Or()
	}
	Exec(pathName:String, args*:String) = {
		this.opt.Get('verbose') && Printf('%s %s\n', pathName, args.Join(' '))
		os.Exec(pathName, args*) == 0
	}
	PreCompile() = {
		(this.compiler == 'cl') && return(true)
		(!this.pathNameHdr || !this.ShouldProcess(this.pathNamePch, this.pathNameHdr)) && return(true)
		Printf('-- Precompiled Header: %s\n', this.pathNameHdr)
		this.Exec(this.compiler, this.cxxflagsBase*, this.cxxflagsPreCompile*, this.cxxflags*,
					('-I' + this.dirNameSysInc), ('-I' + this.dirNamesInc)*,
					'-o' + this.pathNamePch, this.pathNameHdr)
	}
	Compile(pathNameObj:String, pathNameSrc:String, idx:Number, nSrcs:Number) = {
		!this.ShouldProcess(pathNameObj, pathNameSrc) && return(true)
		nDigits = Format('%d', nSrcs).len
		isCLanguage = pathNameSrc.EndsWith('.c'):icase
		cflags = if (isCLanguage) {
			this.cflagsBase |+| this.cflagsCompile |+| this.cflags
		} else {
			this.cxxflagsBase |+| this.cxxflagsCompile |+| this.cxxflags
		}
		if (this.compiler == 'cl') {
			cflagsPreCompile = if (!this.pathNameHdr || isCLanguage) {
				[]
			} elsif (idx == 0) {
				['/Yc' + this.pathNameHdr, '/Fp' + this.pathNamePch]
			} else {
				['/Yu' + this.pathNameHdr, '/Fp' + this.pathNamePch]
			}
			Printf('-- compiling %*d/%d: ', nDigits, idx + 1, nSrcs)
			this.Exec(this.compiler, cflags*,
						('/I"' + path.Regulate(this.dirNameSysInc) + '"'),
						('/I"' + path.Regulate(this.dirNamesInc) + '"')*,
						cflagsPreCompile*,
						'/Fo' + pathNameObj, '/c', pathNameSrc)
		} else {
			Printf('-- compiling %*d/%d: %s\n', nDigits, idx + 1, nSrcs, pathNameSrc)
			this.Exec(this.compiler, cflags*,
						('-I' + this.dirNameSysInc),
						('-I' + this.dirNamesInc)*,
						'-o' + pathNameObj, '-c', pathNameSrc)
		}
	}
	Link(pathNameGurd:String, pathNamesObj+:String) = {
		!this.ShouldProcess(pathNameGurd, pathNamesObj*) && return(true)
		if (this.linker == 'link') {
			!this.Exec(this.linker, this.ldflagsBase*, this.ldflags*,
						'/LIBPATH:"' + path.Regulate(this.dirNameSysLib) + '"',
						('/LIBPATH:"' + path.Regulate(this.dirNamesLib) + '"')*,
						'/out:' + pathNameGurd, '/pdb:' + pathNameGurd + '.pdb', pathNamesObj*,
						(this.libsBase + '.lib')*, (this.libs + '.lib')*) && return(false)
		} else {
			!this.Exec(this.linker, this.ldflagsBase*, this.ldflags*,
						'-L' + this.dirNameSysLib, ('-L' + this.dirNamesLib)*,
						'-o' + pathNameGurd, pathNamesObj*,
						('-l' + this.libsBase)*, ('-l' + this.libs)*) && return(false)
		}
		Printf('-- generated: %s\n', pathNameGurd)
		true
	}
	Command_build() = {
		!this.PreCompile() && return
		nSrcs = this.pathNamesSrc.len
		for (pathNameObj in this.pathNamesObj, pathNameSrc in this.pathNamesSrc) {|idx|
			!this.Compile(pathNameObj, pathNameSrc, idx, nSrcs) && return(false)
		}
		this.Link(this.pathNameGurd, this.pathNamesObj*)
	}
	Command_rebuild() = {
		this.rebuildFlag = true
		this.Command_build()
	}
	Command_clean() = {
		fs.Remove(this.pathNameGurd)
		fs.Remove(this.pathNamesObj)
		this.pathNamePch && fs.Remove(this.pathNamePch)
		Printf('-- cleaned\n')
		true
	}
	Command_install() = {
		for (pathName in (this.pathNameGurd |+| this.pathNamesScript)) {
			Printf('-- installing: %s\n', pathName)
			fs.Copy(pathName, path.Join(this.dirNameSysModule, 'site')):overwrite
		}
		true
	}
	Run() = {
		[argv, this.opt] = argopt.Parser {|p|
			p.AddFlag('help',		'h', 'print this help')
			p.AddFlag('verbose',	'v', 'verbose mode')
			p.AddFlag('quiet',		'q', 'quiet mode')
			p.AddParam('incdir',	'I', 'include directory', 'DIR')
			p.AddParam('libdir',	'L', 'library directory', 'DIR')
			p.AddParam('moddir',	'M', 'directory to which module files are installed', 'DIR')
			p.AddParam('basedir',	'B', 'base directory for output', 'DIR')
			try {
				[argv, opt] = p.Parse(sys.argv)
			} catch {|e|
				sys.cerr.Println(e.text)
				sys.Exit(1)
			}
			if (opt['help']) {
				PrintHelp(p)
				sys.Exit(1)
			}
			[argv, opt]
		}
		if (dirName = this.opt['incdir']) { this.dirNameSysInc = dirName }
		if (dirName = this.opt['libdir']) { this.dirNameSysLib = dirName }
		if (dirName = this.opt['moddir']) { this.dirNameSysModule = dirName }
		this.dirNameOut = cond(dirName = this.opt['basedir'],
							   path.Join(dirName, this.nameOut), this.nameOut)
		!fs.Exists(this.dirNameOut) && fs.CreateDir(this.dirNameOut):tree
		if (!this.pathNameHdr) {
			// nothing to do
		} elsif (sys.platform == `mswin) {
			this.pathNamePch = path.Join(this.dirNameOut, path.FileName(this.pathNameHdr) + '.pch')
			//this.cxxflagsCompile.Add('/Yu' + this.pathNameHdr, '/Fp' + this.pathNamePch)
		} elsif (sys.platform == `darwin) {
			this.pathNamePch = path.Join(this.dirNameOut, path.FileName(this.pathNameHdr) + '.gch')
			this.cxxflagsCompile.Add('-include-pch', this.pathNamePch)
		}
		this.pathNameGurd = path.Join(this.dirNameOut, this.targetName + '.gurd')
		this.pathNamesObj = path.Join(this.dirNameOut, path.BaseName(this.pathNamesSrc)::Replace('/', '_') + this.suffixObj)
		if (argv.IsEmpty()) { argv.Append('build') }
		argv.Each {|command|
			if (command == 'build') {
				!this.Command_build() && break
			} elsif (command == 'rebuild') {
				!this.Command_rebuild() && break
			} elsif (command == 'clean') {
				!this.Command_clean() && break
			} elsif (command == 'install') {
				!this.Command_install() && break
			} else {
				sys.cerr.Printf('unknown command: %s\n', argv[0])
				sys.Exit(1)
			}
		}
		this
	}
	GetDirNameGuest(dirName:String) = path.Join(sys.dirBase, 'guest', dirName)
}
