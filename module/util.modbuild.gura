#!/usr/bin/env gurax
//==============================================================================
// util.builder.gura
//==============================================================================
import(argopt)

//------------------------------------------------------------------------------
// Builder
//------------------------------------------------------------------------------
Builder = class {
	targetName:String
	pathNameGurd:String
	pathNamesSrc[]:String
	pathNamesObj[]:String
	dirNameOut = 'gnuc'
	dirNamesInc = [sys.dirInclude]
	dirNamesLib = [sys.dirLib]
	cflags = ['-Wall', '-std=c++14', '-DGURAX_MODULE_SEPARATED', '-fPIC']
	ldflags = ['-shared']
	libs = ['stdc++', 'guraxcore']
	__init__(targetName:String, pathNamesSrc[]:String) = {
		this.targetName = targetName
		this.pathNamesSrc = pathNamesSrc
		this.pathNameGurd = path.Join(this.dirNameOut, targetName + '.gurd')
		this.pathNamesObj = path.Join(this.dirNameOut, path.BaseName(this.pathNamesSrc)::Replace('/', '_') + '.o')
	}
	ShouldProcess(pathNameTgt:String, pathNamesDep+:String) = {
		!fs.Exists(pathNameTgt) || \
			(fs.Stat(pathNameTgt).mtime < fs.Stat(pathNamesDep):*mtime).Or()
	}
	Exec(pathName:String, args*:String) = {
		Printf('%s %s\n', pathName, args.Join(' '))
		rtn = (os.Exec(pathName, args*) == 0)
		rtn
	}
	Compile(pathNameObj:String, pathNameSrc:String) = {
		cflags = this.cflags.Clone()
		Printf('-- compiling: %s\n', pathNameSrc)
		this.Exec('gcc', cflags*, ('-I' + this.dirNamesInc)*, '-o', pathNameObj, '-c', pathNameSrc)
	}
	Link(pathNameGurd:String, pathNamesObj+:String) = {
		ldflags = this.ldflags.Clone()
		libs = this.libs.Clone()
		if (this.Exec('gcc', ldflags*, ('-L' + this.dirNamesLib)*, '-o', pathNameGurd, pathNamesObj*, ('-l' + libs)*)) {
			Printf('-- generated: %s\n', pathNameGurd)
		}
	}
	Command_build() = {
		errorFlag = false
		for (pathNameObj in this.pathNamesObj, pathNameSrc in this.pathNamesSrc) {
			if (this.ShouldProcess(pathNameObj, pathNameSrc) && \
				!this.Compile(pathNameObj, pathNameSrc)) {
				return
			}
		}
		if (this.ShouldProcess(this.pathNameGurd, this.pathNamesObj*)) {
			this.Link(this.pathNameGurd, this.pathNamesObj*)
		}
	}
	Command_clean() = {
		fs.Remove(this.pathNameGurd)
		fs.Remove(this.pathNamesObj)
		Printf('-- cleaned\n')
	}
	Run() = {
		!fs.Exists(this.dirNameOut) && fs.CreateDir(this.dirNameOut)
		[argv, opt] = argopt.Parser {|p|
			p.Parse(sys.argv)
		}
		if (argv.IsEmpty()) {
			this.Command_build()
		} elsif (argv[0] == 'clean') {
			this.Command_clean()
		} else {
			sys.cerr.Printf('unknown command: %s\n', argv[0])
			sys.Exit(1)
		}
	}
}
