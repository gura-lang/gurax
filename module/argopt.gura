#!/usr/bin/env gurax
//==============================================================================
// argopt.gura
//==============================================================================

//------------------------------------------------------------------------------
// Entry
//------------------------------------------------------------------------------
Entry = struct {
	type:Symbol = `none
	longName:String = ''
	shortName:String:nil
	help:String:nil
	helpValue:String:nil
	MakeHelpIndex(longNameFlag:Bool, shortNameFlag:Bool) = {
		str = ''
		if (!shortNameFlag) {
			strSep = ''
		} elsif (this.shortName) {
			str += '-' + this.shortName
			strSep = ', '
		} else {
			str += '  '
			strSep = '  '
		}
		if (longNameFlag && this.longName) {
			str += strSep
			str += '--'
			str += this.longName
		}
		if (this.type == `flag) {
			// nothing to do
		} else {
			if (longNameFlag && this.longName) {
				str += '='
			} elsif (shortNameFlag && this.shortName) {
				str += ' '
			}
			str += this.helpValue || 'X'
		}
		str
	}
}

//------------------------------------------------------------------------------
// Parser
//------------------------------------------------------------------------------
Parser = class {
	entries[]:Entry = []
	Parse(argv[]:String) = {
		dictByLongName = %{}
		dictByShortName = %{}
		dictByLongName.Put(this.entries:*longName, this.entries)
		argvRest = []
		opt = %{}
		this.entries.Each {|entry|
			if (entry.shortName) {
				dictByShortName.Put(entry.shortName, entry)
			}
			opt[entry.longName] = nil
		}
		iter = argv.Offset(1)
		while (arg = iter.NextValue()) {
			if ((argBody = arg.StartsWith('--'):rest) && !argBody.IsEmpty()) {
				fields = argBody.Split('=', 1):list
				[longName, value] = cond(fields.len == 1, [fields[0], nil], fields)
				entry = dictByLongName.Get(longName)
				!entry && Error.Raise(Error.CommandError, 'unknown option --%s', longName)
				if (entry.type == `param) {
					!value && Error.Raise(Error.CommandError, 'value must be specified')
					opt[entry.longName] = value
				} else { // entry.type == `flag
					value && Error.Raise(Error.CommandError, 'value is unnecessary')
					opt[entry.longName] = true
				}
			} elsif (shortName = arg.StartsWith('-'):rest) {
				entry = dictByShortName.Get(shortName)
				!entry && Error.Raise(Error.CommandError, 'unknown option -%s', shortName)
				if (entry.type == `param) {
					value = iter.NextValue()
					!value && Error.Raise(Error.CommandError, 'value must be specified')
					opt[entry.longName] = value
				} else { // entry.type == `flag
					opt[entry.longName] = true
				}
			} else {
				argvRest.Add(arg)
			}
		}
		[argvRest, opt]
	}
	AddParam(longName:String, shortName?:String, help?:String, helpValue?:String) = {
		this.entries.Add(Entry(`param, longName, shortName, help, helpValue))
	}
	AddFlag(longName:String, shortName?:String, help?:String) = {
		this.entries.Add(Entry(`flag, longName, shortName, help, nil))
	}
	FormatHelp(longNameFlag:Bool = true, shortNameFlag:Bool = true) = {
		indices = this.entries::MakeHelpIndex(longNameFlag, shortNameFlag)
		Format('%-*s  %s', indices::len.Max(), indices, this.entries:*help)
	}
}
