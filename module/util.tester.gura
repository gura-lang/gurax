#!/usr/bin/env gurax
//==============================================================================
// util.tester.gura
//==============================================================================

TestCase(title:String):void {`block} = {
	PrintTitle(title)
	block.Eval()
}

PrintTitle(title:String) = {
	Printf('======== %s ========\n', title)
}

Tester(expr:Expr, arg%%):void:dynamic_scope:map:[quote] {block?} = {
	Printf('%s ..', expr)
	try {
		rtn = expr.Eval()
		rtnStr = rtn.ToString()
		if (arg.IsSet(`quote)) { rtnStr = rtnStr.Enquote():auto }
		Printf(cond(rtnStr.Find('\n'), '\n%s\n', ' %s\n'), rtnStr):nomap
		block && block(rtn)
	} catch {|e|
		Printf(' %s\n', e.text)
	}
}

PrintPUnit(expr:Expr):void:map = {
	seqIdOffset = 0
	punits = expr.EachPUnit()
	punit = punits.NextValue()
	!punit && return
	seqIdOffset = punit.seqId
	while (punit) {
		Printf('  ##%d %s\n', punit.seqId - seqIdOffset, punit.ToString(seqIdOffset))
		punit = punits.NextValue()
	}
}

PrintPUnitWithLabel(expr:Expr):void:map = {
	Printf('%s\n', expr)
	PrintPUnit(expr)
}

PrintPropSlots(vtype:VType) = {
	propSlots = vtype.__EachPropSlot__():list
	maxLenSymbolName = [propSlots:*symbol:*name:*len*, 16].Max()
	maxLenVTypeFullName = [propSlots:*vtype:*__fullName__:*len*, 12].Max()
	Printf('%s\n', vtype.__fullName__)
	propSlots.Each {|propSlot|
		Printf('  %s%-*s %-*s %s%s\n',
			cond(propSlot.isOfClass, '.', '#'),
			maxLenSymbolName, propSlot.symbol.name,
			maxLenVTypeFullName, propSlot.vtype.__fullName__,
			['', 'R', 'W', 'R/W'][cond(propSlot.IsSet(`R), 1, 0) + cond(propSlot.IsSet(`W), 2, 0)],
			cond(propSlot.IsSet(`nil), ',nil', ''))
	}
}
